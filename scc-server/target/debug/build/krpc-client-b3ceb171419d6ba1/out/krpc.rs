pub mod krpc {
// This file is generated by rust-protobuf 3.4.0. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `krpc.proto`
// Generated for lite runtime

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_4_0;

// @@protoc_insertion_point(message:krpc.schema.ConnectionRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ConnectionRequest {
    // message fields
    // @@protoc_insertion_point(field:krpc.schema.ConnectionRequest.type)
    pub type_: ::protobuf::EnumOrUnknown<connection_request::Type>,
    // @@protoc_insertion_point(field:krpc.schema.ConnectionRequest.client_name)
    pub client_name: ::std::string::String,
    // @@protoc_insertion_point(field:krpc.schema.ConnectionRequest.client_identifier)
    pub client_identifier: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:krpc.schema.ConnectionRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ConnectionRequest {
    fn default() -> &'a ConnectionRequest {
        <ConnectionRequest as ::protobuf::Message>::default_instance()
    }
}

impl ConnectionRequest {
    pub fn new() -> ConnectionRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ConnectionRequest {
    const NAME: &'static str = "ConnectionRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                18 => {
                    self.client_name = is.read_string()?;
                },
                26 => {
                    self.client_identifier = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.type_ != ::protobuf::EnumOrUnknown::new(connection_request::Type::RPC) {
            my_size += ::protobuf::rt::int32_size(1, self.type_.value());
        }
        if !self.client_name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.client_name);
        }
        if !self.client_identifier.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.client_identifier);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.type_ != ::protobuf::EnumOrUnknown::new(connection_request::Type::RPC) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        if !self.client_name.is_empty() {
            os.write_string(2, &self.client_name)?;
        }
        if !self.client_identifier.is_empty() {
            os.write_bytes(3, &self.client_identifier)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ConnectionRequest {
        ConnectionRequest::new()
    }

    fn clear(&mut self) {
        self.type_ = ::protobuf::EnumOrUnknown::new(connection_request::Type::RPC);
        self.client_name.clear();
        self.client_identifier.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ConnectionRequest {
        static instance: ConnectionRequest = ConnectionRequest {
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            client_name: ::std::string::String::new(),
            client_identifier: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `ConnectionRequest`
pub mod connection_request {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:krpc.schema.ConnectionRequest.Type)
    pub enum Type {
        // @@protoc_insertion_point(enum_value:krpc.schema.ConnectionRequest.Type.RPC)
        RPC = 0,
        // @@protoc_insertion_point(enum_value:krpc.schema.ConnectionRequest.Type.STREAM)
        STREAM = 1,
    }

    impl ::protobuf::Enum for Type {
        const NAME: &'static str = "Type";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Type> {
            match value {
                0 => ::std::option::Option::Some(Type::RPC),
                1 => ::std::option::Option::Some(Type::STREAM),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Type> {
            match str {
                "RPC" => ::std::option::Option::Some(Type::RPC),
                "STREAM" => ::std::option::Option::Some(Type::STREAM),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Type] = &[
            Type::RPC,
            Type::STREAM,
        ];
    }

    impl ::std::default::Default for Type {
        fn default() -> Self {
            Type::RPC
        }
    }

}

// @@protoc_insertion_point(message:krpc.schema.ConnectionResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ConnectionResponse {
    // message fields
    // @@protoc_insertion_point(field:krpc.schema.ConnectionResponse.status)
    pub status: ::protobuf::EnumOrUnknown<connection_response::Status>,
    // @@protoc_insertion_point(field:krpc.schema.ConnectionResponse.message)
    pub message: ::std::string::String,
    // @@protoc_insertion_point(field:krpc.schema.ConnectionResponse.client_identifier)
    pub client_identifier: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:krpc.schema.ConnectionResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ConnectionResponse {
    fn default() -> &'a ConnectionResponse {
        <ConnectionResponse as ::protobuf::Message>::default_instance()
    }
}

impl ConnectionResponse {
    pub fn new() -> ConnectionResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ConnectionResponse {
    const NAME: &'static str = "ConnectionResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.status = is.read_enum_or_unknown()?;
                },
                18 => {
                    self.message = is.read_string()?;
                },
                26 => {
                    self.client_identifier = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.status != ::protobuf::EnumOrUnknown::new(connection_response::Status::OK) {
            my_size += ::protobuf::rt::int32_size(1, self.status.value());
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.message);
        }
        if !self.client_identifier.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.client_identifier);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.status != ::protobuf::EnumOrUnknown::new(connection_response::Status::OK) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.status))?;
        }
        if !self.message.is_empty() {
            os.write_string(2, &self.message)?;
        }
        if !self.client_identifier.is_empty() {
            os.write_bytes(3, &self.client_identifier)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ConnectionResponse {
        ConnectionResponse::new()
    }

    fn clear(&mut self) {
        self.status = ::protobuf::EnumOrUnknown::new(connection_response::Status::OK);
        self.message.clear();
        self.client_identifier.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ConnectionResponse {
        static instance: ConnectionResponse = ConnectionResponse {
            status: ::protobuf::EnumOrUnknown::from_i32(0),
            message: ::std::string::String::new(),
            client_identifier: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `ConnectionResponse`
pub mod connection_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:krpc.schema.ConnectionResponse.Status)
    pub enum Status {
        // @@protoc_insertion_point(enum_value:krpc.schema.ConnectionResponse.Status.OK)
        OK = 0,
        // @@protoc_insertion_point(enum_value:krpc.schema.ConnectionResponse.Status.MALFORMED_MESSAGE)
        MALFORMED_MESSAGE = 1,
        // @@protoc_insertion_point(enum_value:krpc.schema.ConnectionResponse.Status.TIMEOUT)
        TIMEOUT = 2,
        // @@protoc_insertion_point(enum_value:krpc.schema.ConnectionResponse.Status.WRONG_TYPE)
        WRONG_TYPE = 3,
    }

    impl ::protobuf::Enum for Status {
        const NAME: &'static str = "Status";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Status> {
            match value {
                0 => ::std::option::Option::Some(Status::OK),
                1 => ::std::option::Option::Some(Status::MALFORMED_MESSAGE),
                2 => ::std::option::Option::Some(Status::TIMEOUT),
                3 => ::std::option::Option::Some(Status::WRONG_TYPE),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Status> {
            match str {
                "OK" => ::std::option::Option::Some(Status::OK),
                "MALFORMED_MESSAGE" => ::std::option::Option::Some(Status::MALFORMED_MESSAGE),
                "TIMEOUT" => ::std::option::Option::Some(Status::TIMEOUT),
                "WRONG_TYPE" => ::std::option::Option::Some(Status::WRONG_TYPE),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Status] = &[
            Status::OK,
            Status::MALFORMED_MESSAGE,
            Status::TIMEOUT,
            Status::WRONG_TYPE,
        ];
    }

    impl ::std::default::Default for Status {
        fn default() -> Self {
            Status::OK
        }
    }

}

// @@protoc_insertion_point(message:krpc.schema.Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Request {
    // message fields
    // @@protoc_insertion_point(field:krpc.schema.Request.calls)
    pub calls: ::std::vec::Vec<ProcedureCall>,
    // special fields
    // @@protoc_insertion_point(special_field:krpc.schema.Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Request {
    fn default() -> &'a Request {
        <Request as ::protobuf::Message>::default_instance()
    }
}

impl Request {
    pub fn new() -> Request {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Request {
    const NAME: &'static str = "Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.calls.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.calls {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.calls {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Request {
        Request::new()
    }

    fn clear(&mut self) {
        self.calls.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Request {
        static instance: Request = Request {
            calls: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:krpc.schema.ProcedureCall)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProcedureCall {
    // message fields
    // @@protoc_insertion_point(field:krpc.schema.ProcedureCall.service)
    pub service: ::std::string::String,
    // @@protoc_insertion_point(field:krpc.schema.ProcedureCall.procedure)
    pub procedure: ::std::string::String,
    // @@protoc_insertion_point(field:krpc.schema.ProcedureCall.service_id)
    pub service_id: u32,
    // @@protoc_insertion_point(field:krpc.schema.ProcedureCall.procedure_id)
    pub procedure_id: u32,
    // @@protoc_insertion_point(field:krpc.schema.ProcedureCall.arguments)
    pub arguments: ::std::vec::Vec<Argument>,
    // special fields
    // @@protoc_insertion_point(special_field:krpc.schema.ProcedureCall.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProcedureCall {
    fn default() -> &'a ProcedureCall {
        <ProcedureCall as ::protobuf::Message>::default_instance()
    }
}

impl ProcedureCall {
    pub fn new() -> ProcedureCall {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ProcedureCall {
    const NAME: &'static str = "ProcedureCall";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.service = is.read_string()?;
                },
                18 => {
                    self.procedure = is.read_string()?;
                },
                32 => {
                    self.service_id = is.read_uint32()?;
                },
                40 => {
                    self.procedure_id = is.read_uint32()?;
                },
                26 => {
                    self.arguments.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.service.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.service);
        }
        if !self.procedure.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.procedure);
        }
        if self.service_id != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.service_id);
        }
        if self.procedure_id != 0 {
            my_size += ::protobuf::rt::uint32_size(5, self.procedure_id);
        }
        for value in &self.arguments {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.service.is_empty() {
            os.write_string(1, &self.service)?;
        }
        if !self.procedure.is_empty() {
            os.write_string(2, &self.procedure)?;
        }
        if self.service_id != 0 {
            os.write_uint32(4, self.service_id)?;
        }
        if self.procedure_id != 0 {
            os.write_uint32(5, self.procedure_id)?;
        }
        for v in &self.arguments {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProcedureCall {
        ProcedureCall::new()
    }

    fn clear(&mut self) {
        self.service.clear();
        self.procedure.clear();
        self.service_id = 0;
        self.procedure_id = 0;
        self.arguments.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProcedureCall {
        static instance: ProcedureCall = ProcedureCall {
            service: ::std::string::String::new(),
            procedure: ::std::string::String::new(),
            service_id: 0,
            procedure_id: 0,
            arguments: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:krpc.schema.Argument)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Argument {
    // message fields
    // @@protoc_insertion_point(field:krpc.schema.Argument.position)
    pub position: u32,
    // @@protoc_insertion_point(field:krpc.schema.Argument.value)
    pub value: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:krpc.schema.Argument.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Argument {
    fn default() -> &'a Argument {
        <Argument as ::protobuf::Message>::default_instance()
    }
}

impl Argument {
    pub fn new() -> Argument {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Argument {
    const NAME: &'static str = "Argument";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.position = is.read_uint32()?;
                },
                18 => {
                    self.value = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.position != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.position);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.position != 0 {
            os.write_uint32(1, self.position)?;
        }
        if !self.value.is_empty() {
            os.write_bytes(2, &self.value)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Argument {
        Argument::new()
    }

    fn clear(&mut self) {
        self.position = 0;
        self.value.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Argument {
        static instance: Argument = Argument {
            position: 0,
            value: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:krpc.schema.Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Response {
    // message fields
    // @@protoc_insertion_point(field:krpc.schema.Response.error)
    pub error: ::protobuf::MessageField<Error>,
    // @@protoc_insertion_point(field:krpc.schema.Response.results)
    pub results: ::std::vec::Vec<ProcedureResult>,
    // special fields
    // @@protoc_insertion_point(special_field:krpc.schema.Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Response {
    fn default() -> &'a Response {
        <Response as ::protobuf::Message>::default_instance()
    }
}

impl Response {
    pub fn new() -> Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Response {
    const NAME: &'static str = "Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.error)?;
                },
                18 => {
                    self.results.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.results {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.error.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.results {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Response {
        Response::new()
    }

    fn clear(&mut self) {
        self.error.clear();
        self.results.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Response {
        static instance: Response = Response {
            error: ::protobuf::MessageField::none(),
            results: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:krpc.schema.ProcedureResult)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProcedureResult {
    // message fields
    // @@protoc_insertion_point(field:krpc.schema.ProcedureResult.error)
    pub error: ::protobuf::MessageField<Error>,
    // @@protoc_insertion_point(field:krpc.schema.ProcedureResult.value)
    pub value: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:krpc.schema.ProcedureResult.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProcedureResult {
    fn default() -> &'a ProcedureResult {
        <ProcedureResult as ::protobuf::Message>::default_instance()
    }
}

impl ProcedureResult {
    pub fn new() -> ProcedureResult {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ProcedureResult {
    const NAME: &'static str = "ProcedureResult";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.error)?;
                },
                18 => {
                    self.value = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.error.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.value.is_empty() {
            os.write_bytes(2, &self.value)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProcedureResult {
        ProcedureResult::new()
    }

    fn clear(&mut self) {
        self.error.clear();
        self.value.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProcedureResult {
        static instance: ProcedureResult = ProcedureResult {
            error: ::protobuf::MessageField::none(),
            value: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:krpc.schema.Error)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Error {
    // message fields
    // @@protoc_insertion_point(field:krpc.schema.Error.service)
    pub service: ::std::string::String,
    // @@protoc_insertion_point(field:krpc.schema.Error.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:krpc.schema.Error.description)
    pub description: ::std::string::String,
    // @@protoc_insertion_point(field:krpc.schema.Error.stack_trace)
    pub stack_trace: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:krpc.schema.Error.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Error {
    fn default() -> &'a Error {
        <Error as ::protobuf::Message>::default_instance()
    }
}

impl Error {
    pub fn new() -> Error {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Error {
    const NAME: &'static str = "Error";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.service = is.read_string()?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                26 => {
                    self.description = is.read_string()?;
                },
                34 => {
                    self.stack_trace = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.service.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.service);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.description);
        }
        if !self.stack_trace.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.stack_trace);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.service.is_empty() {
            os.write_string(1, &self.service)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if !self.description.is_empty() {
            os.write_string(3, &self.description)?;
        }
        if !self.stack_trace.is_empty() {
            os.write_string(4, &self.stack_trace)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Error {
        Error::new()
    }

    fn clear(&mut self) {
        self.service.clear();
        self.name.clear();
        self.description.clear();
        self.stack_trace.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Error {
        static instance: Error = Error {
            service: ::std::string::String::new(),
            name: ::std::string::String::new(),
            description: ::std::string::String::new(),
            stack_trace: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:krpc.schema.StreamUpdate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct StreamUpdate {
    // message fields
    // @@protoc_insertion_point(field:krpc.schema.StreamUpdate.results)
    pub results: ::std::vec::Vec<StreamResult>,
    // special fields
    // @@protoc_insertion_point(special_field:krpc.schema.StreamUpdate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StreamUpdate {
    fn default() -> &'a StreamUpdate {
        <StreamUpdate as ::protobuf::Message>::default_instance()
    }
}

impl StreamUpdate {
    pub fn new() -> StreamUpdate {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for StreamUpdate {
    const NAME: &'static str = "StreamUpdate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.results.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.results {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.results {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StreamUpdate {
        StreamUpdate::new()
    }

    fn clear(&mut self) {
        self.results.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StreamUpdate {
        static instance: StreamUpdate = StreamUpdate {
            results: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:krpc.schema.StreamResult)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct StreamResult {
    // message fields
    // @@protoc_insertion_point(field:krpc.schema.StreamResult.id)
    pub id: u64,
    // @@protoc_insertion_point(field:krpc.schema.StreamResult.result)
    pub result: ::protobuf::MessageField<ProcedureResult>,
    // special fields
    // @@protoc_insertion_point(special_field:krpc.schema.StreamResult.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StreamResult {
    fn default() -> &'a StreamResult {
        <StreamResult as ::protobuf::Message>::default_instance()
    }
}

impl StreamResult {
    pub fn new() -> StreamResult {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for StreamResult {
    const NAME: &'static str = "StreamResult";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_uint64()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.result)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.id);
        }
        if let Some(v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_uint64(1, self.id)?;
        }
        if let Some(v) = self.result.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StreamResult {
        StreamResult::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.result.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StreamResult {
        static instance: StreamResult = StreamResult {
            id: 0,
            result: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:krpc.schema.Services)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Services {
    // message fields
    // @@protoc_insertion_point(field:krpc.schema.Services.services)
    pub services: ::std::vec::Vec<Service>,
    // special fields
    // @@protoc_insertion_point(special_field:krpc.schema.Services.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Services {
    fn default() -> &'a Services {
        <Services as ::protobuf::Message>::default_instance()
    }
}

impl Services {
    pub fn new() -> Services {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Services {
    const NAME: &'static str = "Services";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.services.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.services {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.services {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Services {
        Services::new()
    }

    fn clear(&mut self) {
        self.services.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Services {
        static instance: Services = Services {
            services: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:krpc.schema.Service)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Service {
    // message fields
    // @@protoc_insertion_point(field:krpc.schema.Service.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:krpc.schema.Service.procedures)
    pub procedures: ::std::vec::Vec<Procedure>,
    // @@protoc_insertion_point(field:krpc.schema.Service.classes)
    pub classes: ::std::vec::Vec<Class>,
    // @@protoc_insertion_point(field:krpc.schema.Service.enumerations)
    pub enumerations: ::std::vec::Vec<Enumeration>,
    // @@protoc_insertion_point(field:krpc.schema.Service.exceptions)
    pub exceptions: ::std::vec::Vec<Exception>,
    // @@protoc_insertion_point(field:krpc.schema.Service.documentation)
    pub documentation: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:krpc.schema.Service.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Service {
    fn default() -> &'a Service {
        <Service as ::protobuf::Message>::default_instance()
    }
}

impl Service {
    pub fn new() -> Service {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Service {
    const NAME: &'static str = "Service";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                18 => {
                    self.procedures.push(is.read_message()?);
                },
                26 => {
                    self.classes.push(is.read_message()?);
                },
                34 => {
                    self.enumerations.push(is.read_message()?);
                },
                42 => {
                    self.exceptions.push(is.read_message()?);
                },
                50 => {
                    self.documentation = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        for value in &self.procedures {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.classes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.enumerations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.exceptions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.documentation.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.documentation);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        for v in &self.procedures {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.classes {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.enumerations {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.exceptions {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if !self.documentation.is_empty() {
            os.write_string(6, &self.documentation)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Service {
        Service::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.procedures.clear();
        self.classes.clear();
        self.enumerations.clear();
        self.exceptions.clear();
        self.documentation.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Service {
        static instance: Service = Service {
            name: ::std::string::String::new(),
            procedures: ::std::vec::Vec::new(),
            classes: ::std::vec::Vec::new(),
            enumerations: ::std::vec::Vec::new(),
            exceptions: ::std::vec::Vec::new(),
            documentation: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:krpc.schema.Procedure)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Procedure {
    // message fields
    // @@protoc_insertion_point(field:krpc.schema.Procedure.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:krpc.schema.Procedure.parameters)
    pub parameters: ::std::vec::Vec<Parameter>,
    // @@protoc_insertion_point(field:krpc.schema.Procedure.return_type)
    pub return_type: ::protobuf::MessageField<Type>,
    // @@protoc_insertion_point(field:krpc.schema.Procedure.return_is_nullable)
    pub return_is_nullable: bool,
    // @@protoc_insertion_point(field:krpc.schema.Procedure.game_scenes)
    pub game_scenes: ::std::vec::Vec<::protobuf::EnumOrUnknown<procedure::GameScene>>,
    // @@protoc_insertion_point(field:krpc.schema.Procedure.documentation)
    pub documentation: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:krpc.schema.Procedure.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Procedure {
    fn default() -> &'a Procedure {
        <Procedure as ::protobuf::Message>::default_instance()
    }
}

impl Procedure {
    pub fn new() -> Procedure {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Procedure {
    const NAME: &'static str = "Procedure";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                18 => {
                    self.parameters.push(is.read_message()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.return_type)?;
                },
                32 => {
                    self.return_is_nullable = is.read_bool()?;
                },
                48 => {
                    self.game_scenes.push(is.read_enum_or_unknown()?);
                },
                50 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.game_scenes)?
                },
                42 => {
                    self.documentation = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        for value in &self.parameters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.return_type.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.return_is_nullable != false {
            my_size += 1 + 1;
        }
        for value in &self.game_scenes {
            my_size += ::protobuf::rt::int32_size(6, value.value());
        };
        if !self.documentation.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.documentation);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        for v in &self.parameters {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.return_type.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if self.return_is_nullable != false {
            os.write_bool(4, self.return_is_nullable)?;
        }
        for v in &self.game_scenes {
            os.write_enum(6, ::protobuf::EnumOrUnknown::value(v))?;
        };
        if !self.documentation.is_empty() {
            os.write_string(5, &self.documentation)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Procedure {
        Procedure::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.parameters.clear();
        self.return_type.clear();
        self.return_is_nullable = false;
        self.game_scenes.clear();
        self.documentation.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Procedure {
        static instance: Procedure = Procedure {
            name: ::std::string::String::new(),
            parameters: ::std::vec::Vec::new(),
            return_type: ::protobuf::MessageField::none(),
            return_is_nullable: false,
            game_scenes: ::std::vec::Vec::new(),
            documentation: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `Procedure`
pub mod procedure {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:krpc.schema.Procedure.GameScene)
    pub enum GameScene {
        // @@protoc_insertion_point(enum_value:krpc.schema.Procedure.GameScene.SPACE_CENTER)
        SPACE_CENTER = 0,
        // @@protoc_insertion_point(enum_value:krpc.schema.Procedure.GameScene.FLIGHT)
        FLIGHT = 1,
        // @@protoc_insertion_point(enum_value:krpc.schema.Procedure.GameScene.TRACKING_STATION)
        TRACKING_STATION = 2,
        // @@protoc_insertion_point(enum_value:krpc.schema.Procedure.GameScene.EDITOR_VAB)
        EDITOR_VAB = 3,
        // @@protoc_insertion_point(enum_value:krpc.schema.Procedure.GameScene.EDITOR_SPH)
        EDITOR_SPH = 4,
        // @@protoc_insertion_point(enum_value:krpc.schema.Procedure.GameScene.MISSION_BUILDER)
        MISSION_BUILDER = 5,
    }

    impl ::protobuf::Enum for GameScene {
        const NAME: &'static str = "GameScene";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<GameScene> {
            match value {
                0 => ::std::option::Option::Some(GameScene::SPACE_CENTER),
                1 => ::std::option::Option::Some(GameScene::FLIGHT),
                2 => ::std::option::Option::Some(GameScene::TRACKING_STATION),
                3 => ::std::option::Option::Some(GameScene::EDITOR_VAB),
                4 => ::std::option::Option::Some(GameScene::EDITOR_SPH),
                5 => ::std::option::Option::Some(GameScene::MISSION_BUILDER),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<GameScene> {
            match str {
                "SPACE_CENTER" => ::std::option::Option::Some(GameScene::SPACE_CENTER),
                "FLIGHT" => ::std::option::Option::Some(GameScene::FLIGHT),
                "TRACKING_STATION" => ::std::option::Option::Some(GameScene::TRACKING_STATION),
                "EDITOR_VAB" => ::std::option::Option::Some(GameScene::EDITOR_VAB),
                "EDITOR_SPH" => ::std::option::Option::Some(GameScene::EDITOR_SPH),
                "MISSION_BUILDER" => ::std::option::Option::Some(GameScene::MISSION_BUILDER),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [GameScene] = &[
            GameScene::SPACE_CENTER,
            GameScene::FLIGHT,
            GameScene::TRACKING_STATION,
            GameScene::EDITOR_VAB,
            GameScene::EDITOR_SPH,
            GameScene::MISSION_BUILDER,
        ];
    }

    impl ::std::default::Default for GameScene {
        fn default() -> Self {
            GameScene::SPACE_CENTER
        }
    }

}

// @@protoc_insertion_point(message:krpc.schema.Parameter)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Parameter {
    // message fields
    // @@protoc_insertion_point(field:krpc.schema.Parameter.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:krpc.schema.Parameter.type)
    pub type_: ::protobuf::MessageField<Type>,
    // @@protoc_insertion_point(field:krpc.schema.Parameter.default_value)
    pub default_value: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:krpc.schema.Parameter.nullable)
    pub nullable: bool,
    // special fields
    // @@protoc_insertion_point(special_field:krpc.schema.Parameter.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Parameter {
    fn default() -> &'a Parameter {
        <Parameter as ::protobuf::Message>::default_instance()
    }
}

impl Parameter {
    pub fn new() -> Parameter {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Parameter {
    const NAME: &'static str = "Parameter";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.type_)?;
                },
                26 => {
                    self.default_value = is.read_bytes()?;
                },
                32 => {
                    self.nullable = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if let Some(v) = self.type_.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.default_value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.default_value);
        }
        if self.nullable != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if let Some(v) = self.type_.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if !self.default_value.is_empty() {
            os.write_bytes(3, &self.default_value)?;
        }
        if self.nullable != false {
            os.write_bool(4, self.nullable)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Parameter {
        Parameter::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.type_.clear();
        self.default_value.clear();
        self.nullable = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Parameter {
        static instance: Parameter = Parameter {
            name: ::std::string::String::new(),
            type_: ::protobuf::MessageField::none(),
            default_value: ::std::vec::Vec::new(),
            nullable: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:krpc.schema.Class)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Class {
    // message fields
    // @@protoc_insertion_point(field:krpc.schema.Class.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:krpc.schema.Class.documentation)
    pub documentation: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:krpc.schema.Class.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Class {
    fn default() -> &'a Class {
        <Class as ::protobuf::Message>::default_instance()
    }
}

impl Class {
    pub fn new() -> Class {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Class {
    const NAME: &'static str = "Class";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                18 => {
                    self.documentation = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.documentation.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.documentation);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.documentation.is_empty() {
            os.write_string(2, &self.documentation)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Class {
        Class::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.documentation.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Class {
        static instance: Class = Class {
            name: ::std::string::String::new(),
            documentation: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:krpc.schema.Enumeration)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Enumeration {
    // message fields
    // @@protoc_insertion_point(field:krpc.schema.Enumeration.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:krpc.schema.Enumeration.values)
    pub values: ::std::vec::Vec<EnumerationValue>,
    // @@protoc_insertion_point(field:krpc.schema.Enumeration.documentation)
    pub documentation: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:krpc.schema.Enumeration.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Enumeration {
    fn default() -> &'a Enumeration {
        <Enumeration as ::protobuf::Message>::default_instance()
    }
}

impl Enumeration {
    pub fn new() -> Enumeration {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Enumeration {
    const NAME: &'static str = "Enumeration";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                18 => {
                    self.values.push(is.read_message()?);
                },
                26 => {
                    self.documentation = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        for value in &self.values {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.documentation.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.documentation);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        for v in &self.values {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if !self.documentation.is_empty() {
            os.write_string(3, &self.documentation)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Enumeration {
        Enumeration::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.values.clear();
        self.documentation.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Enumeration {
        static instance: Enumeration = Enumeration {
            name: ::std::string::String::new(),
            values: ::std::vec::Vec::new(),
            documentation: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:krpc.schema.EnumerationValue)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct EnumerationValue {
    // message fields
    // @@protoc_insertion_point(field:krpc.schema.EnumerationValue.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:krpc.schema.EnumerationValue.value)
    pub value: i32,
    // @@protoc_insertion_point(field:krpc.schema.EnumerationValue.documentation)
    pub documentation: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:krpc.schema.EnumerationValue.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EnumerationValue {
    fn default() -> &'a EnumerationValue {
        <EnumerationValue as ::protobuf::Message>::default_instance()
    }
}

impl EnumerationValue {
    pub fn new() -> EnumerationValue {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for EnumerationValue {
    const NAME: &'static str = "EnumerationValue";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                16 => {
                    self.value = is.read_int32()?;
                },
                26 => {
                    self.documentation = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if self.value != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.value);
        }
        if !self.documentation.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.documentation);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if self.value != 0 {
            os.write_int32(2, self.value)?;
        }
        if !self.documentation.is_empty() {
            os.write_string(3, &self.documentation)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EnumerationValue {
        EnumerationValue::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.value = 0;
        self.documentation.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EnumerationValue {
        static instance: EnumerationValue = EnumerationValue {
            name: ::std::string::String::new(),
            value: 0,
            documentation: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:krpc.schema.Exception)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Exception {
    // message fields
    // @@protoc_insertion_point(field:krpc.schema.Exception.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:krpc.schema.Exception.documentation)
    pub documentation: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:krpc.schema.Exception.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Exception {
    fn default() -> &'a Exception {
        <Exception as ::protobuf::Message>::default_instance()
    }
}

impl Exception {
    pub fn new() -> Exception {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Exception {
    const NAME: &'static str = "Exception";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                18 => {
                    self.documentation = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.documentation.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.documentation);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.documentation.is_empty() {
            os.write_string(2, &self.documentation)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Exception {
        Exception::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.documentation.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Exception {
        static instance: Exception = Exception {
            name: ::std::string::String::new(),
            documentation: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:krpc.schema.Type)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Type {
    // message fields
    // @@protoc_insertion_point(field:krpc.schema.Type.code)
    pub code: ::protobuf::EnumOrUnknown<type_::TypeCode>,
    // @@protoc_insertion_point(field:krpc.schema.Type.service)
    pub service: ::std::string::String,
    // @@protoc_insertion_point(field:krpc.schema.Type.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:krpc.schema.Type.types)
    pub types: ::std::vec::Vec<Type>,
    // special fields
    // @@protoc_insertion_point(special_field:krpc.schema.Type.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Type {
    fn default() -> &'a Type {
        <Type as ::protobuf::Message>::default_instance()
    }
}

impl Type {
    pub fn new() -> Type {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Type {
    const NAME: &'static str = "Type";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.code = is.read_enum_or_unknown()?;
                },
                18 => {
                    self.service = is.read_string()?;
                },
                26 => {
                    self.name = is.read_string()?;
                },
                34 => {
                    self.types.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.code != ::protobuf::EnumOrUnknown::new(type_::TypeCode::NONE) {
            my_size += ::protobuf::rt::int32_size(1, self.code.value());
        }
        if !self.service.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.service);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        for value in &self.types {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.code != ::protobuf::EnumOrUnknown::new(type_::TypeCode::NONE) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.code))?;
        }
        if !self.service.is_empty() {
            os.write_string(2, &self.service)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        for v in &self.types {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Type {
        Type::new()
    }

    fn clear(&mut self) {
        self.code = ::protobuf::EnumOrUnknown::new(type_::TypeCode::NONE);
        self.service.clear();
        self.name.clear();
        self.types.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Type {
        static instance: Type = Type {
            code: ::protobuf::EnumOrUnknown::from_i32(0),
            service: ::std::string::String::new(),
            name: ::std::string::String::new(),
            types: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `Type`
pub mod type_ {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:krpc.schema.Type.TypeCode)
    pub enum TypeCode {
        // @@protoc_insertion_point(enum_value:krpc.schema.Type.TypeCode.NONE)
        NONE = 0,
        // @@protoc_insertion_point(enum_value:krpc.schema.Type.TypeCode.DOUBLE)
        DOUBLE = 1,
        // @@protoc_insertion_point(enum_value:krpc.schema.Type.TypeCode.FLOAT)
        FLOAT = 2,
        // @@protoc_insertion_point(enum_value:krpc.schema.Type.TypeCode.SINT32)
        SINT32 = 3,
        // @@protoc_insertion_point(enum_value:krpc.schema.Type.TypeCode.SINT64)
        SINT64 = 4,
        // @@protoc_insertion_point(enum_value:krpc.schema.Type.TypeCode.UINT32)
        UINT32 = 5,
        // @@protoc_insertion_point(enum_value:krpc.schema.Type.TypeCode.UINT64)
        UINT64 = 6,
        // @@protoc_insertion_point(enum_value:krpc.schema.Type.TypeCode.BOOL)
        BOOL = 7,
        // @@protoc_insertion_point(enum_value:krpc.schema.Type.TypeCode.STRING)
        STRING = 8,
        // @@protoc_insertion_point(enum_value:krpc.schema.Type.TypeCode.BYTES)
        BYTES = 9,
        // @@protoc_insertion_point(enum_value:krpc.schema.Type.TypeCode.CLASS)
        CLASS = 100,
        // @@protoc_insertion_point(enum_value:krpc.schema.Type.TypeCode.ENUMERATION)
        ENUMERATION = 101,
        // @@protoc_insertion_point(enum_value:krpc.schema.Type.TypeCode.EVENT)
        EVENT = 200,
        // @@protoc_insertion_point(enum_value:krpc.schema.Type.TypeCode.PROCEDURE_CALL)
        PROCEDURE_CALL = 201,
        // @@protoc_insertion_point(enum_value:krpc.schema.Type.TypeCode.STREAM)
        STREAM = 202,
        // @@protoc_insertion_point(enum_value:krpc.schema.Type.TypeCode.STATUS)
        STATUS = 203,
        // @@protoc_insertion_point(enum_value:krpc.schema.Type.TypeCode.SERVICES)
        SERVICES = 204,
        // @@protoc_insertion_point(enum_value:krpc.schema.Type.TypeCode.TUPLE)
        TUPLE = 300,
        // @@protoc_insertion_point(enum_value:krpc.schema.Type.TypeCode.LIST)
        LIST = 301,
        // @@protoc_insertion_point(enum_value:krpc.schema.Type.TypeCode.SET)
        SET = 302,
        // @@protoc_insertion_point(enum_value:krpc.schema.Type.TypeCode.DICTIONARY)
        DICTIONARY = 303,
    }

    impl ::protobuf::Enum for TypeCode {
        const NAME: &'static str = "TypeCode";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<TypeCode> {
            match value {
                0 => ::std::option::Option::Some(TypeCode::NONE),
                1 => ::std::option::Option::Some(TypeCode::DOUBLE),
                2 => ::std::option::Option::Some(TypeCode::FLOAT),
                3 => ::std::option::Option::Some(TypeCode::SINT32),
                4 => ::std::option::Option::Some(TypeCode::SINT64),
                5 => ::std::option::Option::Some(TypeCode::UINT32),
                6 => ::std::option::Option::Some(TypeCode::UINT64),
                7 => ::std::option::Option::Some(TypeCode::BOOL),
                8 => ::std::option::Option::Some(TypeCode::STRING),
                9 => ::std::option::Option::Some(TypeCode::BYTES),
                100 => ::std::option::Option::Some(TypeCode::CLASS),
                101 => ::std::option::Option::Some(TypeCode::ENUMERATION),
                200 => ::std::option::Option::Some(TypeCode::EVENT),
                201 => ::std::option::Option::Some(TypeCode::PROCEDURE_CALL),
                202 => ::std::option::Option::Some(TypeCode::STREAM),
                203 => ::std::option::Option::Some(TypeCode::STATUS),
                204 => ::std::option::Option::Some(TypeCode::SERVICES),
                300 => ::std::option::Option::Some(TypeCode::TUPLE),
                301 => ::std::option::Option::Some(TypeCode::LIST),
                302 => ::std::option::Option::Some(TypeCode::SET),
                303 => ::std::option::Option::Some(TypeCode::DICTIONARY),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<TypeCode> {
            match str {
                "NONE" => ::std::option::Option::Some(TypeCode::NONE),
                "DOUBLE" => ::std::option::Option::Some(TypeCode::DOUBLE),
                "FLOAT" => ::std::option::Option::Some(TypeCode::FLOAT),
                "SINT32" => ::std::option::Option::Some(TypeCode::SINT32),
                "SINT64" => ::std::option::Option::Some(TypeCode::SINT64),
                "UINT32" => ::std::option::Option::Some(TypeCode::UINT32),
                "UINT64" => ::std::option::Option::Some(TypeCode::UINT64),
                "BOOL" => ::std::option::Option::Some(TypeCode::BOOL),
                "STRING" => ::std::option::Option::Some(TypeCode::STRING),
                "BYTES" => ::std::option::Option::Some(TypeCode::BYTES),
                "CLASS" => ::std::option::Option::Some(TypeCode::CLASS),
                "ENUMERATION" => ::std::option::Option::Some(TypeCode::ENUMERATION),
                "EVENT" => ::std::option::Option::Some(TypeCode::EVENT),
                "PROCEDURE_CALL" => ::std::option::Option::Some(TypeCode::PROCEDURE_CALL),
                "STREAM" => ::std::option::Option::Some(TypeCode::STREAM),
                "STATUS" => ::std::option::Option::Some(TypeCode::STATUS),
                "SERVICES" => ::std::option::Option::Some(TypeCode::SERVICES),
                "TUPLE" => ::std::option::Option::Some(TypeCode::TUPLE),
                "LIST" => ::std::option::Option::Some(TypeCode::LIST),
                "SET" => ::std::option::Option::Some(TypeCode::SET),
                "DICTIONARY" => ::std::option::Option::Some(TypeCode::DICTIONARY),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [TypeCode] = &[
            TypeCode::NONE,
            TypeCode::DOUBLE,
            TypeCode::FLOAT,
            TypeCode::SINT32,
            TypeCode::SINT64,
            TypeCode::UINT32,
            TypeCode::UINT64,
            TypeCode::BOOL,
            TypeCode::STRING,
            TypeCode::BYTES,
            TypeCode::CLASS,
            TypeCode::ENUMERATION,
            TypeCode::EVENT,
            TypeCode::PROCEDURE_CALL,
            TypeCode::STREAM,
            TypeCode::STATUS,
            TypeCode::SERVICES,
            TypeCode::TUPLE,
            TypeCode::LIST,
            TypeCode::SET,
            TypeCode::DICTIONARY,
        ];
    }

    impl ::std::default::Default for TypeCode {
        fn default() -> Self {
            TypeCode::NONE
        }
    }

}

// @@protoc_insertion_point(message:krpc.schema.Tuple)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Tuple {
    // message fields
    // @@protoc_insertion_point(field:krpc.schema.Tuple.items)
    pub items: ::std::vec::Vec<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:krpc.schema.Tuple.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Tuple {
    fn default() -> &'a Tuple {
        <Tuple as ::protobuf::Message>::default_instance()
    }
}

impl Tuple {
    pub fn new() -> Tuple {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Tuple {
    const NAME: &'static str = "Tuple";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.items.push(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.items {
            my_size += ::protobuf::rt::bytes_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.items {
            os.write_bytes(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Tuple {
        Tuple::new()
    }

    fn clear(&mut self) {
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Tuple {
        static instance: Tuple = Tuple {
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:krpc.schema.List)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct List {
    // message fields
    // @@protoc_insertion_point(field:krpc.schema.List.items)
    pub items: ::std::vec::Vec<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:krpc.schema.List.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a List {
    fn default() -> &'a List {
        <List as ::protobuf::Message>::default_instance()
    }
}

impl List {
    pub fn new() -> List {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for List {
    const NAME: &'static str = "List";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.items.push(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.items {
            my_size += ::protobuf::rt::bytes_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.items {
            os.write_bytes(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> List {
        List::new()
    }

    fn clear(&mut self) {
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static List {
        static instance: List = List {
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:krpc.schema.Set)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Set {
    // message fields
    // @@protoc_insertion_point(field:krpc.schema.Set.items)
    pub items: ::std::vec::Vec<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:krpc.schema.Set.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Set {
    fn default() -> &'a Set {
        <Set as ::protobuf::Message>::default_instance()
    }
}

impl Set {
    pub fn new() -> Set {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Set {
    const NAME: &'static str = "Set";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.items.push(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.items {
            my_size += ::protobuf::rt::bytes_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.items {
            os.write_bytes(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Set {
        Set::new()
    }

    fn clear(&mut self) {
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Set {
        static instance: Set = Set {
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:krpc.schema.Dictionary)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Dictionary {
    // message fields
    // @@protoc_insertion_point(field:krpc.schema.Dictionary.entries)
    pub entries: ::std::vec::Vec<DictionaryEntry>,
    // special fields
    // @@protoc_insertion_point(special_field:krpc.schema.Dictionary.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Dictionary {
    fn default() -> &'a Dictionary {
        <Dictionary as ::protobuf::Message>::default_instance()
    }
}

impl Dictionary {
    pub fn new() -> Dictionary {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Dictionary {
    const NAME: &'static str = "Dictionary";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.entries.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.entries {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Dictionary {
        Dictionary::new()
    }

    fn clear(&mut self) {
        self.entries.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Dictionary {
        static instance: Dictionary = Dictionary {
            entries: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:krpc.schema.DictionaryEntry)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DictionaryEntry {
    // message fields
    // @@protoc_insertion_point(field:krpc.schema.DictionaryEntry.key)
    pub key: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:krpc.schema.DictionaryEntry.value)
    pub value: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:krpc.schema.DictionaryEntry.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DictionaryEntry {
    fn default() -> &'a DictionaryEntry {
        <DictionaryEntry as ::protobuf::Message>::default_instance()
    }
}

impl DictionaryEntry {
    pub fn new() -> DictionaryEntry {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for DictionaryEntry {
    const NAME: &'static str = "DictionaryEntry";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.key = is.read_bytes()?;
                },
                18 => {
                    self.value = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.key);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.key.is_empty() {
            os.write_bytes(1, &self.key)?;
        }
        if !self.value.is_empty() {
            os.write_bytes(2, &self.value)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DictionaryEntry {
        DictionaryEntry::new()
    }

    fn clear(&mut self) {
        self.key.clear();
        self.value.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DictionaryEntry {
        static instance: DictionaryEntry = DictionaryEntry {
            key: ::std::vec::Vec::new(),
            value: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:krpc.schema.Stream)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Stream {
    // message fields
    // @@protoc_insertion_point(field:krpc.schema.Stream.id)
    pub id: u64,
    // special fields
    // @@protoc_insertion_point(special_field:krpc.schema.Stream.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Stream {
    fn default() -> &'a Stream {
        <Stream as ::protobuf::Message>::default_instance()
    }
}

impl Stream {
    pub fn new() -> Stream {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Stream {
    const NAME: &'static str = "Stream";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_uint64(1, self.id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Stream {
        Stream::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Stream {
        static instance: Stream = Stream {
            id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:krpc.schema.Event)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Event {
    // message fields
    // @@protoc_insertion_point(field:krpc.schema.Event.stream)
    pub stream: ::protobuf::MessageField<Stream>,
    // special fields
    // @@protoc_insertion_point(special_field:krpc.schema.Event.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Event {
    fn default() -> &'a Event {
        <Event as ::protobuf::Message>::default_instance()
    }
}

impl Event {
    pub fn new() -> Event {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Event {
    const NAME: &'static str = "Event";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.stream)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.stream.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.stream.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Event {
        Event::new()
    }

    fn clear(&mut self) {
        self.stream.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Event {
        static instance: Event = Event {
            stream: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:krpc.schema.Status)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Status {
    // message fields
    // @@protoc_insertion_point(field:krpc.schema.Status.version)
    pub version: ::std::string::String,
    // @@protoc_insertion_point(field:krpc.schema.Status.bytes_read)
    pub bytes_read: u64,
    // @@protoc_insertion_point(field:krpc.schema.Status.bytes_written)
    pub bytes_written: u64,
    // @@protoc_insertion_point(field:krpc.schema.Status.bytes_read_rate)
    pub bytes_read_rate: f32,
    // @@protoc_insertion_point(field:krpc.schema.Status.bytes_written_rate)
    pub bytes_written_rate: f32,
    // @@protoc_insertion_point(field:krpc.schema.Status.rpcs_executed)
    pub rpcs_executed: u64,
    // @@protoc_insertion_point(field:krpc.schema.Status.rpc_rate)
    pub rpc_rate: f32,
    // @@protoc_insertion_point(field:krpc.schema.Status.one_rpc_per_update)
    pub one_rpc_per_update: bool,
    // @@protoc_insertion_point(field:krpc.schema.Status.max_time_per_update)
    pub max_time_per_update: u32,
    // @@protoc_insertion_point(field:krpc.schema.Status.adaptive_rate_control)
    pub adaptive_rate_control: bool,
    // @@protoc_insertion_point(field:krpc.schema.Status.blocking_recv)
    pub blocking_recv: bool,
    // @@protoc_insertion_point(field:krpc.schema.Status.recv_timeout)
    pub recv_timeout: u32,
    // @@protoc_insertion_point(field:krpc.schema.Status.time_per_rpc_update)
    pub time_per_rpc_update: f32,
    // @@protoc_insertion_point(field:krpc.schema.Status.poll_time_per_rpc_update)
    pub poll_time_per_rpc_update: f32,
    // @@protoc_insertion_point(field:krpc.schema.Status.exec_time_per_rpc_update)
    pub exec_time_per_rpc_update: f32,
    // @@protoc_insertion_point(field:krpc.schema.Status.stream_rpcs)
    pub stream_rpcs: u32,
    // @@protoc_insertion_point(field:krpc.schema.Status.stream_rpcs_executed)
    pub stream_rpcs_executed: u64,
    // @@protoc_insertion_point(field:krpc.schema.Status.stream_rpc_rate)
    pub stream_rpc_rate: f32,
    // @@protoc_insertion_point(field:krpc.schema.Status.time_per_stream_update)
    pub time_per_stream_update: f32,
    // special fields
    // @@protoc_insertion_point(special_field:krpc.schema.Status.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Status {
    fn default() -> &'a Status {
        <Status as ::protobuf::Message>::default_instance()
    }
}

impl Status {
    pub fn new() -> Status {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Status {
    const NAME: &'static str = "Status";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.version = is.read_string()?;
                },
                16 => {
                    self.bytes_read = is.read_uint64()?;
                },
                24 => {
                    self.bytes_written = is.read_uint64()?;
                },
                37 => {
                    self.bytes_read_rate = is.read_float()?;
                },
                45 => {
                    self.bytes_written_rate = is.read_float()?;
                },
                48 => {
                    self.rpcs_executed = is.read_uint64()?;
                },
                61 => {
                    self.rpc_rate = is.read_float()?;
                },
                64 => {
                    self.one_rpc_per_update = is.read_bool()?;
                },
                72 => {
                    self.max_time_per_update = is.read_uint32()?;
                },
                80 => {
                    self.adaptive_rate_control = is.read_bool()?;
                },
                88 => {
                    self.blocking_recv = is.read_bool()?;
                },
                96 => {
                    self.recv_timeout = is.read_uint32()?;
                },
                109 => {
                    self.time_per_rpc_update = is.read_float()?;
                },
                117 => {
                    self.poll_time_per_rpc_update = is.read_float()?;
                },
                125 => {
                    self.exec_time_per_rpc_update = is.read_float()?;
                },
                128 => {
                    self.stream_rpcs = is.read_uint32()?;
                },
                136 => {
                    self.stream_rpcs_executed = is.read_uint64()?;
                },
                149 => {
                    self.stream_rpc_rate = is.read_float()?;
                },
                157 => {
                    self.time_per_stream_update = is.read_float()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.version.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.version);
        }
        if self.bytes_read != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.bytes_read);
        }
        if self.bytes_written != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.bytes_written);
        }
        if self.bytes_read_rate != 0. {
            my_size += 1 + 4;
        }
        if self.bytes_written_rate != 0. {
            my_size += 1 + 4;
        }
        if self.rpcs_executed != 0 {
            my_size += ::protobuf::rt::uint64_size(6, self.rpcs_executed);
        }
        if self.rpc_rate != 0. {
            my_size += 1 + 4;
        }
        if self.one_rpc_per_update != false {
            my_size += 1 + 1;
        }
        if self.max_time_per_update != 0 {
            my_size += ::protobuf::rt::uint32_size(9, self.max_time_per_update);
        }
        if self.adaptive_rate_control != false {
            my_size += 1 + 1;
        }
        if self.blocking_recv != false {
            my_size += 1 + 1;
        }
        if self.recv_timeout != 0 {
            my_size += ::protobuf::rt::uint32_size(12, self.recv_timeout);
        }
        if self.time_per_rpc_update != 0. {
            my_size += 1 + 4;
        }
        if self.poll_time_per_rpc_update != 0. {
            my_size += 1 + 4;
        }
        if self.exec_time_per_rpc_update != 0. {
            my_size += 1 + 4;
        }
        if self.stream_rpcs != 0 {
            my_size += ::protobuf::rt::uint32_size(16, self.stream_rpcs);
        }
        if self.stream_rpcs_executed != 0 {
            my_size += ::protobuf::rt::uint64_size(17, self.stream_rpcs_executed);
        }
        if self.stream_rpc_rate != 0. {
            my_size += 2 + 4;
        }
        if self.time_per_stream_update != 0. {
            my_size += 2 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.version.is_empty() {
            os.write_string(1, &self.version)?;
        }
        if self.bytes_read != 0 {
            os.write_uint64(2, self.bytes_read)?;
        }
        if self.bytes_written != 0 {
            os.write_uint64(3, self.bytes_written)?;
        }
        if self.bytes_read_rate != 0. {
            os.write_float(4, self.bytes_read_rate)?;
        }
        if self.bytes_written_rate != 0. {
            os.write_float(5, self.bytes_written_rate)?;
        }
        if self.rpcs_executed != 0 {
            os.write_uint64(6, self.rpcs_executed)?;
        }
        if self.rpc_rate != 0. {
            os.write_float(7, self.rpc_rate)?;
        }
        if self.one_rpc_per_update != false {
            os.write_bool(8, self.one_rpc_per_update)?;
        }
        if self.max_time_per_update != 0 {
            os.write_uint32(9, self.max_time_per_update)?;
        }
        if self.adaptive_rate_control != false {
            os.write_bool(10, self.adaptive_rate_control)?;
        }
        if self.blocking_recv != false {
            os.write_bool(11, self.blocking_recv)?;
        }
        if self.recv_timeout != 0 {
            os.write_uint32(12, self.recv_timeout)?;
        }
        if self.time_per_rpc_update != 0. {
            os.write_float(13, self.time_per_rpc_update)?;
        }
        if self.poll_time_per_rpc_update != 0. {
            os.write_float(14, self.poll_time_per_rpc_update)?;
        }
        if self.exec_time_per_rpc_update != 0. {
            os.write_float(15, self.exec_time_per_rpc_update)?;
        }
        if self.stream_rpcs != 0 {
            os.write_uint32(16, self.stream_rpcs)?;
        }
        if self.stream_rpcs_executed != 0 {
            os.write_uint64(17, self.stream_rpcs_executed)?;
        }
        if self.stream_rpc_rate != 0. {
            os.write_float(18, self.stream_rpc_rate)?;
        }
        if self.time_per_stream_update != 0. {
            os.write_float(19, self.time_per_stream_update)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Status {
        Status::new()
    }

    fn clear(&mut self) {
        self.version.clear();
        self.bytes_read = 0;
        self.bytes_written = 0;
        self.bytes_read_rate = 0.;
        self.bytes_written_rate = 0.;
        self.rpcs_executed = 0;
        self.rpc_rate = 0.;
        self.one_rpc_per_update = false;
        self.max_time_per_update = 0;
        self.adaptive_rate_control = false;
        self.blocking_recv = false;
        self.recv_timeout = 0;
        self.time_per_rpc_update = 0.;
        self.poll_time_per_rpc_update = 0.;
        self.exec_time_per_rpc_update = 0.;
        self.stream_rpcs = 0;
        self.stream_rpcs_executed = 0;
        self.stream_rpc_rate = 0.;
        self.time_per_stream_update = 0.;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Status {
        static instance: Status = Status {
            version: ::std::string::String::new(),
            bytes_read: 0,
            bytes_written: 0,
            bytes_read_rate: 0.,
            bytes_written_rate: 0.,
            rpcs_executed: 0,
            rpc_rate: 0.,
            one_rpc_per_update: false,
            max_time_per_update: 0,
            adaptive_rate_control: false,
            blocking_recv: false,
            recv_timeout: 0,
            time_per_rpc_update: 0.,
            poll_time_per_rpc_update: 0.,
            exec_time_per_rpc_update: 0.,
            stream_rpcs: 0,
            stream_rpcs_executed: 0,
            stream_rpc_rate: 0.,
            time_per_stream_update: 0.,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:krpc.schema.MultiplexedRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiplexedRequest {
    // message fields
    // @@protoc_insertion_point(field:krpc.schema.MultiplexedRequest.connection_request)
    pub connection_request: ::protobuf::MessageField<ConnectionRequest>,
    // @@protoc_insertion_point(field:krpc.schema.MultiplexedRequest.request)
    pub request: ::protobuf::MessageField<Request>,
    // special fields
    // @@protoc_insertion_point(special_field:krpc.schema.MultiplexedRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiplexedRequest {
    fn default() -> &'a MultiplexedRequest {
        <MultiplexedRequest as ::protobuf::Message>::default_instance()
    }
}

impl MultiplexedRequest {
    pub fn new() -> MultiplexedRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MultiplexedRequest {
    const NAME: &'static str = "MultiplexedRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.connection_request)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.request)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.connection_request.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.request.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.connection_request.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.request.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiplexedRequest {
        MultiplexedRequest::new()
    }

    fn clear(&mut self) {
        self.connection_request.clear();
        self.request.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiplexedRequest {
        static instance: MultiplexedRequest = MultiplexedRequest {
            connection_request: ::protobuf::MessageField::none(),
            request: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:krpc.schema.MultiplexedResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiplexedResponse {
    // message fields
    // @@protoc_insertion_point(field:krpc.schema.MultiplexedResponse.response)
    pub response: ::protobuf::MessageField<Response>,
    // @@protoc_insertion_point(field:krpc.schema.MultiplexedResponse.stream_update)
    pub stream_update: ::protobuf::MessageField<StreamUpdate>,
    // special fields
    // @@protoc_insertion_point(special_field:krpc.schema.MultiplexedResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiplexedResponse {
    fn default() -> &'a MultiplexedResponse {
        <MultiplexedResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiplexedResponse {
    pub fn new() -> MultiplexedResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MultiplexedResponse {
    const NAME: &'static str = "MultiplexedResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.response)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.stream_update)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.stream_update.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.response.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.stream_update.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiplexedResponse {
        MultiplexedResponse::new()
    }

    fn clear(&mut self) {
        self.response.clear();
        self.stream_update.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiplexedResponse {
        static instance: MultiplexedResponse = MultiplexedResponse {
            response: ::protobuf::MessageField::none(),
            stream_update: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

}