#[allow(clippy::type_complexity)]
pub mod docking_camera {
    use crate::{
        schema::{ToArgument, FromResponse},
        error::RpcError,
    };
    pub struct DockingCamera {
        pub client: ::std::sync::Arc<crate::Client>,
    }
    impl DockingCamera {
        pub fn new(client: ::std::sync::Arc<crate::Client>) -> Self {
            Self { client }
        }
    }
    crate::schema::rpc_object!(Camera);
    impl DockingCamera {
        pub(crate) fn camera_call(
            &self,
            part: &crate::services::space_center::Part,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "DockingCamera",
                    "Camera",
                    vec![part.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn camera_stream(
            &self,
            part: &crate::services::space_center::Part,
        ) -> Result<
            crate::stream::Stream<crate::services::docking_camera::Camera>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.camera_call(part)?)
        }
        pub fn camera(
            &self,
            part: &crate::services::space_center::Part,
        ) -> Result<crate::services::docking_camera::Camera, RpcError> {
            let request = crate::schema::Request::from(self.camera_call(part)?);
            let response = self.client.call(request)?;
            <crate::services::docking_camera::Camera>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Camera {
        pub(crate) fn get_image_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "DockingCamera",
                    "Camera_get_Image",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_image_stream(
            &self,
        ) -> Result<crate::stream::Stream<Vec<u8>>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_image_call()?)
        }
        pub fn get_image(&self) -> Result<Vec<u8>, RpcError> {
            let request = crate::schema::Request::from(self.get_image_call()?);
            let response = self.client.call(request)?;
            <Vec<u8>>::from_response(response, self.client.clone())
        }
    }
    impl Camera {
        pub(crate) fn get_part_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "DockingCamera",
                    "Camera_get_Part",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_part_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::Part>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_part_call()?)
        }
        pub fn get_part(&self) -> Result<crate::services::space_center::Part, RpcError> {
            let request = crate::schema::Request::from(self.get_part_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::Part>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl DockingCamera {
        pub(crate) fn get_available_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "DockingCamera",
                    "get_Available",
                    vec![],
                ),
            )
        }
        pub fn get_available_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_available_call()?)
        }
        pub fn get_available(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_available_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
}
#[allow(clippy::type_complexity)]
pub mod drawing {
    use crate::{
        schema::{ToArgument, FromResponse},
        error::RpcError,
    };
    pub struct Drawing {
        pub client: ::std::sync::Arc<crate::Client>,
    }
    impl Drawing {
        pub fn new(client: ::std::sync::Arc<crate::Client>) -> Self {
            Self { client }
        }
    }
    crate::schema::rpc_object!(Line);
    crate::schema::rpc_object!(Polygon);
    crate::schema::rpc_object!(Text);
    impl Drawing {
        pub(crate) fn add_direction_call(
            &self,
            direction: (f64, f64, f64),
            reference_frame: &crate::services::space_center::ReferenceFrame,
            length: f32,
            visible: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "Drawing",
                    "AddDirection",
                    vec![
                        direction.to_argument(0usize as u32) ?, reference_frame
                        .to_argument(1usize as u32) ?, length.to_argument(2usize as u32)
                        ?, visible.to_argument(3usize as u32) ?
                    ],
                ),
            )
        }
        pub fn add_direction_stream(
            &self,
            direction: (f64, f64, f64),
            reference_frame: &crate::services::space_center::ReferenceFrame,
            length: f32,
            visible: bool,
        ) -> Result<crate::stream::Stream<crate::services::drawing::Line>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.add_direction_call(direction, reference_frame, length, visible)?,
            )
        }
        pub fn add_direction(
            &self,
            direction: (f64, f64, f64),
            reference_frame: &crate::services::space_center::ReferenceFrame,
            length: f32,
            visible: bool,
        ) -> Result<crate::services::drawing::Line, RpcError> {
            let request = crate::schema::Request::from(
                self.add_direction_call(direction, reference_frame, length, visible)?,
            );
            let response = self.client.call(request)?;
            <crate::services::drawing::Line>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Drawing {
        pub(crate) fn add_direction_from_com_call(
            &self,
            direction: (f64, f64, f64),
            reference_frame: &crate::services::space_center::ReferenceFrame,
            length: f32,
            visible: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "Drawing",
                    "AddDirectionFromCom",
                    vec![
                        direction.to_argument(0usize as u32) ?, reference_frame
                        .to_argument(1usize as u32) ?, length.to_argument(2usize as u32)
                        ?, visible.to_argument(3usize as u32) ?
                    ],
                ),
            )
        }
        pub fn add_direction_from_com_stream(
            &self,
            direction: (f64, f64, f64),
            reference_frame: &crate::services::space_center::ReferenceFrame,
            length: f32,
            visible: bool,
        ) -> Result<crate::stream::Stream<crate::services::drawing::Line>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self
                    .add_direction_from_com_call(
                        direction,
                        reference_frame,
                        length,
                        visible,
                    )?,
            )
        }
        pub fn add_direction_from_com(
            &self,
            direction: (f64, f64, f64),
            reference_frame: &crate::services::space_center::ReferenceFrame,
            length: f32,
            visible: bool,
        ) -> Result<crate::services::drawing::Line, RpcError> {
            let request = crate::schema::Request::from(
                self
                    .add_direction_from_com_call(
                        direction,
                        reference_frame,
                        length,
                        visible,
                    )?,
            );
            let response = self.client.call(request)?;
            <crate::services::drawing::Line>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Drawing {
        pub(crate) fn add_line_call(
            &self,
            start: (f64, f64, f64),
            end: (f64, f64, f64),
            reference_frame: &crate::services::space_center::ReferenceFrame,
            visible: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "Drawing",
                    "AddLine",
                    vec![
                        start.to_argument(0usize as u32) ?, end.to_argument(1usize as
                        u32) ?, reference_frame.to_argument(2usize as u32) ?, visible
                        .to_argument(3usize as u32) ?
                    ],
                ),
            )
        }
        pub fn add_line_stream(
            &self,
            start: (f64, f64, f64),
            end: (f64, f64, f64),
            reference_frame: &crate::services::space_center::ReferenceFrame,
            visible: bool,
        ) -> Result<crate::stream::Stream<crate::services::drawing::Line>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.add_line_call(start, end, reference_frame, visible)?,
            )
        }
        pub fn add_line(
            &self,
            start: (f64, f64, f64),
            end: (f64, f64, f64),
            reference_frame: &crate::services::space_center::ReferenceFrame,
            visible: bool,
        ) -> Result<crate::services::drawing::Line, RpcError> {
            let request = crate::schema::Request::from(
                self.add_line_call(start, end, reference_frame, visible)?,
            );
            let response = self.client.call(request)?;
            <crate::services::drawing::Line>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Drawing {
        pub(crate) fn add_polygon_call(
            &self,
            vertices: Vec<(f64, f64, f64)>,
            reference_frame: &crate::services::space_center::ReferenceFrame,
            visible: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "Drawing",
                    "AddPolygon",
                    vec![
                        vertices.to_argument(0usize as u32) ?, reference_frame
                        .to_argument(1usize as u32) ?, visible.to_argument(2usize as u32)
                        ?
                    ],
                ),
            )
        }
        pub fn add_polygon_stream(
            &self,
            vertices: Vec<(f64, f64, f64)>,
            reference_frame: &crate::services::space_center::ReferenceFrame,
            visible: bool,
        ) -> Result<crate::stream::Stream<crate::services::drawing::Polygon>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.add_polygon_call(vertices, reference_frame, visible)?,
            )
        }
        pub fn add_polygon(
            &self,
            vertices: Vec<(f64, f64, f64)>,
            reference_frame: &crate::services::space_center::ReferenceFrame,
            visible: bool,
        ) -> Result<crate::services::drawing::Polygon, RpcError> {
            let request = crate::schema::Request::from(
                self.add_polygon_call(vertices, reference_frame, visible)?,
            );
            let response = self.client.call(request)?;
            <crate::services::drawing::Polygon>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Drawing {
        pub(crate) fn add_text_call(
            &self,
            text: String,
            reference_frame: &crate::services::space_center::ReferenceFrame,
            position: (f64, f64, f64),
            rotation: (f64, f64, f64, f64),
            visible: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "Drawing",
                    "AddText",
                    vec![
                        text.to_argument(0usize as u32) ?, reference_frame
                        .to_argument(1usize as u32) ?, position.to_argument(2usize as
                        u32) ?, rotation.to_argument(3usize as u32) ?, visible
                        .to_argument(4usize as u32) ?
                    ],
                ),
            )
        }
        pub fn add_text_stream(
            &self,
            text: String,
            reference_frame: &crate::services::space_center::ReferenceFrame,
            position: (f64, f64, f64),
            rotation: (f64, f64, f64, f64),
            visible: bool,
        ) -> Result<crate::stream::Stream<crate::services::drawing::Text>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.add_text_call(text, reference_frame, position, rotation, visible)?,
            )
        }
        pub fn add_text(
            &self,
            text: String,
            reference_frame: &crate::services::space_center::ReferenceFrame,
            position: (f64, f64, f64),
            rotation: (f64, f64, f64, f64),
            visible: bool,
        ) -> Result<crate::services::drawing::Text, RpcError> {
            let request = crate::schema::Request::from(
                self.add_text_call(text, reference_frame, position, rotation, visible)?,
            );
            let response = self.client.call(request)?;
            <crate::services::drawing::Text>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Drawing {
        pub(crate) fn clear_call(
            &self,
            client_only: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "Drawing",
                    "Clear",
                    vec![client_only.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn clear_stream(
            &self,
            client_only: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.clear_call(client_only)?,
            )
        }
        pub fn clear(&self, client_only: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.clear_call(client_only)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Line {
        pub(crate) fn remove_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "Drawing",
                    "Line_Remove",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn remove_stream(&self) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.remove_call()?)
        }
        pub fn remove(&self) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.remove_call()?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Line {
        pub(crate) fn get_color_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "Drawing",
                    "Line_get_Color",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_color_stream(
            &self,
        ) -> Result<crate::stream::Stream<(f64, f64, f64)>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_color_call()?)
        }
        pub fn get_color(&self) -> Result<(f64, f64, f64), RpcError> {
            let request = crate::schema::Request::from(self.get_color_call()?);
            let response = self.client.call(request)?;
            <(f64, f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl Line {
        pub(crate) fn get_end_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "Drawing",
                    "Line_get_End",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_end_stream(
            &self,
        ) -> Result<crate::stream::Stream<(f64, f64, f64)>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_end_call()?)
        }
        pub fn get_end(&self) -> Result<(f64, f64, f64), RpcError> {
            let request = crate::schema::Request::from(self.get_end_call()?);
            let response = self.client.call(request)?;
            <(f64, f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl Line {
        pub(crate) fn get_material_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "Drawing",
                    "Line_get_Material",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_material_stream(
            &self,
        ) -> Result<crate::stream::Stream<String>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_material_call()?)
        }
        pub fn get_material(&self) -> Result<String, RpcError> {
            let request = crate::schema::Request::from(self.get_material_call()?);
            let response = self.client.call(request)?;
            <String>::from_response(response, self.client.clone())
        }
    }
    impl Line {
        pub(crate) fn get_reference_frame_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "Drawing",
                    "Line_get_ReferenceFrame",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_reference_frame_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::ReferenceFrame>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_reference_frame_call()?,
            )
        }
        pub fn get_reference_frame(
            &self,
        ) -> Result<crate::services::space_center::ReferenceFrame, RpcError> {
            let request = crate::schema::Request::from(self.get_reference_frame_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::ReferenceFrame>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Line {
        pub(crate) fn get_start_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "Drawing",
                    "Line_get_Start",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_start_stream(
            &self,
        ) -> Result<crate::stream::Stream<(f64, f64, f64)>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_start_call()?)
        }
        pub fn get_start(&self) -> Result<(f64, f64, f64), RpcError> {
            let request = crate::schema::Request::from(self.get_start_call()?);
            let response = self.client.call(request)?;
            <(f64, f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl Line {
        pub(crate) fn get_thickness_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "Drawing",
                    "Line_get_Thickness",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_thickness_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_thickness_call()?)
        }
        pub fn get_thickness(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_thickness_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Line {
        pub(crate) fn get_visible_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "Drawing",
                    "Line_get_Visible",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_visible_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_visible_call()?)
        }
        pub fn get_visible(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_visible_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Line {
        pub(crate) fn set_color_call(
            &self,
            value: (f64, f64, f64),
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "Drawing",
                    "Line_set_Color",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_color_stream(
            &self,
            value: (f64, f64, f64),
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.set_color_call(value)?)
        }
        pub fn set_color(&self, value: (f64, f64, f64)) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_color_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Line {
        pub(crate) fn set_end_call(
            &self,
            value: (f64, f64, f64),
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "Drawing",
                    "Line_set_End",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_end_stream(
            &self,
            value: (f64, f64, f64),
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.set_end_call(value)?)
        }
        pub fn set_end(&self, value: (f64, f64, f64)) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_end_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Line {
        pub(crate) fn set_material_call(
            &self,
            value: String,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "Drawing",
                    "Line_set_Material",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_material_stream(
            &self,
            value: String,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_material_call(value)?,
            )
        }
        pub fn set_material(&self, value: String) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_material_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Line {
        pub(crate) fn set_reference_frame_call(
            &self,
            value: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "Drawing",
                    "Line_set_ReferenceFrame",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_reference_frame_stream(
            &self,
            value: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_reference_frame_call(value)?,
            )
        }
        pub fn set_reference_frame(
            &self,
            value: &crate::services::space_center::ReferenceFrame,
        ) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_reference_frame_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Line {
        pub(crate) fn set_start_call(
            &self,
            value: (f64, f64, f64),
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "Drawing",
                    "Line_set_Start",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_start_stream(
            &self,
            value: (f64, f64, f64),
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.set_start_call(value)?)
        }
        pub fn set_start(&self, value: (f64, f64, f64)) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_start_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Line {
        pub(crate) fn set_thickness_call(
            &self,
            value: f32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "Drawing",
                    "Line_set_Thickness",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_thickness_stream(
            &self,
            value: f32,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_thickness_call(value)?,
            )
        }
        pub fn set_thickness(&self, value: f32) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_thickness_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Line {
        pub(crate) fn set_visible_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "Drawing",
                    "Line_set_Visible",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_visible_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_visible_call(value)?,
            )
        }
        pub fn set_visible(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_visible_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Polygon {
        pub(crate) fn remove_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "Drawing",
                    "Polygon_Remove",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn remove_stream(&self) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.remove_call()?)
        }
        pub fn remove(&self) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.remove_call()?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Polygon {
        pub(crate) fn get_color_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "Drawing",
                    "Polygon_get_Color",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_color_stream(
            &self,
        ) -> Result<crate::stream::Stream<(f64, f64, f64)>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_color_call()?)
        }
        pub fn get_color(&self) -> Result<(f64, f64, f64), RpcError> {
            let request = crate::schema::Request::from(self.get_color_call()?);
            let response = self.client.call(request)?;
            <(f64, f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl Polygon {
        pub(crate) fn get_material_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "Drawing",
                    "Polygon_get_Material",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_material_stream(
            &self,
        ) -> Result<crate::stream::Stream<String>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_material_call()?)
        }
        pub fn get_material(&self) -> Result<String, RpcError> {
            let request = crate::schema::Request::from(self.get_material_call()?);
            let response = self.client.call(request)?;
            <String>::from_response(response, self.client.clone())
        }
    }
    impl Polygon {
        pub(crate) fn get_reference_frame_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "Drawing",
                    "Polygon_get_ReferenceFrame",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_reference_frame_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::ReferenceFrame>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_reference_frame_call()?,
            )
        }
        pub fn get_reference_frame(
            &self,
        ) -> Result<crate::services::space_center::ReferenceFrame, RpcError> {
            let request = crate::schema::Request::from(self.get_reference_frame_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::ReferenceFrame>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Polygon {
        pub(crate) fn get_thickness_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "Drawing",
                    "Polygon_get_Thickness",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_thickness_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_thickness_call()?)
        }
        pub fn get_thickness(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_thickness_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Polygon {
        pub(crate) fn get_vertices_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "Drawing",
                    "Polygon_get_Vertices",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_vertices_stream(
            &self,
        ) -> Result<crate::stream::Stream<Vec<(f64, f64, f64)>>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_vertices_call()?)
        }
        pub fn get_vertices(&self) -> Result<Vec<(f64, f64, f64)>, RpcError> {
            let request = crate::schema::Request::from(self.get_vertices_call()?);
            let response = self.client.call(request)?;
            <Vec<(f64, f64, f64)>>::from_response(response, self.client.clone())
        }
    }
    impl Polygon {
        pub(crate) fn get_visible_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "Drawing",
                    "Polygon_get_Visible",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_visible_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_visible_call()?)
        }
        pub fn get_visible(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_visible_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Polygon {
        pub(crate) fn set_color_call(
            &self,
            value: (f64, f64, f64),
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "Drawing",
                    "Polygon_set_Color",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_color_stream(
            &self,
            value: (f64, f64, f64),
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.set_color_call(value)?)
        }
        pub fn set_color(&self, value: (f64, f64, f64)) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_color_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Polygon {
        pub(crate) fn set_material_call(
            &self,
            value: String,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "Drawing",
                    "Polygon_set_Material",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_material_stream(
            &self,
            value: String,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_material_call(value)?,
            )
        }
        pub fn set_material(&self, value: String) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_material_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Polygon {
        pub(crate) fn set_reference_frame_call(
            &self,
            value: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "Drawing",
                    "Polygon_set_ReferenceFrame",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_reference_frame_stream(
            &self,
            value: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_reference_frame_call(value)?,
            )
        }
        pub fn set_reference_frame(
            &self,
            value: &crate::services::space_center::ReferenceFrame,
        ) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_reference_frame_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Polygon {
        pub(crate) fn set_thickness_call(
            &self,
            value: f32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "Drawing",
                    "Polygon_set_Thickness",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_thickness_stream(
            &self,
            value: f32,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_thickness_call(value)?,
            )
        }
        pub fn set_thickness(&self, value: f32) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_thickness_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Polygon {
        pub(crate) fn set_vertices_call(
            &self,
            value: Vec<(f64, f64, f64)>,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "Drawing",
                    "Polygon_set_Vertices",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_vertices_stream(
            &self,
            value: Vec<(f64, f64, f64)>,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_vertices_call(value)?,
            )
        }
        pub fn set_vertices(&self, value: Vec<(f64, f64, f64)>) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_vertices_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Polygon {
        pub(crate) fn set_visible_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "Drawing",
                    "Polygon_set_Visible",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_visible_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_visible_call(value)?,
            )
        }
        pub fn set_visible(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_visible_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Text {
        pub(crate) fn remove_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "Drawing",
                    "Text_Remove",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn remove_stream(&self) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.remove_call()?)
        }
        pub fn remove(&self) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.remove_call()?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Text {
        pub(crate) fn get_alignment_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "Drawing",
                    "Text_get_Alignment",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_alignment_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::ui::TextAlignment>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_alignment_call()?)
        }
        pub fn get_alignment(
            &self,
        ) -> Result<crate::services::ui::TextAlignment, RpcError> {
            let request = crate::schema::Request::from(self.get_alignment_call()?);
            let response = self.client.call(request)?;
            <crate::services::ui::TextAlignment>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Text {
        pub(crate) fn get_anchor_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "Drawing",
                    "Text_get_Anchor",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_anchor_stream(
            &self,
        ) -> Result<crate::stream::Stream<crate::services::ui::TextAnchor>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_anchor_call()?)
        }
        pub fn get_anchor(&self) -> Result<crate::services::ui::TextAnchor, RpcError> {
            let request = crate::schema::Request::from(self.get_anchor_call()?);
            let response = self.client.call(request)?;
            <crate::services::ui::TextAnchor>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Text {
        pub(crate) fn get_character_size_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "Drawing",
                    "Text_get_CharacterSize",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_character_size_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_character_size_call()?,
            )
        }
        pub fn get_character_size(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_character_size_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Text {
        pub(crate) fn get_color_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "Drawing",
                    "Text_get_Color",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_color_stream(
            &self,
        ) -> Result<crate::stream::Stream<(f64, f64, f64)>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_color_call()?)
        }
        pub fn get_color(&self) -> Result<(f64, f64, f64), RpcError> {
            let request = crate::schema::Request::from(self.get_color_call()?);
            let response = self.client.call(request)?;
            <(f64, f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl Text {
        pub(crate) fn get_content_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "Drawing",
                    "Text_get_Content",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_content_stream(
            &self,
        ) -> Result<crate::stream::Stream<String>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_content_call()?)
        }
        pub fn get_content(&self) -> Result<String, RpcError> {
            let request = crate::schema::Request::from(self.get_content_call()?);
            let response = self.client.call(request)?;
            <String>::from_response(response, self.client.clone())
        }
    }
    impl Text {
        pub(crate) fn get_font_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "Drawing",
                    "Text_get_Font",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_font_stream(
            &self,
        ) -> Result<crate::stream::Stream<String>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_font_call()?)
        }
        pub fn get_font(&self) -> Result<String, RpcError> {
            let request = crate::schema::Request::from(self.get_font_call()?);
            let response = self.client.call(request)?;
            <String>::from_response(response, self.client.clone())
        }
    }
    impl Text {
        pub(crate) fn get_line_spacing_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "Drawing",
                    "Text_get_LineSpacing",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_line_spacing_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_line_spacing_call()?,
            )
        }
        pub fn get_line_spacing(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_line_spacing_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Text {
        pub(crate) fn get_material_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "Drawing",
                    "Text_get_Material",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_material_stream(
            &self,
        ) -> Result<crate::stream::Stream<String>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_material_call()?)
        }
        pub fn get_material(&self) -> Result<String, RpcError> {
            let request = crate::schema::Request::from(self.get_material_call()?);
            let response = self.client.call(request)?;
            <String>::from_response(response, self.client.clone())
        }
    }
    impl Text {
        pub(crate) fn get_position_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "Drawing",
                    "Text_get_Position",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_position_stream(
            &self,
        ) -> Result<crate::stream::Stream<(f64, f64, f64)>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_position_call()?)
        }
        pub fn get_position(&self) -> Result<(f64, f64, f64), RpcError> {
            let request = crate::schema::Request::from(self.get_position_call()?);
            let response = self.client.call(request)?;
            <(f64, f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl Text {
        pub(crate) fn get_reference_frame_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "Drawing",
                    "Text_get_ReferenceFrame",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_reference_frame_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::ReferenceFrame>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_reference_frame_call()?,
            )
        }
        pub fn get_reference_frame(
            &self,
        ) -> Result<crate::services::space_center::ReferenceFrame, RpcError> {
            let request = crate::schema::Request::from(self.get_reference_frame_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::ReferenceFrame>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Text {
        pub(crate) fn get_rotation_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "Drawing",
                    "Text_get_Rotation",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_rotation_stream(
            &self,
        ) -> Result<crate::stream::Stream<(f64, f64, f64, f64)>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_rotation_call()?)
        }
        pub fn get_rotation(&self) -> Result<(f64, f64, f64, f64), RpcError> {
            let request = crate::schema::Request::from(self.get_rotation_call()?);
            let response = self.client.call(request)?;
            <(f64, f64, f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl Text {
        pub(crate) fn get_size_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "Drawing",
                    "Text_get_Size",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_size_stream(&self) -> Result<crate::stream::Stream<i32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_size_call()?)
        }
        pub fn get_size(&self) -> Result<i32, RpcError> {
            let request = crate::schema::Request::from(self.get_size_call()?);
            let response = self.client.call(request)?;
            <i32>::from_response(response, self.client.clone())
        }
    }
    impl Text {
        pub(crate) fn get_style_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "Drawing",
                    "Text_get_Style",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_style_stream(
            &self,
        ) -> Result<crate::stream::Stream<crate::services::ui::FontStyle>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_style_call()?)
        }
        pub fn get_style(&self) -> Result<crate::services::ui::FontStyle, RpcError> {
            let request = crate::schema::Request::from(self.get_style_call()?);
            let response = self.client.call(request)?;
            <crate::services::ui::FontStyle>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Text {
        pub(crate) fn get_visible_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "Drawing",
                    "Text_get_Visible",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_visible_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_visible_call()?)
        }
        pub fn get_visible(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_visible_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Text {
        pub(crate) fn set_alignment_call(
            &self,
            value: crate::services::ui::TextAlignment,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "Drawing",
                    "Text_set_Alignment",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_alignment_stream(
            &self,
            value: crate::services::ui::TextAlignment,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_alignment_call(value)?,
            )
        }
        pub fn set_alignment(
            &self,
            value: crate::services::ui::TextAlignment,
        ) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_alignment_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Text {
        pub(crate) fn set_anchor_call(
            &self,
            value: crate::services::ui::TextAnchor,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "Drawing",
                    "Text_set_Anchor",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_anchor_stream(
            &self,
            value: crate::services::ui::TextAnchor,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.set_anchor_call(value)?)
        }
        pub fn set_anchor(
            &self,
            value: crate::services::ui::TextAnchor,
        ) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_anchor_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Text {
        pub(crate) fn set_character_size_call(
            &self,
            value: f32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "Drawing",
                    "Text_set_CharacterSize",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_character_size_stream(
            &self,
            value: f32,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_character_size_call(value)?,
            )
        }
        pub fn set_character_size(&self, value: f32) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_character_size_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Text {
        pub(crate) fn set_color_call(
            &self,
            value: (f64, f64, f64),
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "Drawing",
                    "Text_set_Color",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_color_stream(
            &self,
            value: (f64, f64, f64),
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.set_color_call(value)?)
        }
        pub fn set_color(&self, value: (f64, f64, f64)) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_color_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Text {
        pub(crate) fn set_content_call(
            &self,
            value: String,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "Drawing",
                    "Text_set_Content",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_content_stream(
            &self,
            value: String,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_content_call(value)?,
            )
        }
        pub fn set_content(&self, value: String) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_content_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Text {
        pub(crate) fn set_font_call(
            &self,
            value: String,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "Drawing",
                    "Text_set_Font",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_font_stream(
            &self,
            value: String,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.set_font_call(value)?)
        }
        pub fn set_font(&self, value: String) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_font_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Text {
        pub(crate) fn set_line_spacing_call(
            &self,
            value: f32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "Drawing",
                    "Text_set_LineSpacing",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_line_spacing_stream(
            &self,
            value: f32,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_line_spacing_call(value)?,
            )
        }
        pub fn set_line_spacing(&self, value: f32) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_line_spacing_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Text {
        pub(crate) fn set_material_call(
            &self,
            value: String,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "Drawing",
                    "Text_set_Material",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_material_stream(
            &self,
            value: String,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_material_call(value)?,
            )
        }
        pub fn set_material(&self, value: String) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_material_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Text {
        pub(crate) fn set_position_call(
            &self,
            value: (f64, f64, f64),
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "Drawing",
                    "Text_set_Position",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_position_stream(
            &self,
            value: (f64, f64, f64),
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_position_call(value)?,
            )
        }
        pub fn set_position(&self, value: (f64, f64, f64)) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_position_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Text {
        pub(crate) fn set_reference_frame_call(
            &self,
            value: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "Drawing",
                    "Text_set_ReferenceFrame",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_reference_frame_stream(
            &self,
            value: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_reference_frame_call(value)?,
            )
        }
        pub fn set_reference_frame(
            &self,
            value: &crate::services::space_center::ReferenceFrame,
        ) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_reference_frame_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Text {
        pub(crate) fn set_rotation_call(
            &self,
            value: (f64, f64, f64, f64),
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "Drawing",
                    "Text_set_Rotation",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_rotation_stream(
            &self,
            value: (f64, f64, f64, f64),
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_rotation_call(value)?,
            )
        }
        pub fn set_rotation(&self, value: (f64, f64, f64, f64)) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_rotation_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Text {
        pub(crate) fn set_size_call(
            &self,
            value: i32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "Drawing",
                    "Text_set_Size",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_size_stream(
            &self,
            value: i32,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.set_size_call(value)?)
        }
        pub fn set_size(&self, value: i32) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_size_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Text {
        pub(crate) fn set_style_call(
            &self,
            value: crate::services::ui::FontStyle,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "Drawing",
                    "Text_set_Style",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_style_stream(
            &self,
            value: crate::services::ui::FontStyle,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.set_style_call(value)?)
        }
        pub fn set_style(
            &self,
            value: crate::services::ui::FontStyle,
        ) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_style_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Text {
        pub(crate) fn set_visible_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "Drawing",
                    "Text_set_Visible",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_visible_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_visible_call(value)?,
            )
        }
        pub fn set_visible(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_visible_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Text {
        pub(crate) fn static_available_fonts_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "Drawing",
                    "Text_static_AvailableFonts",
                    vec![],
                ),
            )
        }
        pub fn static_available_fonts_stream(
            &self,
        ) -> Result<crate::stream::Stream<Vec<String>>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.static_available_fonts_call()?,
            )
        }
        pub fn static_available_fonts(&self) -> Result<Vec<String>, RpcError> {
            let request = crate::schema::Request::from(
                self.static_available_fonts_call()?,
            );
            let response = self.client.call(request)?;
            <Vec<String>>::from_response(response, self.client.clone())
        }
    }
}
#[allow(clippy::type_complexity)]
pub mod infernal_robotics {
    use crate::{
        schema::{ToArgument, FromResponse},
        error::RpcError,
    };
    pub struct InfernalRobotics {
        pub client: ::std::sync::Arc<crate::Client>,
    }
    impl InfernalRobotics {
        pub fn new(client: ::std::sync::Arc<crate::Client>) -> Self {
            Self { client }
        }
    }
    crate::schema::rpc_object!(Servo);
    crate::schema::rpc_object!(ServoGroup);
    impl InfernalRobotics {
        pub(crate) fn servo_group_with_name_call(
            &self,
            vessel: &crate::services::space_center::Vessel,
            name: String,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "InfernalRobotics",
                    "ServoGroupWithName",
                    vec![
                        vessel.to_argument(0usize as u32) ?, name.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn servo_group_with_name_stream(
            &self,
            vessel: &crate::services::space_center::Vessel,
            name: String,
        ) -> Result<
            crate::stream::Stream<
                Option<crate::services::infernal_robotics::ServoGroup>,
            >,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.servo_group_with_name_call(vessel, name)?,
            )
        }
        pub fn servo_group_with_name(
            &self,
            vessel: &crate::services::space_center::Vessel,
            name: String,
        ) -> Result<Option<crate::services::infernal_robotics::ServoGroup>, RpcError> {
            let request = crate::schema::Request::from(
                self.servo_group_with_name_call(vessel, name)?,
            );
            let response = self.client.call(request)?;
            <Option<
                crate::services::infernal_robotics::ServoGroup,
            >>::from_response(response, self.client.clone())
        }
    }
    impl ServoGroup {
        pub(crate) fn move_center_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "InfernalRobotics",
                    "ServoGroup_MoveCenter",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn move_center_stream(&self) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.move_center_call()?)
        }
        pub fn move_center(&self) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.move_center_call()?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl ServoGroup {
        pub(crate) fn move_left_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "InfernalRobotics",
                    "ServoGroup_MoveLeft",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn move_left_stream(&self) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.move_left_call()?)
        }
        pub fn move_left(&self) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.move_left_call()?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl ServoGroup {
        pub(crate) fn move_next_preset_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "InfernalRobotics",
                    "ServoGroup_MoveNextPreset",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn move_next_preset_stream(
            &self,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.move_next_preset_call()?,
            )
        }
        pub fn move_next_preset(&self) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.move_next_preset_call()?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl ServoGroup {
        pub(crate) fn move_prev_preset_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "InfernalRobotics",
                    "ServoGroup_MovePrevPreset",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn move_prev_preset_stream(
            &self,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.move_prev_preset_call()?,
            )
        }
        pub fn move_prev_preset(&self) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.move_prev_preset_call()?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl ServoGroup {
        pub(crate) fn move_right_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "InfernalRobotics",
                    "ServoGroup_MoveRight",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn move_right_stream(&self) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.move_right_call()?)
        }
        pub fn move_right(&self) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.move_right_call()?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl ServoGroup {
        pub(crate) fn servo_with_name_call(
            &self,
            name: String,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "InfernalRobotics",
                    "ServoGroup_ServoWithName",
                    vec![
                        self.to_argument(0usize as u32) ?, name.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn servo_with_name_stream(
            &self,
            name: String,
        ) -> Result<
            crate::stream::Stream<Option<crate::services::infernal_robotics::Servo>>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.servo_with_name_call(name)?,
            )
        }
        pub fn servo_with_name(
            &self,
            name: String,
        ) -> Result<Option<crate::services::infernal_robotics::Servo>, RpcError> {
            let request = crate::schema::Request::from(self.servo_with_name_call(name)?);
            let response = self.client.call(request)?;
            <Option<
                crate::services::infernal_robotics::Servo,
            >>::from_response(response, self.client.clone())
        }
    }
    impl ServoGroup {
        pub(crate) fn stop_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "InfernalRobotics",
                    "ServoGroup_Stop",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn stop_stream(&self) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.stop_call()?)
        }
        pub fn stop(&self) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.stop_call()?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl ServoGroup {
        pub(crate) fn get_expanded_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "InfernalRobotics",
                    "ServoGroup_get_Expanded",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_expanded_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_expanded_call()?)
        }
        pub fn get_expanded(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_expanded_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl ServoGroup {
        pub(crate) fn get_forward_key_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "InfernalRobotics",
                    "ServoGroup_get_ForwardKey",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_forward_key_stream(
            &self,
        ) -> Result<crate::stream::Stream<String>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_forward_key_call()?)
        }
        pub fn get_forward_key(&self) -> Result<String, RpcError> {
            let request = crate::schema::Request::from(self.get_forward_key_call()?);
            let response = self.client.call(request)?;
            <String>::from_response(response, self.client.clone())
        }
    }
    impl ServoGroup {
        pub(crate) fn get_name_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "InfernalRobotics",
                    "ServoGroup_get_Name",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_name_stream(
            &self,
        ) -> Result<crate::stream::Stream<String>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_name_call()?)
        }
        pub fn get_name(&self) -> Result<String, RpcError> {
            let request = crate::schema::Request::from(self.get_name_call()?);
            let response = self.client.call(request)?;
            <String>::from_response(response, self.client.clone())
        }
    }
    impl ServoGroup {
        pub(crate) fn get_parts_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "InfernalRobotics",
                    "ServoGroup_get_Parts",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_parts_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Vec<crate::services::space_center::Part>>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_parts_call()?)
        }
        pub fn get_parts(
            &self,
        ) -> Result<Vec<crate::services::space_center::Part>, RpcError> {
            let request = crate::schema::Request::from(self.get_parts_call()?);
            let response = self.client.call(request)?;
            <Vec<
                crate::services::space_center::Part,
            >>::from_response(response, self.client.clone())
        }
    }
    impl ServoGroup {
        pub(crate) fn get_reverse_key_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "InfernalRobotics",
                    "ServoGroup_get_ReverseKey",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_reverse_key_stream(
            &self,
        ) -> Result<crate::stream::Stream<String>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_reverse_key_call()?)
        }
        pub fn get_reverse_key(&self) -> Result<String, RpcError> {
            let request = crate::schema::Request::from(self.get_reverse_key_call()?);
            let response = self.client.call(request)?;
            <String>::from_response(response, self.client.clone())
        }
    }
    impl ServoGroup {
        pub(crate) fn get_servos_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "InfernalRobotics",
                    "ServoGroup_get_Servos",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_servos_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Vec<crate::services::infernal_robotics::Servo>>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_servos_call()?)
        }
        pub fn get_servos(
            &self,
        ) -> Result<Vec<crate::services::infernal_robotics::Servo>, RpcError> {
            let request = crate::schema::Request::from(self.get_servos_call()?);
            let response = self.client.call(request)?;
            <Vec<
                crate::services::infernal_robotics::Servo,
            >>::from_response(response, self.client.clone())
        }
    }
    impl ServoGroup {
        pub(crate) fn get_speed_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "InfernalRobotics",
                    "ServoGroup_get_Speed",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_speed_stream(&self) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_speed_call()?)
        }
        pub fn get_speed(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_speed_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl ServoGroup {
        pub(crate) fn set_expanded_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "InfernalRobotics",
                    "ServoGroup_set_Expanded",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_expanded_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_expanded_call(value)?,
            )
        }
        pub fn set_expanded(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_expanded_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl ServoGroup {
        pub(crate) fn set_forward_key_call(
            &self,
            value: String,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "InfernalRobotics",
                    "ServoGroup_set_ForwardKey",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_forward_key_stream(
            &self,
            value: String,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_forward_key_call(value)?,
            )
        }
        pub fn set_forward_key(&self, value: String) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_forward_key_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl ServoGroup {
        pub(crate) fn set_name_call(
            &self,
            value: String,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "InfernalRobotics",
                    "ServoGroup_set_Name",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_name_stream(
            &self,
            value: String,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.set_name_call(value)?)
        }
        pub fn set_name(&self, value: String) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_name_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl ServoGroup {
        pub(crate) fn set_reverse_key_call(
            &self,
            value: String,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "InfernalRobotics",
                    "ServoGroup_set_ReverseKey",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_reverse_key_stream(
            &self,
            value: String,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_reverse_key_call(value)?,
            )
        }
        pub fn set_reverse_key(&self, value: String) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_reverse_key_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl ServoGroup {
        pub(crate) fn set_speed_call(
            &self,
            value: f32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "InfernalRobotics",
                    "ServoGroup_set_Speed",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_speed_stream(
            &self,
            value: f32,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.set_speed_call(value)?)
        }
        pub fn set_speed(&self, value: f32) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_speed_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl InfernalRobotics {
        pub(crate) fn servo_groups_call(
            &self,
            vessel: &crate::services::space_center::Vessel,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "InfernalRobotics",
                    "ServoGroups",
                    vec![vessel.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn servo_groups_stream(
            &self,
            vessel: &crate::services::space_center::Vessel,
        ) -> Result<
            crate::stream::Stream<Vec<crate::services::infernal_robotics::ServoGroup>>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.servo_groups_call(vessel)?,
            )
        }
        pub fn servo_groups(
            &self,
            vessel: &crate::services::space_center::Vessel,
        ) -> Result<Vec<crate::services::infernal_robotics::ServoGroup>, RpcError> {
            let request = crate::schema::Request::from(self.servo_groups_call(vessel)?);
            let response = self.client.call(request)?;
            <Vec<
                crate::services::infernal_robotics::ServoGroup,
            >>::from_response(response, self.client.clone())
        }
    }
    impl InfernalRobotics {
        pub(crate) fn servo_with_name_call(
            &self,
            vessel: &crate::services::space_center::Vessel,
            name: String,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "InfernalRobotics",
                    "ServoWithName",
                    vec![
                        vessel.to_argument(0usize as u32) ?, name.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn servo_with_name_stream(
            &self,
            vessel: &crate::services::space_center::Vessel,
            name: String,
        ) -> Result<
            crate::stream::Stream<Option<crate::services::infernal_robotics::Servo>>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.servo_with_name_call(vessel, name)?,
            )
        }
        pub fn servo_with_name(
            &self,
            vessel: &crate::services::space_center::Vessel,
            name: String,
        ) -> Result<Option<crate::services::infernal_robotics::Servo>, RpcError> {
            let request = crate::schema::Request::from(
                self.servo_with_name_call(vessel, name)?,
            );
            let response = self.client.call(request)?;
            <Option<
                crate::services::infernal_robotics::Servo,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Servo {
        pub(crate) fn move_center_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "InfernalRobotics",
                    "Servo_MoveCenter",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn move_center_stream(&self) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.move_center_call()?)
        }
        pub fn move_center(&self) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.move_center_call()?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Servo {
        pub(crate) fn move_left_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "InfernalRobotics",
                    "Servo_MoveLeft",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn move_left_stream(&self) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.move_left_call()?)
        }
        pub fn move_left(&self) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.move_left_call()?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Servo {
        pub(crate) fn move_right_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "InfernalRobotics",
                    "Servo_MoveRight",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn move_right_stream(&self) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.move_right_call()?)
        }
        pub fn move_right(&self) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.move_right_call()?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Servo {
        pub(crate) fn move_to_call(
            &self,
            position: f32,
            speed: f32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "InfernalRobotics",
                    "Servo_MoveTo",
                    vec![
                        self.to_argument(0usize as u32) ?, position.to_argument(1usize as
                        u32) ?, speed.to_argument(2usize as u32) ?
                    ],
                ),
            )
        }
        pub fn move_to_stream(
            &self,
            position: f32,
            speed: f32,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.move_to_call(position, speed)?,
            )
        }
        pub fn move_to(&self, position: f32, speed: f32) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.move_to_call(position, speed)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Servo {
        pub(crate) fn stop_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "InfernalRobotics",
                    "Servo_Stop",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn stop_stream(&self) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.stop_call()?)
        }
        pub fn stop(&self) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.stop_call()?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Servo {
        pub(crate) fn get_acceleration_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "InfernalRobotics",
                    "Servo_get_Acceleration",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_acceleration_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_acceleration_call()?,
            )
        }
        pub fn get_acceleration(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_acceleration_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Servo {
        pub(crate) fn get_config_speed_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "InfernalRobotics",
                    "Servo_get_ConfigSpeed",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_config_speed_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_config_speed_call()?,
            )
        }
        pub fn get_config_speed(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_config_speed_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Servo {
        pub(crate) fn get_current_speed_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "InfernalRobotics",
                    "Servo_get_CurrentSpeed",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_current_speed_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_current_speed_call()?,
            )
        }
        pub fn get_current_speed(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_current_speed_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Servo {
        pub(crate) fn get_is_axis_inverted_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "InfernalRobotics",
                    "Servo_get_IsAxisInverted",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_is_axis_inverted_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_is_axis_inverted_call()?,
            )
        }
        pub fn get_is_axis_inverted(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(
                self.get_is_axis_inverted_call()?,
            );
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Servo {
        pub(crate) fn get_is_free_moving_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "InfernalRobotics",
                    "Servo_get_IsFreeMoving",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_is_free_moving_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_is_free_moving_call()?,
            )
        }
        pub fn get_is_free_moving(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_is_free_moving_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Servo {
        pub(crate) fn get_is_locked_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "InfernalRobotics",
                    "Servo_get_IsLocked",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_is_locked_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_is_locked_call()?)
        }
        pub fn get_is_locked(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_is_locked_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Servo {
        pub(crate) fn get_is_moving_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "InfernalRobotics",
                    "Servo_get_IsMoving",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_is_moving_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_is_moving_call()?)
        }
        pub fn get_is_moving(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_is_moving_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Servo {
        pub(crate) fn get_max_config_position_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "InfernalRobotics",
                    "Servo_get_MaxConfigPosition",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_max_config_position_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_max_config_position_call()?,
            )
        }
        pub fn get_max_config_position(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(
                self.get_max_config_position_call()?,
            );
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Servo {
        pub(crate) fn get_max_position_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "InfernalRobotics",
                    "Servo_get_MaxPosition",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_max_position_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_max_position_call()?,
            )
        }
        pub fn get_max_position(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_max_position_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Servo {
        pub(crate) fn get_min_config_position_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "InfernalRobotics",
                    "Servo_get_MinConfigPosition",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_min_config_position_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_min_config_position_call()?,
            )
        }
        pub fn get_min_config_position(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(
                self.get_min_config_position_call()?,
            );
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Servo {
        pub(crate) fn get_min_position_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "InfernalRobotics",
                    "Servo_get_MinPosition",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_min_position_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_min_position_call()?,
            )
        }
        pub fn get_min_position(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_min_position_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Servo {
        pub(crate) fn get_name_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "InfernalRobotics",
                    "Servo_get_Name",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_name_stream(
            &self,
        ) -> Result<crate::stream::Stream<String>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_name_call()?)
        }
        pub fn get_name(&self) -> Result<String, RpcError> {
            let request = crate::schema::Request::from(self.get_name_call()?);
            let response = self.client.call(request)?;
            <String>::from_response(response, self.client.clone())
        }
    }
    impl Servo {
        pub(crate) fn get_part_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "InfernalRobotics",
                    "Servo_get_Part",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_part_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::Part>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_part_call()?)
        }
        pub fn get_part(&self) -> Result<crate::services::space_center::Part, RpcError> {
            let request = crate::schema::Request::from(self.get_part_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::Part>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Servo {
        pub(crate) fn get_position_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "InfernalRobotics",
                    "Servo_get_Position",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_position_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_position_call()?)
        }
        pub fn get_position(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_position_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Servo {
        pub(crate) fn get_speed_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "InfernalRobotics",
                    "Servo_get_Speed",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_speed_stream(&self) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_speed_call()?)
        }
        pub fn get_speed(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_speed_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Servo {
        pub(crate) fn set_acceleration_call(
            &self,
            value: f32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "InfernalRobotics",
                    "Servo_set_Acceleration",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_acceleration_stream(
            &self,
            value: f32,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_acceleration_call(value)?,
            )
        }
        pub fn set_acceleration(&self, value: f32) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_acceleration_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Servo {
        pub(crate) fn set_highlight_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "InfernalRobotics",
                    "Servo_set_Highlight",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_highlight_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_highlight_call(value)?,
            )
        }
        pub fn set_highlight(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_highlight_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Servo {
        pub(crate) fn set_is_axis_inverted_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "InfernalRobotics",
                    "Servo_set_IsAxisInverted",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_is_axis_inverted_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_is_axis_inverted_call(value)?,
            )
        }
        pub fn set_is_axis_inverted(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_is_axis_inverted_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Servo {
        pub(crate) fn set_is_locked_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "InfernalRobotics",
                    "Servo_set_IsLocked",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_is_locked_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_is_locked_call(value)?,
            )
        }
        pub fn set_is_locked(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_is_locked_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Servo {
        pub(crate) fn set_max_position_call(
            &self,
            value: f32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "InfernalRobotics",
                    "Servo_set_MaxPosition",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_max_position_stream(
            &self,
            value: f32,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_max_position_call(value)?,
            )
        }
        pub fn set_max_position(&self, value: f32) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_max_position_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Servo {
        pub(crate) fn set_min_position_call(
            &self,
            value: f32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "InfernalRobotics",
                    "Servo_set_MinPosition",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_min_position_stream(
            &self,
            value: f32,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_min_position_call(value)?,
            )
        }
        pub fn set_min_position(&self, value: f32) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_min_position_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Servo {
        pub(crate) fn set_name_call(
            &self,
            value: String,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "InfernalRobotics",
                    "Servo_set_Name",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_name_stream(
            &self,
            value: String,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.set_name_call(value)?)
        }
        pub fn set_name(&self, value: String) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_name_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Servo {
        pub(crate) fn set_speed_call(
            &self,
            value: f32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "InfernalRobotics",
                    "Servo_set_Speed",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_speed_stream(
            &self,
            value: f32,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.set_speed_call(value)?)
        }
        pub fn set_speed(&self, value: f32) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_speed_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl InfernalRobotics {
        pub(crate) fn get_available_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "InfernalRobotics",
                    "get_Available",
                    vec![],
                ),
            )
        }
        pub fn get_available_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_available_call()?)
        }
        pub fn get_available(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_available_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl InfernalRobotics {
        pub(crate) fn get_ready_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(crate::client::Client::proc_call("InfernalRobotics", "get_Ready", vec![]))
        }
        pub fn get_ready_stream(&self) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_ready_call()?)
        }
        pub fn get_ready(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_ready_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
}
#[allow(clippy::type_complexity)]
pub mod kerbal_alarm_clock {
    use crate::{
        schema::{ToArgument, FromResponse},
        error::RpcError,
    };
    pub struct KerbalAlarmClock {
        pub client: ::std::sync::Arc<crate::Client>,
    }
    impl KerbalAlarmClock {
        pub fn new(client: ::std::sync::Arc<crate::Client>) -> Self {
            Self { client }
        }
    }
    crate::schema::rpc_object!(Alarm);
    crate::schema::rpc_enum!(
        AlarmAction, [DoNothing, DoNothingDeleteWhenPassed, KillWarp, KillWarpOnly,
        MessageOnly, PauseGame,]
    );
    crate::schema::rpc_enum!(
        AlarmType, [Raw, Maneuver, ManeuverAuto, Apoapsis, Periapsis, AscendingNode,
        DescendingNode, Closest, Contract, ContractAuto, Crew, Distance, EarthTime,
        LaunchRendevous, SOIChange, SOIChangeAuto, Transfer, TransferModelled,]
    );
    impl KerbalAlarmClock {
        pub(crate) fn alarm_with_name_call(
            &self,
            name: String,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KerbalAlarmClock",
                    "AlarmWithName",
                    vec![name.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn alarm_with_name_stream(
            &self,
            name: String,
        ) -> Result<
            crate::stream::Stream<Option<crate::services::kerbal_alarm_clock::Alarm>>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.alarm_with_name_call(name)?,
            )
        }
        pub fn alarm_with_name(
            &self,
            name: String,
        ) -> Result<Option<crate::services::kerbal_alarm_clock::Alarm>, RpcError> {
            let request = crate::schema::Request::from(self.alarm_with_name_call(name)?);
            let response = self.client.call(request)?;
            <Option<
                crate::services::kerbal_alarm_clock::Alarm,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Alarm {
        pub(crate) fn remove_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KerbalAlarmClock",
                    "Alarm_Remove",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn remove_stream(&self) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.remove_call()?)
        }
        pub fn remove(&self) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.remove_call()?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Alarm {
        pub(crate) fn get_action_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KerbalAlarmClock",
                    "Alarm_get_Action",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_action_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::kerbal_alarm_clock::AlarmAction>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_action_call()?)
        }
        pub fn get_action(
            &self,
        ) -> Result<crate::services::kerbal_alarm_clock::AlarmAction, RpcError> {
            let request = crate::schema::Request::from(self.get_action_call()?);
            let response = self.client.call(request)?;
            <crate::services::kerbal_alarm_clock::AlarmAction>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Alarm {
        pub(crate) fn get_id_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KerbalAlarmClock",
                    "Alarm_get_ID",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_id_stream(&self) -> Result<crate::stream::Stream<String>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_id_call()?)
        }
        pub fn get_id(&self) -> Result<String, RpcError> {
            let request = crate::schema::Request::from(self.get_id_call()?);
            let response = self.client.call(request)?;
            <String>::from_response(response, self.client.clone())
        }
    }
    impl Alarm {
        pub(crate) fn get_margin_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KerbalAlarmClock",
                    "Alarm_get_Margin",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_margin_stream(&self) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_margin_call()?)
        }
        pub fn get_margin(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(self.get_margin_call()?);
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Alarm {
        pub(crate) fn get_name_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KerbalAlarmClock",
                    "Alarm_get_Name",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_name_stream(
            &self,
        ) -> Result<crate::stream::Stream<String>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_name_call()?)
        }
        pub fn get_name(&self) -> Result<String, RpcError> {
            let request = crate::schema::Request::from(self.get_name_call()?);
            let response = self.client.call(request)?;
            <String>::from_response(response, self.client.clone())
        }
    }
    impl Alarm {
        pub(crate) fn get_notes_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KerbalAlarmClock",
                    "Alarm_get_Notes",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_notes_stream(
            &self,
        ) -> Result<crate::stream::Stream<String>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_notes_call()?)
        }
        pub fn get_notes(&self) -> Result<String, RpcError> {
            let request = crate::schema::Request::from(self.get_notes_call()?);
            let response = self.client.call(request)?;
            <String>::from_response(response, self.client.clone())
        }
    }
    impl Alarm {
        pub(crate) fn get_remaining_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KerbalAlarmClock",
                    "Alarm_get_Remaining",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_remaining_stream(
            &self,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_remaining_call()?)
        }
        pub fn get_remaining(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(self.get_remaining_call()?);
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Alarm {
        pub(crate) fn get_repeat_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KerbalAlarmClock",
                    "Alarm_get_Repeat",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_repeat_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_repeat_call()?)
        }
        pub fn get_repeat(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_repeat_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Alarm {
        pub(crate) fn get_repeat_period_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KerbalAlarmClock",
                    "Alarm_get_RepeatPeriod",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_repeat_period_stream(
            &self,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_repeat_period_call()?,
            )
        }
        pub fn get_repeat_period(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(self.get_repeat_period_call()?);
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Alarm {
        pub(crate) fn get_time_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KerbalAlarmClock",
                    "Alarm_get_Time",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_time_stream(&self) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_time_call()?)
        }
        pub fn get_time(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(self.get_time_call()?);
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Alarm {
        pub(crate) fn get_type_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KerbalAlarmClock",
                    "Alarm_get_Type",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_type_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::kerbal_alarm_clock::AlarmType>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_type_call()?)
        }
        pub fn get_type(
            &self,
        ) -> Result<crate::services::kerbal_alarm_clock::AlarmType, RpcError> {
            let request = crate::schema::Request::from(self.get_type_call()?);
            let response = self.client.call(request)?;
            <crate::services::kerbal_alarm_clock::AlarmType>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Alarm {
        pub(crate) fn get_vessel_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KerbalAlarmClock",
                    "Alarm_get_Vessel",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_vessel_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::Vessel>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_vessel_call()?)
        }
        pub fn get_vessel(
            &self,
        ) -> Result<crate::services::space_center::Vessel, RpcError> {
            let request = crate::schema::Request::from(self.get_vessel_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::Vessel>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Alarm {
        pub(crate) fn get_xfer_origin_body_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KerbalAlarmClock",
                    "Alarm_get_XferOriginBody",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_xfer_origin_body_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::CelestialBody>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_xfer_origin_body_call()?,
            )
        }
        pub fn get_xfer_origin_body(
            &self,
        ) -> Result<crate::services::space_center::CelestialBody, RpcError> {
            let request = crate::schema::Request::from(
                self.get_xfer_origin_body_call()?,
            );
            let response = self.client.call(request)?;
            <crate::services::space_center::CelestialBody>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Alarm {
        pub(crate) fn get_xfer_target_body_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KerbalAlarmClock",
                    "Alarm_get_XferTargetBody",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_xfer_target_body_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::CelestialBody>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_xfer_target_body_call()?,
            )
        }
        pub fn get_xfer_target_body(
            &self,
        ) -> Result<crate::services::space_center::CelestialBody, RpcError> {
            let request = crate::schema::Request::from(
                self.get_xfer_target_body_call()?,
            );
            let response = self.client.call(request)?;
            <crate::services::space_center::CelestialBody>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Alarm {
        pub(crate) fn set_action_call(
            &self,
            value: crate::services::kerbal_alarm_clock::AlarmAction,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KerbalAlarmClock",
                    "Alarm_set_Action",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_action_stream(
            &self,
            value: crate::services::kerbal_alarm_clock::AlarmAction,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.set_action_call(value)?)
        }
        pub fn set_action(
            &self,
            value: crate::services::kerbal_alarm_clock::AlarmAction,
        ) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_action_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Alarm {
        pub(crate) fn set_margin_call(
            &self,
            value: f64,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KerbalAlarmClock",
                    "Alarm_set_Margin",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_margin_stream(
            &self,
            value: f64,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.set_margin_call(value)?)
        }
        pub fn set_margin(&self, value: f64) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_margin_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Alarm {
        pub(crate) fn set_name_call(
            &self,
            value: String,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KerbalAlarmClock",
                    "Alarm_set_Name",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_name_stream(
            &self,
            value: String,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.set_name_call(value)?)
        }
        pub fn set_name(&self, value: String) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_name_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Alarm {
        pub(crate) fn set_notes_call(
            &self,
            value: String,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KerbalAlarmClock",
                    "Alarm_set_Notes",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_notes_stream(
            &self,
            value: String,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.set_notes_call(value)?)
        }
        pub fn set_notes(&self, value: String) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_notes_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Alarm {
        pub(crate) fn set_repeat_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KerbalAlarmClock",
                    "Alarm_set_Repeat",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_repeat_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.set_repeat_call(value)?)
        }
        pub fn set_repeat(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_repeat_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Alarm {
        pub(crate) fn set_repeat_period_call(
            &self,
            value: f64,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KerbalAlarmClock",
                    "Alarm_set_RepeatPeriod",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_repeat_period_stream(
            &self,
            value: f64,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_repeat_period_call(value)?,
            )
        }
        pub fn set_repeat_period(&self, value: f64) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_repeat_period_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Alarm {
        pub(crate) fn set_time_call(
            &self,
            value: f64,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KerbalAlarmClock",
                    "Alarm_set_Time",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_time_stream(
            &self,
            value: f64,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.set_time_call(value)?)
        }
        pub fn set_time(&self, value: f64) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_time_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Alarm {
        pub(crate) fn set_vessel_call(
            &self,
            value: &crate::services::space_center::Vessel,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KerbalAlarmClock",
                    "Alarm_set_Vessel",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_vessel_stream(
            &self,
            value: &crate::services::space_center::Vessel,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.set_vessel_call(value)?)
        }
        pub fn set_vessel(
            &self,
            value: &crate::services::space_center::Vessel,
        ) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_vessel_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Alarm {
        pub(crate) fn set_xfer_origin_body_call(
            &self,
            value: &crate::services::space_center::CelestialBody,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KerbalAlarmClock",
                    "Alarm_set_XferOriginBody",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_xfer_origin_body_stream(
            &self,
            value: &crate::services::space_center::CelestialBody,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_xfer_origin_body_call(value)?,
            )
        }
        pub fn set_xfer_origin_body(
            &self,
            value: &crate::services::space_center::CelestialBody,
        ) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_xfer_origin_body_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Alarm {
        pub(crate) fn set_xfer_target_body_call(
            &self,
            value: &crate::services::space_center::CelestialBody,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KerbalAlarmClock",
                    "Alarm_set_XferTargetBody",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_xfer_target_body_stream(
            &self,
            value: &crate::services::space_center::CelestialBody,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_xfer_target_body_call(value)?,
            )
        }
        pub fn set_xfer_target_body(
            &self,
            value: &crate::services::space_center::CelestialBody,
        ) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_xfer_target_body_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl KerbalAlarmClock {
        pub(crate) fn alarms_with_type_call(
            &self,
            r#type: crate::services::kerbal_alarm_clock::AlarmType,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KerbalAlarmClock",
                    "AlarmsWithType",
                    vec![r#type.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn alarms_with_type_stream(
            &self,
            r#type: crate::services::kerbal_alarm_clock::AlarmType,
        ) -> Result<
            crate::stream::Stream<Vec<crate::services::kerbal_alarm_clock::Alarm>>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.alarms_with_type_call(r#type)?,
            )
        }
        pub fn alarms_with_type(
            &self,
            r#type: crate::services::kerbal_alarm_clock::AlarmType,
        ) -> Result<Vec<crate::services::kerbal_alarm_clock::Alarm>, RpcError> {
            let request = crate::schema::Request::from(
                self.alarms_with_type_call(r#type)?,
            );
            let response = self.client.call(request)?;
            <Vec<
                crate::services::kerbal_alarm_clock::Alarm,
            >>::from_response(response, self.client.clone())
        }
    }
    impl KerbalAlarmClock {
        pub(crate) fn create_alarm_call(
            &self,
            r#type: crate::services::kerbal_alarm_clock::AlarmType,
            name: String,
            ut: f64,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KerbalAlarmClock",
                    "CreateAlarm",
                    vec![
                        r#type.to_argument(0usize as u32) ?, name.to_argument(1usize as
                        u32) ?, ut.to_argument(2usize as u32) ?
                    ],
                ),
            )
        }
        pub fn create_alarm_stream(
            &self,
            r#type: crate::services::kerbal_alarm_clock::AlarmType,
            name: String,
            ut: f64,
        ) -> Result<
            crate::stream::Stream<crate::services::kerbal_alarm_clock::Alarm>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.create_alarm_call(r#type, name, ut)?,
            )
        }
        pub fn create_alarm(
            &self,
            r#type: crate::services::kerbal_alarm_clock::AlarmType,
            name: String,
            ut: f64,
        ) -> Result<crate::services::kerbal_alarm_clock::Alarm, RpcError> {
            let request = crate::schema::Request::from(
                self.create_alarm_call(r#type, name, ut)?,
            );
            let response = self.client.call(request)?;
            <crate::services::kerbal_alarm_clock::Alarm>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl KerbalAlarmClock {
        pub(crate) fn get_alarms_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KerbalAlarmClock",
                    "get_Alarms",
                    vec![],
                ),
            )
        }
        pub fn get_alarms_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Vec<crate::services::kerbal_alarm_clock::Alarm>>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_alarms_call()?)
        }
        pub fn get_alarms(
            &self,
        ) -> Result<Vec<crate::services::kerbal_alarm_clock::Alarm>, RpcError> {
            let request = crate::schema::Request::from(self.get_alarms_call()?);
            let response = self.client.call(request)?;
            <Vec<
                crate::services::kerbal_alarm_clock::Alarm,
            >>::from_response(response, self.client.clone())
        }
    }
    impl KerbalAlarmClock {
        pub(crate) fn get_available_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KerbalAlarmClock",
                    "get_Available",
                    vec![],
                ),
            )
        }
        pub fn get_available_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_available_call()?)
        }
        pub fn get_available(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_available_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
}
#[allow(clippy::type_complexity)]
pub mod li_dar {
    use crate::{
        schema::{ToArgument, FromResponse},
        error::RpcError,
    };
    pub struct LiDAR {
        pub client: ::std::sync::Arc<crate::Client>,
    }
    impl LiDAR {
        pub fn new(client: ::std::sync::Arc<crate::Client>) -> Self {
            Self { client }
        }
    }
    crate::schema::rpc_object!(Laser);
    impl LiDAR {
        pub(crate) fn laser_call(
            &self,
            part: &crate::services::space_center::Part,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "LiDAR",
                    "Laser",
                    vec![part.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn laser_stream(
            &self,
            part: &crate::services::space_center::Part,
        ) -> Result<crate::stream::Stream<crate::services::li_dar::Laser>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.laser_call(part)?)
        }
        pub fn laser(
            &self,
            part: &crate::services::space_center::Part,
        ) -> Result<crate::services::li_dar::Laser, RpcError> {
            let request = crate::schema::Request::from(self.laser_call(part)?);
            let response = self.client.call(request)?;
            <crate::services::li_dar::Laser>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Laser {
        pub(crate) fn get_cloud_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "LiDAR",
                    "Laser_get_Cloud",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_cloud_stream(
            &self,
        ) -> Result<crate::stream::Stream<Vec<f64>>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_cloud_call()?)
        }
        pub fn get_cloud(&self) -> Result<Vec<f64>, RpcError> {
            let request = crate::schema::Request::from(self.get_cloud_call()?);
            let response = self.client.call(request)?;
            <Vec<f64>>::from_response(response, self.client.clone())
        }
    }
    impl Laser {
        pub(crate) fn get_part_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "LiDAR",
                    "Laser_get_Part",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_part_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::Part>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_part_call()?)
        }
        pub fn get_part(&self) -> Result<crate::services::space_center::Part, RpcError> {
            let request = crate::schema::Request::from(self.get_part_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::Part>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl LiDAR {
        pub(crate) fn get_available_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(crate::client::Client::proc_call("LiDAR", "get_Available", vec![]))
        }
        pub fn get_available_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_available_call()?)
        }
        pub fn get_available(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_available_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
}
#[allow(clippy::type_complexity)]
pub mod remote_tech {
    use crate::{
        schema::{ToArgument, FromResponse},
        error::RpcError,
    };
    pub struct RemoteTech {
        pub client: ::std::sync::Arc<crate::Client>,
    }
    impl RemoteTech {
        pub fn new(client: ::std::sync::Arc<crate::Client>) -> Self {
            Self { client }
        }
    }
    crate::schema::rpc_object!(Antenna);
    crate::schema::rpc_object!(Comms);
    crate::schema::rpc_enum!(
        Target, [ActiveVessel, CelestialBody, GroundStation, Vessel, None,]
    );
    impl RemoteTech {
        pub(crate) fn antenna_call(
            &self,
            part: &crate::services::space_center::Part,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "RemoteTech",
                    "Antenna",
                    vec![part.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn antenna_stream(
            &self,
            part: &crate::services::space_center::Part,
        ) -> Result<
            crate::stream::Stream<crate::services::remote_tech::Antenna>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.antenna_call(part)?)
        }
        pub fn antenna(
            &self,
            part: &crate::services::space_center::Part,
        ) -> Result<crate::services::remote_tech::Antenna, RpcError> {
            let request = crate::schema::Request::from(self.antenna_call(part)?);
            let response = self.client.call(request)?;
            <crate::services::remote_tech::Antenna>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Antenna {
        pub(crate) fn get_has_connection_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "RemoteTech",
                    "Antenna_get_HasConnection",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_has_connection_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_has_connection_call()?,
            )
        }
        pub fn get_has_connection(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_has_connection_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Antenna {
        pub(crate) fn get_part_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "RemoteTech",
                    "Antenna_get_Part",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_part_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::Part>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_part_call()?)
        }
        pub fn get_part(&self) -> Result<crate::services::space_center::Part, RpcError> {
            let request = crate::schema::Request::from(self.get_part_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::Part>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Antenna {
        pub(crate) fn get_target_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "RemoteTech",
                    "Antenna_get_Target",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_target_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::remote_tech::Target>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_target_call()?)
        }
        pub fn get_target(
            &self,
        ) -> Result<crate::services::remote_tech::Target, RpcError> {
            let request = crate::schema::Request::from(self.get_target_call()?);
            let response = self.client.call(request)?;
            <crate::services::remote_tech::Target>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Antenna {
        pub(crate) fn get_target_body_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "RemoteTech",
                    "Antenna_get_TargetBody",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_target_body_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::CelestialBody>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_target_body_call()?)
        }
        pub fn get_target_body(
            &self,
        ) -> Result<crate::services::space_center::CelestialBody, RpcError> {
            let request = crate::schema::Request::from(self.get_target_body_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::CelestialBody>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Antenna {
        pub(crate) fn get_target_ground_station_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "RemoteTech",
                    "Antenna_get_TargetGroundStation",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_target_ground_station_stream(
            &self,
        ) -> Result<crate::stream::Stream<String>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_target_ground_station_call()?,
            )
        }
        pub fn get_target_ground_station(&self) -> Result<String, RpcError> {
            let request = crate::schema::Request::from(
                self.get_target_ground_station_call()?,
            );
            let response = self.client.call(request)?;
            <String>::from_response(response, self.client.clone())
        }
    }
    impl Antenna {
        pub(crate) fn get_target_vessel_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "RemoteTech",
                    "Antenna_get_TargetVessel",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_target_vessel_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::Vessel>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_target_vessel_call()?,
            )
        }
        pub fn get_target_vessel(
            &self,
        ) -> Result<crate::services::space_center::Vessel, RpcError> {
            let request = crate::schema::Request::from(self.get_target_vessel_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::Vessel>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Antenna {
        pub(crate) fn set_target_call(
            &self,
            value: crate::services::remote_tech::Target,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "RemoteTech",
                    "Antenna_set_Target",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_target_stream(
            &self,
            value: crate::services::remote_tech::Target,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.set_target_call(value)?)
        }
        pub fn set_target(
            &self,
            value: crate::services::remote_tech::Target,
        ) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_target_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Antenna {
        pub(crate) fn set_target_body_call(
            &self,
            value: &crate::services::space_center::CelestialBody,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "RemoteTech",
                    "Antenna_set_TargetBody",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_target_body_stream(
            &self,
            value: &crate::services::space_center::CelestialBody,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_target_body_call(value)?,
            )
        }
        pub fn set_target_body(
            &self,
            value: &crate::services::space_center::CelestialBody,
        ) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_target_body_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Antenna {
        pub(crate) fn set_target_ground_station_call(
            &self,
            value: String,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "RemoteTech",
                    "Antenna_set_TargetGroundStation",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_target_ground_station_stream(
            &self,
            value: String,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_target_ground_station_call(value)?,
            )
        }
        pub fn set_target_ground_station(&self, value: String) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_target_ground_station_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Antenna {
        pub(crate) fn set_target_vessel_call(
            &self,
            value: &crate::services::space_center::Vessel,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "RemoteTech",
                    "Antenna_set_TargetVessel",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_target_vessel_stream(
            &self,
            value: &crate::services::space_center::Vessel,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_target_vessel_call(value)?,
            )
        }
        pub fn set_target_vessel(
            &self,
            value: &crate::services::space_center::Vessel,
        ) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_target_vessel_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl RemoteTech {
        pub(crate) fn comms_call(
            &self,
            vessel: &crate::services::space_center::Vessel,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "RemoteTech",
                    "Comms",
                    vec![vessel.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn comms_stream(
            &self,
            vessel: &crate::services::space_center::Vessel,
        ) -> Result<
            crate::stream::Stream<crate::services::remote_tech::Comms>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.comms_call(vessel)?)
        }
        pub fn comms(
            &self,
            vessel: &crate::services::space_center::Vessel,
        ) -> Result<crate::services::remote_tech::Comms, RpcError> {
            let request = crate::schema::Request::from(self.comms_call(vessel)?);
            let response = self.client.call(request)?;
            <crate::services::remote_tech::Comms>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Comms {
        pub(crate) fn signal_delay_to_vessel_call(
            &self,
            other: &crate::services::space_center::Vessel,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "RemoteTech",
                    "Comms_SignalDelayToVessel",
                    vec![
                        self.to_argument(0usize as u32) ?, other.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn signal_delay_to_vessel_stream(
            &self,
            other: &crate::services::space_center::Vessel,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.signal_delay_to_vessel_call(other)?,
            )
        }
        pub fn signal_delay_to_vessel(
            &self,
            other: &crate::services::space_center::Vessel,
        ) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(
                self.signal_delay_to_vessel_call(other)?,
            );
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Comms {
        pub(crate) fn get_antennas_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "RemoteTech",
                    "Comms_get_Antennas",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_antennas_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Vec<crate::services::remote_tech::Antenna>>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_antennas_call()?)
        }
        pub fn get_antennas(
            &self,
        ) -> Result<Vec<crate::services::remote_tech::Antenna>, RpcError> {
            let request = crate::schema::Request::from(self.get_antennas_call()?);
            let response = self.client.call(request)?;
            <Vec<
                crate::services::remote_tech::Antenna,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Comms {
        pub(crate) fn get_has_connection_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "RemoteTech",
                    "Comms_get_HasConnection",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_has_connection_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_has_connection_call()?,
            )
        }
        pub fn get_has_connection(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_has_connection_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Comms {
        pub(crate) fn get_has_connection_to_ground_station_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "RemoteTech",
                    "Comms_get_HasConnectionToGroundStation",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_has_connection_to_ground_station_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_has_connection_to_ground_station_call()?,
            )
        }
        pub fn get_has_connection_to_ground_station(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(
                self.get_has_connection_to_ground_station_call()?,
            );
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Comms {
        pub(crate) fn get_has_flight_computer_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "RemoteTech",
                    "Comms_get_HasFlightComputer",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_has_flight_computer_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_has_flight_computer_call()?,
            )
        }
        pub fn get_has_flight_computer(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(
                self.get_has_flight_computer_call()?,
            );
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Comms {
        pub(crate) fn get_has_local_control_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "RemoteTech",
                    "Comms_get_HasLocalControl",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_has_local_control_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_has_local_control_call()?,
            )
        }
        pub fn get_has_local_control(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(
                self.get_has_local_control_call()?,
            );
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Comms {
        pub(crate) fn get_signal_delay_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "RemoteTech",
                    "Comms_get_SignalDelay",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_signal_delay_stream(
            &self,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_signal_delay_call()?,
            )
        }
        pub fn get_signal_delay(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(self.get_signal_delay_call()?);
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Comms {
        pub(crate) fn get_signal_delay_to_ground_station_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "RemoteTech",
                    "Comms_get_SignalDelayToGroundStation",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_signal_delay_to_ground_station_stream(
            &self,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_signal_delay_to_ground_station_call()?,
            )
        }
        pub fn get_signal_delay_to_ground_station(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(
                self.get_signal_delay_to_ground_station_call()?,
            );
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Comms {
        pub(crate) fn get_vessel_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "RemoteTech",
                    "Comms_get_Vessel",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_vessel_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::Vessel>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_vessel_call()?)
        }
        pub fn get_vessel(
            &self,
        ) -> Result<crate::services::space_center::Vessel, RpcError> {
            let request = crate::schema::Request::from(self.get_vessel_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::Vessel>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl RemoteTech {
        pub(crate) fn get_available_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(crate::client::Client::proc_call("RemoteTech", "get_Available", vec![]))
        }
        pub fn get_available_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_available_call()?)
        }
        pub fn get_available(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_available_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl RemoteTech {
        pub(crate) fn get_ground_stations_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "RemoteTech",
                    "get_GroundStations",
                    vec![],
                ),
            )
        }
        pub fn get_ground_stations_stream(
            &self,
        ) -> Result<crate::stream::Stream<Vec<String>>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_ground_stations_call()?,
            )
        }
        pub fn get_ground_stations(&self) -> Result<Vec<String>, RpcError> {
            let request = crate::schema::Request::from(self.get_ground_stations_call()?);
            let response = self.client.call(request)?;
            <Vec<String>>::from_response(response, self.client.clone())
        }
    }
}
#[allow(clippy::type_complexity)]
pub mod space_center {
    use crate::{
        schema::{ToArgument, FromResponse},
        error::RpcError,
    };
    pub struct SpaceCenter {
        pub client: ::std::sync::Arc<crate::Client>,
    }
    impl SpaceCenter {
        pub fn new(client: ::std::sync::Arc<crate::Client>) -> Self {
            Self { client }
        }
    }
    crate::schema::rpc_object!(Alarm);
    crate::schema::rpc_object!(AlarmManager);
    crate::schema::rpc_object!(Antenna);
    crate::schema::rpc_object!(AutoPilot);
    crate::schema::rpc_object!(Camera);
    crate::schema::rpc_object!(CargoBay);
    crate::schema::rpc_object!(CelestialBody);
    crate::schema::rpc_object!(CommLink);
    crate::schema::rpc_object!(CommNode);
    crate::schema::rpc_object!(Comms);
    crate::schema::rpc_object!(Contract);
    crate::schema::rpc_object!(ContractManager);
    crate::schema::rpc_object!(ContractParameter);
    crate::schema::rpc_object!(Control);
    crate::schema::rpc_object!(ControlSurface);
    crate::schema::rpc_object!(CrewMember);
    crate::schema::rpc_object!(Decoupler);
    crate::schema::rpc_object!(DockingPort);
    crate::schema::rpc_object!(Engine);
    crate::schema::rpc_object!(Experiment);
    crate::schema::rpc_object!(Fairing);
    crate::schema::rpc_object!(Flight);
    crate::schema::rpc_object!(Force);
    crate::schema::rpc_object!(Intake);
    crate::schema::rpc_object!(LaunchClamp);
    crate::schema::rpc_object!(LaunchSite);
    crate::schema::rpc_object!(Leg);
    crate::schema::rpc_object!(Light);
    crate::schema::rpc_object!(Module);
    crate::schema::rpc_object!(Node);
    crate::schema::rpc_object!(Orbit);
    crate::schema::rpc_object!(Parachute);
    crate::schema::rpc_object!(Part);
    crate::schema::rpc_object!(Parts);
    crate::schema::rpc_object!(Propellant);
    crate::schema::rpc_object!(RCS);
    crate::schema::rpc_object!(Radiator);
    crate::schema::rpc_object!(ReactionWheel);
    crate::schema::rpc_object!(ReferenceFrame);
    crate::schema::rpc_object!(Resource);
    crate::schema::rpc_object!(ResourceConverter);
    crate::schema::rpc_object!(ResourceDrain);
    crate::schema::rpc_object!(ResourceHarvester);
    crate::schema::rpc_object!(ResourceTransfer);
    crate::schema::rpc_object!(Resources);
    crate::schema::rpc_object!(RoboticController);
    crate::schema::rpc_object!(RoboticHinge);
    crate::schema::rpc_object!(RoboticPiston);
    crate::schema::rpc_object!(RoboticRotation);
    crate::schema::rpc_object!(RoboticRotor);
    crate::schema::rpc_object!(ScienceData);
    crate::schema::rpc_object!(ScienceSubject);
    crate::schema::rpc_object!(Sensor);
    crate::schema::rpc_object!(SolarPanel);
    crate::schema::rpc_object!(Thruster);
    crate::schema::rpc_object!(Vessel);
    crate::schema::rpc_object!(Waypoint);
    crate::schema::rpc_object!(WaypointManager);
    crate::schema::rpc_object!(Wheel);
    crate::schema::rpc_enum!(
        AntennaState, [Deployed, Retracted, Deploying, Retracting, Broken,]
    );
    crate::schema::rpc_enum!(
        AutoStrutMode, [Off, Root, Heaviest, Grandparent, ForceRoot, ForceHeaviest,
        ForceGrandparent,]
    );
    crate::schema::rpc_enum!(
        CameraMode, [Automatic, Free, Chase, Locked, Orbital, IVA, Map,]
    );
    crate::schema::rpc_enum!(CargoBayState, [Open, Closed, Opening, Closing,]);
    crate::schema::rpc_enum!(CommLinkType, [Home, Control, Relay,]);
    crate::schema::rpc_enum!(
        ContractState, [Active, Canceled, Completed, DeadlineExpired, Declined, Failed,
        Generated, Offered, OfferExpired, Withdrawn,]
    );
    crate::schema::rpc_enum!(ControlInputMode, [Additive, Override,]);
    crate::schema::rpc_enum!(ControlSource, [Kerbal, Probe, None,]);
    crate::schema::rpc_enum!(ControlState, [Full, Partial, None,]);
    crate::schema::rpc_enum!(CrewMemberGender, [Male, Female,]);
    crate::schema::rpc_enum!(CrewMemberType, [Applicant, Crew, Tourist, Unowned,]);
    crate::schema::rpc_enum!(
        DockingPortState, [Ready, Docked, Docking, Undocking, Shielded, Moving,]
    );
    crate::schema::rpc_enum!(DrainMode, [Part, Vessel,]);
    crate::schema::rpc_enum!(EditorFacility, [VAB, SPH, None,]);
    crate::schema::rpc_enum!(
        GameMode, [Sandbox, Career, Science, ScienceSandbox, Mission, MissionBuilder,
        Scenario, ScenarioNonResumable,]
    );
    crate::schema::rpc_enum!(
        LegState, [Deployed, Retracted, Deploying, Retracting, Broken,]
    );
    crate::schema::rpc_enum!(
        MapFilterType, [All, None, Debris, Unknown, SpaceObjects, Probes, Rovers,
        Landers, Ships, Stations, Bases, EVAs, Flags, Plane, Relay, Site,
        DeployedScienceController,]
    );
    crate::schema::rpc_enum!(
        MotorState, [Idle, Running, Disabled, Inoperable, NotEnoughResources,]
    );
    crate::schema::rpc_enum!(
        ParachuteState, [Stowed, Armed, SemiDeployed, Deployed, Cut,]
    );
    crate::schema::rpc_enum!(
        RadiatorState, [Extended, Retracted, Extending, Retracting, Broken,]
    );
    crate::schema::rpc_enum!(
        ResourceConverterState, [Running, Idle, MissingResource, StorageFull, Capacity,
        Unknown,]
    );
    crate::schema::rpc_enum!(ResourceFlowMode, [Vessel, Stage, Adjacent, None,]);
    crate::schema::rpc_enum!(
        ResourceHarvesterState, [Deploying, Deployed, Retracting, Retracted, Active,]
    );
    crate::schema::rpc_enum!(RosterStatus, [Available, Assigned, Dead, Missing,]);
    crate::schema::rpc_enum!(
        SASMode, [StabilityAssist, Maneuver, Prograde, Retrograde, Normal, AntiNormal,
        Radial, AntiRadial, Target, AntiTarget,]
    );
    crate::schema::rpc_enum!(
        SolarPanelState, [Extended, Retracted, Extending, Retracting, Broken,]
    );
    crate::schema::rpc_enum!(SpeedMode, [Orbit, Surface, Target,]);
    crate::schema::rpc_enum!(SuitType, [Default, Vintage, Future, Slim,]);
    crate::schema::rpc_enum!(
        VesselSituation, [PreLaunch, Orbiting, SubOrbital, Escaping, Flying, Landed,
        Splashed, Docked,]
    );
    crate::schema::rpc_enum!(
        VesselType, [Base, Debris, Lander, Plane, Probe, Relay, Rover, Ship, Station,
        SpaceObject, Unknown, EVA, Flag, DeployedScienceController, DeployedSciencePart,
        DroppedPart, DeployedGroundPart,]
    );
    crate::schema::rpc_enum!(WarpMode, [Rails, Physics, None,]);
    crate::schema::rpc_enum!(
        WheelState, [Deployed, Retracted, Deploying, Retracting, Broken,]
    );
    impl AlarmManager {
        pub(crate) fn get_alarms_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "AlarmManager_get_Alarms",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_alarms_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Vec<crate::services::space_center::Alarm>>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_alarms_call()?)
        }
        pub fn get_alarms(
            &self,
        ) -> Result<Vec<crate::services::space_center::Alarm>, RpcError> {
            let request = crate::schema::Request::from(self.get_alarms_call()?);
            let response = self.client.call(request)?;
            <Vec<
                crate::services::space_center::Alarm,
            >>::from_response(response, self.client.clone())
        }
    }
    impl AlarmManager {
        pub(crate) fn static_add_alarm_call(
            &self,
            time: f64,
            title: String,
            description: String,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "AlarmManager_static_AddAlarm",
                    vec![
                        time.to_argument(0usize as u32) ?, title.to_argument(1usize as
                        u32) ?, description.to_argument(2usize as u32) ?
                    ],
                ),
            )
        }
        pub fn static_add_alarm_stream(
            &self,
            time: f64,
            title: String,
            description: String,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::Alarm>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.static_add_alarm_call(time, title, description)?,
            )
        }
        pub fn static_add_alarm(
            &self,
            time: f64,
            title: String,
            description: String,
        ) -> Result<crate::services::space_center::Alarm, RpcError> {
            let request = crate::schema::Request::from(
                self.static_add_alarm_call(time, title, description)?,
            );
            let response = self.client.call(request)?;
            <crate::services::space_center::Alarm>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl AlarmManager {
        pub(crate) fn static_add_apoapsis_alarm_call(
            &self,
            vessel: &crate::services::space_center::Vessel,
            offset: f64,
            title: String,
            description: String,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "AlarmManager_static_AddApoapsisAlarm",
                    vec![
                        vessel.to_argument(0usize as u32) ?, offset.to_argument(1usize as
                        u32) ?, title.to_argument(2usize as u32) ?, description
                        .to_argument(3usize as u32) ?
                    ],
                ),
            )
        }
        pub fn static_add_apoapsis_alarm_stream(
            &self,
            vessel: &crate::services::space_center::Vessel,
            offset: f64,
            title: String,
            description: String,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::Alarm>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.static_add_apoapsis_alarm_call(vessel, offset, title, description)?,
            )
        }
        pub fn static_add_apoapsis_alarm(
            &self,
            vessel: &crate::services::space_center::Vessel,
            offset: f64,
            title: String,
            description: String,
        ) -> Result<crate::services::space_center::Alarm, RpcError> {
            let request = crate::schema::Request::from(
                self.static_add_apoapsis_alarm_call(vessel, offset, title, description)?,
            );
            let response = self.client.call(request)?;
            <crate::services::space_center::Alarm>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl AlarmManager {
        pub(crate) fn static_add_maneuver_node_alarm_call(
            &self,
            vessel: &crate::services::space_center::Vessel,
            node: &crate::services::space_center::Node,
            offset: f64,
            add_burn_time: bool,
            title: String,
            description: String,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "AlarmManager_static_AddManeuverNodeAlarm",
                    vec![
                        vessel.to_argument(0usize as u32) ?, node.to_argument(1usize as
                        u32) ?, offset.to_argument(2usize as u32) ?, add_burn_time
                        .to_argument(3usize as u32) ?, title.to_argument(4usize as u32)
                        ?, description.to_argument(5usize as u32) ?
                    ],
                ),
            )
        }
        pub fn static_add_maneuver_node_alarm_stream(
            &self,
            vessel: &crate::services::space_center::Vessel,
            node: &crate::services::space_center::Node,
            offset: f64,
            add_burn_time: bool,
            title: String,
            description: String,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::Alarm>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self
                    .static_add_maneuver_node_alarm_call(
                        vessel,
                        node,
                        offset,
                        add_burn_time,
                        title,
                        description,
                    )?,
            )
        }
        pub fn static_add_maneuver_node_alarm(
            &self,
            vessel: &crate::services::space_center::Vessel,
            node: &crate::services::space_center::Node,
            offset: f64,
            add_burn_time: bool,
            title: String,
            description: String,
        ) -> Result<crate::services::space_center::Alarm, RpcError> {
            let request = crate::schema::Request::from(
                self
                    .static_add_maneuver_node_alarm_call(
                        vessel,
                        node,
                        offset,
                        add_burn_time,
                        title,
                        description,
                    )?,
            );
            let response = self.client.call(request)?;
            <crate::services::space_center::Alarm>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl AlarmManager {
        pub(crate) fn static_add_periapsis_alarm_call(
            &self,
            vessel: &crate::services::space_center::Vessel,
            offset: f64,
            title: String,
            description: String,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "AlarmManager_static_AddPeriapsisAlarm",
                    vec![
                        vessel.to_argument(0usize as u32) ?, offset.to_argument(1usize as
                        u32) ?, title.to_argument(2usize as u32) ?, description
                        .to_argument(3usize as u32) ?
                    ],
                ),
            )
        }
        pub fn static_add_periapsis_alarm_stream(
            &self,
            vessel: &crate::services::space_center::Vessel,
            offset: f64,
            title: String,
            description: String,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::Alarm>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.static_add_periapsis_alarm_call(vessel, offset, title, description)?,
            )
        }
        pub fn static_add_periapsis_alarm(
            &self,
            vessel: &crate::services::space_center::Vessel,
            offset: f64,
            title: String,
            description: String,
        ) -> Result<crate::services::space_center::Alarm, RpcError> {
            let request = crate::schema::Request::from(
                self.static_add_periapsis_alarm_call(vessel, offset, title, description)?,
            );
            let response = self.client.call(request)?;
            <crate::services::space_center::Alarm>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl AlarmManager {
        pub(crate) fn static_add_soi_alarm_call(
            &self,
            vessel: &crate::services::space_center::Vessel,
            offset: f64,
            title: String,
            description: String,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "AlarmManager_static_AddSOIAlarm",
                    vec![
                        vessel.to_argument(0usize as u32) ?, offset.to_argument(1usize as
                        u32) ?, title.to_argument(2usize as u32) ?, description
                        .to_argument(3usize as u32) ?
                    ],
                ),
            )
        }
        pub fn static_add_soi_alarm_stream(
            &self,
            vessel: &crate::services::space_center::Vessel,
            offset: f64,
            title: String,
            description: String,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::Alarm>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.static_add_soi_alarm_call(vessel, offset, title, description)?,
            )
        }
        pub fn static_add_soi_alarm(
            &self,
            vessel: &crate::services::space_center::Vessel,
            offset: f64,
            title: String,
            description: String,
        ) -> Result<crate::services::space_center::Alarm, RpcError> {
            let request = crate::schema::Request::from(
                self.static_add_soi_alarm_call(vessel, offset, title, description)?,
            );
            let response = self.client.call(request)?;
            <crate::services::space_center::Alarm>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl AlarmManager {
        pub(crate) fn static_add_vessel_alarm_call(
            &self,
            time: f64,
            vessel: &crate::services::space_center::Vessel,
            title: String,
            description: String,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "AlarmManager_static_AddVesselAlarm",
                    vec![
                        time.to_argument(0usize as u32) ?, vessel.to_argument(1usize as
                        u32) ?, title.to_argument(2usize as u32) ?, description
                        .to_argument(3usize as u32) ?
                    ],
                ),
            )
        }
        pub fn static_add_vessel_alarm_stream(
            &self,
            time: f64,
            vessel: &crate::services::space_center::Vessel,
            title: String,
            description: String,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::Alarm>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.static_add_vessel_alarm_call(time, vessel, title, description)?,
            )
        }
        pub fn static_add_vessel_alarm(
            &self,
            time: f64,
            vessel: &crate::services::space_center::Vessel,
            title: String,
            description: String,
        ) -> Result<crate::services::space_center::Alarm, RpcError> {
            let request = crate::schema::Request::from(
                self.static_add_vessel_alarm_call(time, vessel, title, description)?,
            );
            let response = self.client.call(request)?;
            <crate::services::space_center::Alarm>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Alarm {
        pub(crate) fn get_description_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Alarm_get_Description",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_description_stream(
            &self,
        ) -> Result<crate::stream::Stream<String>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_description_call()?)
        }
        pub fn get_description(&self) -> Result<String, RpcError> {
            let request = crate::schema::Request::from(self.get_description_call()?);
            let response = self.client.call(request)?;
            <String>::from_response(response, self.client.clone())
        }
    }
    impl Alarm {
        pub(crate) fn get_event_offset_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Alarm_get_EventOffset",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_event_offset_stream(
            &self,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_event_offset_call()?,
            )
        }
        pub fn get_event_offset(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(self.get_event_offset_call()?);
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Alarm {
        pub(crate) fn get_id_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Alarm_get_ID",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_id_stream(
            &self,
        ) -> Result<crate::stream::Stream<Option<u32>>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_id_call()?)
        }
        pub fn get_id(&self) -> Result<Option<u32>, RpcError> {
            let request = crate::schema::Request::from(self.get_id_call()?);
            let response = self.client.call(request)?;
            <Option<u32>>::from_response(response, self.client.clone())
        }
    }
    impl Alarm {
        pub(crate) fn get_time_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Alarm_get_Time",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_time_stream(&self) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_time_call()?)
        }
        pub fn get_time(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(self.get_time_call()?);
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Alarm {
        pub(crate) fn get_time_until_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Alarm_get_TimeUntil",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_time_until_stream(
            &self,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_time_until_call()?)
        }
        pub fn get_time_until(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(self.get_time_until_call()?);
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Alarm {
        pub(crate) fn get_title_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Alarm_get_Title",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_title_stream(
            &self,
        ) -> Result<crate::stream::Stream<String>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_title_call()?)
        }
        pub fn get_title(&self) -> Result<String, RpcError> {
            let request = crate::schema::Request::from(self.get_title_call()?);
            let response = self.client.call(request)?;
            <String>::from_response(response, self.client.clone())
        }
    }
    impl Alarm {
        pub(crate) fn get_type_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Alarm_get_Type",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_type_stream(
            &self,
        ) -> Result<crate::stream::Stream<String>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_type_call()?)
        }
        pub fn get_type(&self) -> Result<String, RpcError> {
            let request = crate::schema::Request::from(self.get_type_call()?);
            let response = self.client.call(request)?;
            <String>::from_response(response, self.client.clone())
        }
    }
    impl Alarm {
        pub(crate) fn get_vessel_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Alarm_get_Vessel",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_vessel_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Option<crate::services::space_center::Vessel>>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_vessel_call()?)
        }
        pub fn get_vessel(
            &self,
        ) -> Result<Option<crate::services::space_center::Vessel>, RpcError> {
            let request = crate::schema::Request::from(self.get_vessel_call()?);
            let response = self.client.call(request)?;
            <Option<
                crate::services::space_center::Vessel,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Antenna {
        pub(crate) fn cancel_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Antenna_Cancel",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn cancel_stream(&self) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.cancel_call()?)
        }
        pub fn cancel(&self) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.cancel_call()?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Antenna {
        pub(crate) fn transmit_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Antenna_Transmit",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn transmit_stream(&self) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.transmit_call()?)
        }
        pub fn transmit(&self) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.transmit_call()?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Antenna {
        pub(crate) fn get_allow_partial_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Antenna_get_AllowPartial",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_allow_partial_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_allow_partial_call()?,
            )
        }
        pub fn get_allow_partial(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_allow_partial_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Antenna {
        pub(crate) fn get_can_transmit_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Antenna_get_CanTransmit",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_can_transmit_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_can_transmit_call()?,
            )
        }
        pub fn get_can_transmit(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_can_transmit_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Antenna {
        pub(crate) fn get_combinable_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Antenna_get_Combinable",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_combinable_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_combinable_call()?)
        }
        pub fn get_combinable(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_combinable_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Antenna {
        pub(crate) fn get_combinable_exponent_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Antenna_get_CombinableExponent",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_combinable_exponent_stream(
            &self,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_combinable_exponent_call()?,
            )
        }
        pub fn get_combinable_exponent(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(
                self.get_combinable_exponent_call()?,
            );
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Antenna {
        pub(crate) fn get_deployable_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Antenna_get_Deployable",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_deployable_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_deployable_call()?)
        }
        pub fn get_deployable(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_deployable_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Antenna {
        pub(crate) fn get_deployed_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Antenna_get_Deployed",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_deployed_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_deployed_call()?)
        }
        pub fn get_deployed(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_deployed_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Antenna {
        pub(crate) fn get_packet_interval_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Antenna_get_PacketInterval",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_packet_interval_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_packet_interval_call()?,
            )
        }
        pub fn get_packet_interval(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_packet_interval_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Antenna {
        pub(crate) fn get_packet_resource_cost_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Antenna_get_PacketResourceCost",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_packet_resource_cost_stream(
            &self,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_packet_resource_cost_call()?,
            )
        }
        pub fn get_packet_resource_cost(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(
                self.get_packet_resource_cost_call()?,
            );
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Antenna {
        pub(crate) fn get_packet_size_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Antenna_get_PacketSize",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_packet_size_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_packet_size_call()?)
        }
        pub fn get_packet_size(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_packet_size_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Antenna {
        pub(crate) fn get_part_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Antenna_get_Part",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_part_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::Part>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_part_call()?)
        }
        pub fn get_part(&self) -> Result<crate::services::space_center::Part, RpcError> {
            let request = crate::schema::Request::from(self.get_part_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::Part>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Antenna {
        pub(crate) fn get_power_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Antenna_get_Power",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_power_stream(&self) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_power_call()?)
        }
        pub fn get_power(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(self.get_power_call()?);
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Antenna {
        pub(crate) fn get_state_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Antenna_get_State",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_state_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::AntennaState>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_state_call()?)
        }
        pub fn get_state(
            &self,
        ) -> Result<crate::services::space_center::AntennaState, RpcError> {
            let request = crate::schema::Request::from(self.get_state_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::AntennaState>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Antenna {
        pub(crate) fn set_allow_partial_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Antenna_set_AllowPartial",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_allow_partial_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_allow_partial_call(value)?,
            )
        }
        pub fn set_allow_partial(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_allow_partial_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Antenna {
        pub(crate) fn set_deployed_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Antenna_set_Deployed",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_deployed_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_deployed_call(value)?,
            )
        }
        pub fn set_deployed(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_deployed_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl AutoPilot {
        pub(crate) fn disengage_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "AutoPilot_Disengage",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn disengage_stream(&self) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.disengage_call()?)
        }
        pub fn disengage(&self) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.disengage_call()?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl AutoPilot {
        pub(crate) fn engage_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "AutoPilot_Engage",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn engage_stream(&self) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.engage_call()?)
        }
        pub fn engage(&self) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.engage_call()?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl AutoPilot {
        pub(crate) fn target_pitch_and_heading_call(
            &self,
            pitch: f32,
            heading: f32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "AutoPilot_TargetPitchAndHeading",
                    vec![
                        self.to_argument(0usize as u32) ?, pitch.to_argument(1usize as
                        u32) ?, heading.to_argument(2usize as u32) ?
                    ],
                ),
            )
        }
        pub fn target_pitch_and_heading_stream(
            &self,
            pitch: f32,
            heading: f32,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.target_pitch_and_heading_call(pitch, heading)?,
            )
        }
        pub fn target_pitch_and_heading(
            &self,
            pitch: f32,
            heading: f32,
        ) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.target_pitch_and_heading_call(pitch, heading)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl AutoPilot {
        pub(crate) fn wait_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "AutoPilot_Wait",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn wait_stream(&self) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.wait_call()?)
        }
        pub fn wait(&self) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.wait_call()?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl AutoPilot {
        pub(crate) fn get_attenuation_angle_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "AutoPilot_get_AttenuationAngle",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_attenuation_angle_stream(
            &self,
        ) -> Result<crate::stream::Stream<(f64, f64, f64)>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_attenuation_angle_call()?,
            )
        }
        pub fn get_attenuation_angle(&self) -> Result<(f64, f64, f64), RpcError> {
            let request = crate::schema::Request::from(
                self.get_attenuation_angle_call()?,
            );
            let response = self.client.call(request)?;
            <(f64, f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl AutoPilot {
        pub(crate) fn get_auto_tune_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "AutoPilot_get_AutoTune",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_auto_tune_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_auto_tune_call()?)
        }
        pub fn get_auto_tune(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_auto_tune_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl AutoPilot {
        pub(crate) fn get_deceleration_time_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "AutoPilot_get_DecelerationTime",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_deceleration_time_stream(
            &self,
        ) -> Result<crate::stream::Stream<(f64, f64, f64)>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_deceleration_time_call()?,
            )
        }
        pub fn get_deceleration_time(&self) -> Result<(f64, f64, f64), RpcError> {
            let request = crate::schema::Request::from(
                self.get_deceleration_time_call()?,
            );
            let response = self.client.call(request)?;
            <(f64, f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl AutoPilot {
        pub(crate) fn get_error_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "AutoPilot_get_Error",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_error_stream(&self) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_error_call()?)
        }
        pub fn get_error(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_error_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl AutoPilot {
        pub(crate) fn get_heading_error_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "AutoPilot_get_HeadingError",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_heading_error_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_heading_error_call()?,
            )
        }
        pub fn get_heading_error(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_heading_error_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl AutoPilot {
        pub(crate) fn get_overshoot_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "AutoPilot_get_Overshoot",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_overshoot_stream(
            &self,
        ) -> Result<crate::stream::Stream<(f64, f64, f64)>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_overshoot_call()?)
        }
        pub fn get_overshoot(&self) -> Result<(f64, f64, f64), RpcError> {
            let request = crate::schema::Request::from(self.get_overshoot_call()?);
            let response = self.client.call(request)?;
            <(f64, f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl AutoPilot {
        pub(crate) fn get_pitch_error_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "AutoPilot_get_PitchError",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_pitch_error_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_pitch_error_call()?)
        }
        pub fn get_pitch_error(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_pitch_error_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl AutoPilot {
        pub(crate) fn get_pitch_pid_gains_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "AutoPilot_get_PitchPIDGains",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_pitch_pid_gains_stream(
            &self,
        ) -> Result<crate::stream::Stream<(f64, f64, f64)>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_pitch_pid_gains_call()?,
            )
        }
        pub fn get_pitch_pid_gains(&self) -> Result<(f64, f64, f64), RpcError> {
            let request = crate::schema::Request::from(self.get_pitch_pid_gains_call()?);
            let response = self.client.call(request)?;
            <(f64, f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl AutoPilot {
        pub(crate) fn get_reference_frame_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "AutoPilot_get_ReferenceFrame",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_reference_frame_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::ReferenceFrame>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_reference_frame_call()?,
            )
        }
        pub fn get_reference_frame(
            &self,
        ) -> Result<crate::services::space_center::ReferenceFrame, RpcError> {
            let request = crate::schema::Request::from(self.get_reference_frame_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::ReferenceFrame>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl AutoPilot {
        pub(crate) fn get_roll_error_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "AutoPilot_get_RollError",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_roll_error_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_roll_error_call()?)
        }
        pub fn get_roll_error(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_roll_error_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl AutoPilot {
        pub(crate) fn get_roll_pid_gains_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "AutoPilot_get_RollPIDGains",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_roll_pid_gains_stream(
            &self,
        ) -> Result<crate::stream::Stream<(f64, f64, f64)>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_roll_pid_gains_call()?,
            )
        }
        pub fn get_roll_pid_gains(&self) -> Result<(f64, f64, f64), RpcError> {
            let request = crate::schema::Request::from(self.get_roll_pid_gains_call()?);
            let response = self.client.call(request)?;
            <(f64, f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl AutoPilot {
        pub(crate) fn get_roll_threshold_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "AutoPilot_get_RollThreshold",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_roll_threshold_stream(
            &self,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_roll_threshold_call()?,
            )
        }
        pub fn get_roll_threshold(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(self.get_roll_threshold_call()?);
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl AutoPilot {
        pub(crate) fn get_sas_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "AutoPilot_get_SAS",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_sas_stream(&self) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_sas_call()?)
        }
        pub fn get_sas(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_sas_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl AutoPilot {
        pub(crate) fn get_sas_mode_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "AutoPilot_get_SASMode",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_sas_mode_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::SASMode>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_sas_mode_call()?)
        }
        pub fn get_sas_mode(
            &self,
        ) -> Result<crate::services::space_center::SASMode, RpcError> {
            let request = crate::schema::Request::from(self.get_sas_mode_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::SASMode>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl AutoPilot {
        pub(crate) fn get_stopping_time_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "AutoPilot_get_StoppingTime",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_stopping_time_stream(
            &self,
        ) -> Result<crate::stream::Stream<(f64, f64, f64)>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_stopping_time_call()?,
            )
        }
        pub fn get_stopping_time(&self) -> Result<(f64, f64, f64), RpcError> {
            let request = crate::schema::Request::from(self.get_stopping_time_call()?);
            let response = self.client.call(request)?;
            <(f64, f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl AutoPilot {
        pub(crate) fn get_target_direction_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "AutoPilot_get_TargetDirection",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_target_direction_stream(
            &self,
        ) -> Result<crate::stream::Stream<(f64, f64, f64)>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_target_direction_call()?,
            )
        }
        pub fn get_target_direction(&self) -> Result<(f64, f64, f64), RpcError> {
            let request = crate::schema::Request::from(
                self.get_target_direction_call()?,
            );
            let response = self.client.call(request)?;
            <(f64, f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl AutoPilot {
        pub(crate) fn get_target_heading_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "AutoPilot_get_TargetHeading",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_target_heading_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_target_heading_call()?,
            )
        }
        pub fn get_target_heading(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_target_heading_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl AutoPilot {
        pub(crate) fn get_target_pitch_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "AutoPilot_get_TargetPitch",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_target_pitch_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_target_pitch_call()?,
            )
        }
        pub fn get_target_pitch(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_target_pitch_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl AutoPilot {
        pub(crate) fn get_target_roll_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "AutoPilot_get_TargetRoll",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_target_roll_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_target_roll_call()?)
        }
        pub fn get_target_roll(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_target_roll_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl AutoPilot {
        pub(crate) fn get_time_to_peak_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "AutoPilot_get_TimeToPeak",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_time_to_peak_stream(
            &self,
        ) -> Result<crate::stream::Stream<(f64, f64, f64)>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_time_to_peak_call()?,
            )
        }
        pub fn get_time_to_peak(&self) -> Result<(f64, f64, f64), RpcError> {
            let request = crate::schema::Request::from(self.get_time_to_peak_call()?);
            let response = self.client.call(request)?;
            <(f64, f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl AutoPilot {
        pub(crate) fn get_yaw_pid_gains_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "AutoPilot_get_YawPIDGains",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_yaw_pid_gains_stream(
            &self,
        ) -> Result<crate::stream::Stream<(f64, f64, f64)>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_yaw_pid_gains_call()?,
            )
        }
        pub fn get_yaw_pid_gains(&self) -> Result<(f64, f64, f64), RpcError> {
            let request = crate::schema::Request::from(self.get_yaw_pid_gains_call()?);
            let response = self.client.call(request)?;
            <(f64, f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl AutoPilot {
        pub(crate) fn set_attenuation_angle_call(
            &self,
            value: (f64, f64, f64),
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "AutoPilot_set_AttenuationAngle",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_attenuation_angle_stream(
            &self,
            value: (f64, f64, f64),
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_attenuation_angle_call(value)?,
            )
        }
        pub fn set_attenuation_angle(
            &self,
            value: (f64, f64, f64),
        ) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_attenuation_angle_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl AutoPilot {
        pub(crate) fn set_auto_tune_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "AutoPilot_set_AutoTune",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_auto_tune_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_auto_tune_call(value)?,
            )
        }
        pub fn set_auto_tune(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_auto_tune_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl AutoPilot {
        pub(crate) fn set_deceleration_time_call(
            &self,
            value: (f64, f64, f64),
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "AutoPilot_set_DecelerationTime",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_deceleration_time_stream(
            &self,
            value: (f64, f64, f64),
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_deceleration_time_call(value)?,
            )
        }
        pub fn set_deceleration_time(
            &self,
            value: (f64, f64, f64),
        ) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_deceleration_time_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl AutoPilot {
        pub(crate) fn set_overshoot_call(
            &self,
            value: (f64, f64, f64),
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "AutoPilot_set_Overshoot",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_overshoot_stream(
            &self,
            value: (f64, f64, f64),
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_overshoot_call(value)?,
            )
        }
        pub fn set_overshoot(&self, value: (f64, f64, f64)) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_overshoot_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl AutoPilot {
        pub(crate) fn set_pitch_pid_gains_call(
            &self,
            value: (f64, f64, f64),
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "AutoPilot_set_PitchPIDGains",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_pitch_pid_gains_stream(
            &self,
            value: (f64, f64, f64),
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_pitch_pid_gains_call(value)?,
            )
        }
        pub fn set_pitch_pid_gains(
            &self,
            value: (f64, f64, f64),
        ) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_pitch_pid_gains_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl AutoPilot {
        pub(crate) fn set_reference_frame_call(
            &self,
            value: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "AutoPilot_set_ReferenceFrame",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_reference_frame_stream(
            &self,
            value: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_reference_frame_call(value)?,
            )
        }
        pub fn set_reference_frame(
            &self,
            value: &crate::services::space_center::ReferenceFrame,
        ) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_reference_frame_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl AutoPilot {
        pub(crate) fn set_roll_pid_gains_call(
            &self,
            value: (f64, f64, f64),
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "AutoPilot_set_RollPIDGains",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_roll_pid_gains_stream(
            &self,
            value: (f64, f64, f64),
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_roll_pid_gains_call(value)?,
            )
        }
        pub fn set_roll_pid_gains(
            &self,
            value: (f64, f64, f64),
        ) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_roll_pid_gains_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl AutoPilot {
        pub(crate) fn set_roll_threshold_call(
            &self,
            value: f64,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "AutoPilot_set_RollThreshold",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_roll_threshold_stream(
            &self,
            value: f64,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_roll_threshold_call(value)?,
            )
        }
        pub fn set_roll_threshold(&self, value: f64) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_roll_threshold_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl AutoPilot {
        pub(crate) fn set_sas_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "AutoPilot_set_SAS",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_sas_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.set_sas_call(value)?)
        }
        pub fn set_sas(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_sas_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl AutoPilot {
        pub(crate) fn set_sas_mode_call(
            &self,
            value: crate::services::space_center::SASMode,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "AutoPilot_set_SASMode",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_sas_mode_stream(
            &self,
            value: crate::services::space_center::SASMode,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_sas_mode_call(value)?,
            )
        }
        pub fn set_sas_mode(
            &self,
            value: crate::services::space_center::SASMode,
        ) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_sas_mode_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl AutoPilot {
        pub(crate) fn set_stopping_time_call(
            &self,
            value: (f64, f64, f64),
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "AutoPilot_set_StoppingTime",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_stopping_time_stream(
            &self,
            value: (f64, f64, f64),
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_stopping_time_call(value)?,
            )
        }
        pub fn set_stopping_time(&self, value: (f64, f64, f64)) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_stopping_time_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl AutoPilot {
        pub(crate) fn set_target_direction_call(
            &self,
            value: (f64, f64, f64),
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "AutoPilot_set_TargetDirection",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_target_direction_stream(
            &self,
            value: (f64, f64, f64),
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_target_direction_call(value)?,
            )
        }
        pub fn set_target_direction(
            &self,
            value: (f64, f64, f64),
        ) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_target_direction_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl AutoPilot {
        pub(crate) fn set_target_heading_call(
            &self,
            value: f32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "AutoPilot_set_TargetHeading",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_target_heading_stream(
            &self,
            value: f32,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_target_heading_call(value)?,
            )
        }
        pub fn set_target_heading(&self, value: f32) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_target_heading_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl AutoPilot {
        pub(crate) fn set_target_pitch_call(
            &self,
            value: f32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "AutoPilot_set_TargetPitch",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_target_pitch_stream(
            &self,
            value: f32,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_target_pitch_call(value)?,
            )
        }
        pub fn set_target_pitch(&self, value: f32) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_target_pitch_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl AutoPilot {
        pub(crate) fn set_target_roll_call(
            &self,
            value: f32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "AutoPilot_set_TargetRoll",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_target_roll_stream(
            &self,
            value: f32,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_target_roll_call(value)?,
            )
        }
        pub fn set_target_roll(&self, value: f32) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_target_roll_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl AutoPilot {
        pub(crate) fn set_time_to_peak_call(
            &self,
            value: (f64, f64, f64),
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "AutoPilot_set_TimeToPeak",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_time_to_peak_stream(
            &self,
            value: (f64, f64, f64),
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_time_to_peak_call(value)?,
            )
        }
        pub fn set_time_to_peak(&self, value: (f64, f64, f64)) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_time_to_peak_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl AutoPilot {
        pub(crate) fn set_yaw_pid_gains_call(
            &self,
            value: (f64, f64, f64),
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "AutoPilot_set_YawPIDGains",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_yaw_pid_gains_stream(
            &self,
            value: (f64, f64, f64),
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_yaw_pid_gains_call(value)?,
            )
        }
        pub fn set_yaw_pid_gains(&self, value: (f64, f64, f64)) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_yaw_pid_gains_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Camera {
        pub(crate) fn get_default_distance_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Camera_get_DefaultDistance",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_default_distance_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_default_distance_call()?,
            )
        }
        pub fn get_default_distance(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(
                self.get_default_distance_call()?,
            );
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Camera {
        pub(crate) fn get_distance_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Camera_get_Distance",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_distance_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_distance_call()?)
        }
        pub fn get_distance(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_distance_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Camera {
        pub(crate) fn get_focussed_body_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Camera_get_FocussedBody",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_focussed_body_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Option<crate::services::space_center::CelestialBody>>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_focussed_body_call()?,
            )
        }
        pub fn get_focussed_body(
            &self,
        ) -> Result<Option<crate::services::space_center::CelestialBody>, RpcError> {
            let request = crate::schema::Request::from(self.get_focussed_body_call()?);
            let response = self.client.call(request)?;
            <Option<
                crate::services::space_center::CelestialBody,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Camera {
        pub(crate) fn get_focussed_node_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Camera_get_FocussedNode",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_focussed_node_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Option<crate::services::space_center::Node>>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_focussed_node_call()?,
            )
        }
        pub fn get_focussed_node(
            &self,
        ) -> Result<Option<crate::services::space_center::Node>, RpcError> {
            let request = crate::schema::Request::from(self.get_focussed_node_call()?);
            let response = self.client.call(request)?;
            <Option<
                crate::services::space_center::Node,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Camera {
        pub(crate) fn get_focussed_vessel_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Camera_get_FocussedVessel",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_focussed_vessel_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Option<crate::services::space_center::Vessel>>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_focussed_vessel_call()?,
            )
        }
        pub fn get_focussed_vessel(
            &self,
        ) -> Result<Option<crate::services::space_center::Vessel>, RpcError> {
            let request = crate::schema::Request::from(self.get_focussed_vessel_call()?);
            let response = self.client.call(request)?;
            <Option<
                crate::services::space_center::Vessel,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Camera {
        pub(crate) fn get_heading_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Camera_get_Heading",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_heading_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_heading_call()?)
        }
        pub fn get_heading(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_heading_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Camera {
        pub(crate) fn get_max_distance_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Camera_get_MaxDistance",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_max_distance_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_max_distance_call()?,
            )
        }
        pub fn get_max_distance(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_max_distance_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Camera {
        pub(crate) fn get_max_pitch_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Camera_get_MaxPitch",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_max_pitch_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_max_pitch_call()?)
        }
        pub fn get_max_pitch(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_max_pitch_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Camera {
        pub(crate) fn get_min_distance_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Camera_get_MinDistance",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_min_distance_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_min_distance_call()?,
            )
        }
        pub fn get_min_distance(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_min_distance_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Camera {
        pub(crate) fn get_min_pitch_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Camera_get_MinPitch",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_min_pitch_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_min_pitch_call()?)
        }
        pub fn get_min_pitch(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_min_pitch_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Camera {
        pub(crate) fn get_mode_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Camera_get_Mode",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_mode_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::CameraMode>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_mode_call()?)
        }
        pub fn get_mode(
            &self,
        ) -> Result<crate::services::space_center::CameraMode, RpcError> {
            let request = crate::schema::Request::from(self.get_mode_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::CameraMode>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Camera {
        pub(crate) fn get_pitch_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Camera_get_Pitch",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_pitch_stream(&self) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_pitch_call()?)
        }
        pub fn get_pitch(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_pitch_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Camera {
        pub(crate) fn set_distance_call(
            &self,
            value: f32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Camera_set_Distance",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_distance_stream(
            &self,
            value: f32,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_distance_call(value)?,
            )
        }
        pub fn set_distance(&self, value: f32) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_distance_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Camera {
        pub(crate) fn set_focussed_body_call(
            &self,
            value: &crate::services::space_center::CelestialBody,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Camera_set_FocussedBody",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_focussed_body_stream(
            &self,
            value: &crate::services::space_center::CelestialBody,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_focussed_body_call(value)?,
            )
        }
        pub fn set_focussed_body(
            &self,
            value: &crate::services::space_center::CelestialBody,
        ) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_focussed_body_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Camera {
        pub(crate) fn set_focussed_node_call(
            &self,
            value: &crate::services::space_center::Node,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Camera_set_FocussedNode",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_focussed_node_stream(
            &self,
            value: &crate::services::space_center::Node,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_focussed_node_call(value)?,
            )
        }
        pub fn set_focussed_node(
            &self,
            value: &crate::services::space_center::Node,
        ) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_focussed_node_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Camera {
        pub(crate) fn set_focussed_vessel_call(
            &self,
            value: &crate::services::space_center::Vessel,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Camera_set_FocussedVessel",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_focussed_vessel_stream(
            &self,
            value: &crate::services::space_center::Vessel,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_focussed_vessel_call(value)?,
            )
        }
        pub fn set_focussed_vessel(
            &self,
            value: &crate::services::space_center::Vessel,
        ) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_focussed_vessel_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Camera {
        pub(crate) fn set_heading_call(
            &self,
            value: f32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Camera_set_Heading",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_heading_stream(
            &self,
            value: f32,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_heading_call(value)?,
            )
        }
        pub fn set_heading(&self, value: f32) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_heading_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Camera {
        pub(crate) fn set_mode_call(
            &self,
            value: crate::services::space_center::CameraMode,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Camera_set_Mode",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_mode_stream(
            &self,
            value: crate::services::space_center::CameraMode,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.set_mode_call(value)?)
        }
        pub fn set_mode(
            &self,
            value: crate::services::space_center::CameraMode,
        ) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_mode_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Camera {
        pub(crate) fn set_pitch_call(
            &self,
            value: f32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Camera_set_Pitch",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_pitch_stream(
            &self,
            value: f32,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.set_pitch_call(value)?)
        }
        pub fn set_pitch(&self, value: f32) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_pitch_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl SpaceCenter {
        pub(crate) fn can_rails_warp_at_call(
            &self,
            factor: i32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "CanRailsWarpAt",
                    vec![factor.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn can_rails_warp_at_stream(
            &self,
            factor: i32,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.can_rails_warp_at_call(factor)?,
            )
        }
        pub fn can_rails_warp_at(&self, factor: i32) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(
                self.can_rails_warp_at_call(factor)?,
            );
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl SpaceCenter {
        pub(crate) fn can_revert_to_launch_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "CanRevertToLaunch",
                    vec![],
                ),
            )
        }
        pub fn can_revert_to_launch_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.can_revert_to_launch_call()?,
            )
        }
        pub fn can_revert_to_launch(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(
                self.can_revert_to_launch_call()?,
            );
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl CargoBay {
        pub(crate) fn get_open_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "CargoBay_get_Open",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_open_stream(&self) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_open_call()?)
        }
        pub fn get_open(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_open_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl CargoBay {
        pub(crate) fn get_part_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "CargoBay_get_Part",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_part_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::Part>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_part_call()?)
        }
        pub fn get_part(&self) -> Result<crate::services::space_center::Part, RpcError> {
            let request = crate::schema::Request::from(self.get_part_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::Part>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl CargoBay {
        pub(crate) fn get_state_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "CargoBay_get_State",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_state_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::CargoBayState>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_state_call()?)
        }
        pub fn get_state(
            &self,
        ) -> Result<crate::services::space_center::CargoBayState, RpcError> {
            let request = crate::schema::Request::from(self.get_state_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::CargoBayState>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl CargoBay {
        pub(crate) fn set_open_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "CargoBay_set_Open",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_open_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.set_open_call(value)?)
        }
        pub fn set_open(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_open_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl CelestialBody {
        pub(crate) fn altitude_at_position_call(
            &self,
            position: (f64, f64, f64),
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "CelestialBody_AltitudeAtPosition",
                    vec![
                        self.to_argument(0usize as u32) ?, position.to_argument(1usize as
                        u32) ?, reference_frame.to_argument(2usize as u32) ?
                    ],
                ),
            )
        }
        pub fn altitude_at_position_stream(
            &self,
            position: (f64, f64, f64),
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.altitude_at_position_call(position, reference_frame)?,
            )
        }
        pub fn altitude_at_position(
            &self,
            position: (f64, f64, f64),
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(
                self.altitude_at_position_call(position, reference_frame)?,
            );
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl CelestialBody {
        pub(crate) fn angular_velocity_call(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "CelestialBody_AngularVelocity",
                    vec![
                        self.to_argument(0usize as u32) ?, reference_frame
                        .to_argument(1usize as u32) ?
                    ],
                ),
            )
        }
        pub fn angular_velocity_stream(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::stream::Stream<(f64, f64, f64)>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.angular_velocity_call(reference_frame)?,
            )
        }
        pub fn angular_velocity(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<(f64, f64, f64), RpcError> {
            let request = crate::schema::Request::from(
                self.angular_velocity_call(reference_frame)?,
            );
            let response = self.client.call(request)?;
            <(f64, f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl CelestialBody {
        pub(crate) fn atmospheric_density_at_position_call(
            &self,
            position: (f64, f64, f64),
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "CelestialBody_AtmosphericDensityAtPosition",
                    vec![
                        self.to_argument(0usize as u32) ?, position.to_argument(1usize as
                        u32) ?, reference_frame.to_argument(2usize as u32) ?
                    ],
                ),
            )
        }
        pub fn atmospheric_density_at_position_stream(
            &self,
            position: (f64, f64, f64),
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.atmospheric_density_at_position_call(position, reference_frame)?,
            )
        }
        pub fn atmospheric_density_at_position(
            &self,
            position: (f64, f64, f64),
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(
                self.atmospheric_density_at_position_call(position, reference_frame)?,
            );
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl CelestialBody {
        pub(crate) fn bedrock_height_call(
            &self,
            latitude: f64,
            longitude: f64,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "CelestialBody_BedrockHeight",
                    vec![
                        self.to_argument(0usize as u32) ?, latitude.to_argument(1usize as
                        u32) ?, longitude.to_argument(2usize as u32) ?
                    ],
                ),
            )
        }
        pub fn bedrock_height_stream(
            &self,
            latitude: f64,
            longitude: f64,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.bedrock_height_call(latitude, longitude)?,
            )
        }
        pub fn bedrock_height(
            &self,
            latitude: f64,
            longitude: f64,
        ) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(
                self.bedrock_height_call(latitude, longitude)?,
            );
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl CelestialBody {
        pub(crate) fn bedrock_position_call(
            &self,
            latitude: f64,
            longitude: f64,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "CelestialBody_BedrockPosition",
                    vec![
                        self.to_argument(0usize as u32) ?, latitude.to_argument(1usize as
                        u32) ?, longitude.to_argument(2usize as u32) ?, reference_frame
                        .to_argument(3usize as u32) ?
                    ],
                ),
            )
        }
        pub fn bedrock_position_stream(
            &self,
            latitude: f64,
            longitude: f64,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::stream::Stream<(f64, f64, f64)>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.bedrock_position_call(latitude, longitude, reference_frame)?,
            )
        }
        pub fn bedrock_position(
            &self,
            latitude: f64,
            longitude: f64,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<(f64, f64, f64), RpcError> {
            let request = crate::schema::Request::from(
                self.bedrock_position_call(latitude, longitude, reference_frame)?,
            );
            let response = self.client.call(request)?;
            <(f64, f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl CelestialBody {
        pub(crate) fn biome_at_call(
            &self,
            latitude: f64,
            longitude: f64,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "CelestialBody_BiomeAt",
                    vec![
                        self.to_argument(0usize as u32) ?, latitude.to_argument(1usize as
                        u32) ?, longitude.to_argument(2usize as u32) ?
                    ],
                ),
            )
        }
        pub fn biome_at_stream(
            &self,
            latitude: f64,
            longitude: f64,
        ) -> Result<crate::stream::Stream<String>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.biome_at_call(latitude, longitude)?,
            )
        }
        pub fn biome_at(
            &self,
            latitude: f64,
            longitude: f64,
        ) -> Result<String, RpcError> {
            let request = crate::schema::Request::from(
                self.biome_at_call(latitude, longitude)?,
            );
            let response = self.client.call(request)?;
            <String>::from_response(response, self.client.clone())
        }
    }
    impl CelestialBody {
        pub(crate) fn density_at_call(
            &self,
            altitude: f64,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "CelestialBody_DensityAt",
                    vec![
                        self.to_argument(0usize as u32) ?, altitude.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn density_at_stream(
            &self,
            altitude: f64,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.density_at_call(altitude)?,
            )
        }
        pub fn density_at(&self, altitude: f64) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(self.density_at_call(altitude)?);
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl CelestialBody {
        pub(crate) fn direction_call(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "CelestialBody_Direction",
                    vec![
                        self.to_argument(0usize as u32) ?, reference_frame
                        .to_argument(1usize as u32) ?
                    ],
                ),
            )
        }
        pub fn direction_stream(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::stream::Stream<(f64, f64, f64)>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.direction_call(reference_frame)?,
            )
        }
        pub fn direction(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<(f64, f64, f64), RpcError> {
            let request = crate::schema::Request::from(
                self.direction_call(reference_frame)?,
            );
            let response = self.client.call(request)?;
            <(f64, f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl CelestialBody {
        pub(crate) fn latitude_at_position_call(
            &self,
            position: (f64, f64, f64),
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "CelestialBody_LatitudeAtPosition",
                    vec![
                        self.to_argument(0usize as u32) ?, position.to_argument(1usize as
                        u32) ?, reference_frame.to_argument(2usize as u32) ?
                    ],
                ),
            )
        }
        pub fn latitude_at_position_stream(
            &self,
            position: (f64, f64, f64),
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.latitude_at_position_call(position, reference_frame)?,
            )
        }
        pub fn latitude_at_position(
            &self,
            position: (f64, f64, f64),
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(
                self.latitude_at_position_call(position, reference_frame)?,
            );
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl CelestialBody {
        pub(crate) fn longitude_at_position_call(
            &self,
            position: (f64, f64, f64),
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "CelestialBody_LongitudeAtPosition",
                    vec![
                        self.to_argument(0usize as u32) ?, position.to_argument(1usize as
                        u32) ?, reference_frame.to_argument(2usize as u32) ?
                    ],
                ),
            )
        }
        pub fn longitude_at_position_stream(
            &self,
            position: (f64, f64, f64),
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.longitude_at_position_call(position, reference_frame)?,
            )
        }
        pub fn longitude_at_position(
            &self,
            position: (f64, f64, f64),
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(
                self.longitude_at_position_call(position, reference_frame)?,
            );
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl CelestialBody {
        pub(crate) fn msl_position_call(
            &self,
            latitude: f64,
            longitude: f64,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "CelestialBody_MSLPosition",
                    vec![
                        self.to_argument(0usize as u32) ?, latitude.to_argument(1usize as
                        u32) ?, longitude.to_argument(2usize as u32) ?, reference_frame
                        .to_argument(3usize as u32) ?
                    ],
                ),
            )
        }
        pub fn msl_position_stream(
            &self,
            latitude: f64,
            longitude: f64,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::stream::Stream<(f64, f64, f64)>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.msl_position_call(latitude, longitude, reference_frame)?,
            )
        }
        pub fn msl_position(
            &self,
            latitude: f64,
            longitude: f64,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<(f64, f64, f64), RpcError> {
            let request = crate::schema::Request::from(
                self.msl_position_call(latitude, longitude, reference_frame)?,
            );
            let response = self.client.call(request)?;
            <(f64, f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl CelestialBody {
        pub(crate) fn position_call(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "CelestialBody_Position",
                    vec![
                        self.to_argument(0usize as u32) ?, reference_frame
                        .to_argument(1usize as u32) ?
                    ],
                ),
            )
        }
        pub fn position_stream(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::stream::Stream<(f64, f64, f64)>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.position_call(reference_frame)?,
            )
        }
        pub fn position(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<(f64, f64, f64), RpcError> {
            let request = crate::schema::Request::from(
                self.position_call(reference_frame)?,
            );
            let response = self.client.call(request)?;
            <(f64, f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl CelestialBody {
        pub(crate) fn position_at_altitude_call(
            &self,
            latitude: f64,
            longitude: f64,
            altitude: f64,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "CelestialBody_PositionAtAltitude",
                    vec![
                        self.to_argument(0usize as u32) ?, latitude.to_argument(1usize as
                        u32) ?, longitude.to_argument(2usize as u32) ?, altitude
                        .to_argument(3usize as u32) ?, reference_frame.to_argument(4usize
                        as u32) ?
                    ],
                ),
            )
        }
        pub fn position_at_altitude_stream(
            &self,
            latitude: f64,
            longitude: f64,
            altitude: f64,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::stream::Stream<(f64, f64, f64)>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self
                    .position_at_altitude_call(
                        latitude,
                        longitude,
                        altitude,
                        reference_frame,
                    )?,
            )
        }
        pub fn position_at_altitude(
            &self,
            latitude: f64,
            longitude: f64,
            altitude: f64,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<(f64, f64, f64), RpcError> {
            let request = crate::schema::Request::from(
                self
                    .position_at_altitude_call(
                        latitude,
                        longitude,
                        altitude,
                        reference_frame,
                    )?,
            );
            let response = self.client.call(request)?;
            <(f64, f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl CelestialBody {
        pub(crate) fn pressure_at_call(
            &self,
            altitude: f64,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "CelestialBody_PressureAt",
                    vec![
                        self.to_argument(0usize as u32) ?, altitude.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn pressure_at_stream(
            &self,
            altitude: f64,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.pressure_at_call(altitude)?,
            )
        }
        pub fn pressure_at(&self, altitude: f64) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(self.pressure_at_call(altitude)?);
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl CelestialBody {
        pub(crate) fn rotation_call(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "CelestialBody_Rotation",
                    vec![
                        self.to_argument(0usize as u32) ?, reference_frame
                        .to_argument(1usize as u32) ?
                    ],
                ),
            )
        }
        pub fn rotation_stream(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::stream::Stream<(f64, f64, f64, f64)>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.rotation_call(reference_frame)?,
            )
        }
        pub fn rotation(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<(f64, f64, f64, f64), RpcError> {
            let request = crate::schema::Request::from(
                self.rotation_call(reference_frame)?,
            );
            let response = self.client.call(request)?;
            <(f64, f64, f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl CelestialBody {
        pub(crate) fn surface_height_call(
            &self,
            latitude: f64,
            longitude: f64,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "CelestialBody_SurfaceHeight",
                    vec![
                        self.to_argument(0usize as u32) ?, latitude.to_argument(1usize as
                        u32) ?, longitude.to_argument(2usize as u32) ?
                    ],
                ),
            )
        }
        pub fn surface_height_stream(
            &self,
            latitude: f64,
            longitude: f64,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.surface_height_call(latitude, longitude)?,
            )
        }
        pub fn surface_height(
            &self,
            latitude: f64,
            longitude: f64,
        ) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(
                self.surface_height_call(latitude, longitude)?,
            );
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl CelestialBody {
        pub(crate) fn surface_position_call(
            &self,
            latitude: f64,
            longitude: f64,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "CelestialBody_SurfacePosition",
                    vec![
                        self.to_argument(0usize as u32) ?, latitude.to_argument(1usize as
                        u32) ?, longitude.to_argument(2usize as u32) ?, reference_frame
                        .to_argument(3usize as u32) ?
                    ],
                ),
            )
        }
        pub fn surface_position_stream(
            &self,
            latitude: f64,
            longitude: f64,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::stream::Stream<(f64, f64, f64)>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.surface_position_call(latitude, longitude, reference_frame)?,
            )
        }
        pub fn surface_position(
            &self,
            latitude: f64,
            longitude: f64,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<(f64, f64, f64), RpcError> {
            let request = crate::schema::Request::from(
                self.surface_position_call(latitude, longitude, reference_frame)?,
            );
            let response = self.client.call(request)?;
            <(f64, f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl CelestialBody {
        pub(crate) fn temperature_at_call(
            &self,
            position: (f64, f64, f64),
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "CelestialBody_TemperatureAt",
                    vec![
                        self.to_argument(0usize as u32) ?, position.to_argument(1usize as
                        u32) ?, reference_frame.to_argument(2usize as u32) ?
                    ],
                ),
            )
        }
        pub fn temperature_at_stream(
            &self,
            position: (f64, f64, f64),
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.temperature_at_call(position, reference_frame)?,
            )
        }
        pub fn temperature_at(
            &self,
            position: (f64, f64, f64),
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(
                self.temperature_at_call(position, reference_frame)?,
            );
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl CelestialBody {
        pub(crate) fn velocity_call(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "CelestialBody_Velocity",
                    vec![
                        self.to_argument(0usize as u32) ?, reference_frame
                        .to_argument(1usize as u32) ?
                    ],
                ),
            )
        }
        pub fn velocity_stream(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::stream::Stream<(f64, f64, f64)>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.velocity_call(reference_frame)?,
            )
        }
        pub fn velocity(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<(f64, f64, f64), RpcError> {
            let request = crate::schema::Request::from(
                self.velocity_call(reference_frame)?,
            );
            let response = self.client.call(request)?;
            <(f64, f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl CelestialBody {
        pub(crate) fn get_atmosphere_depth_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "CelestialBody_get_AtmosphereDepth",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_atmosphere_depth_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_atmosphere_depth_call()?,
            )
        }
        pub fn get_atmosphere_depth(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(
                self.get_atmosphere_depth_call()?,
            );
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl CelestialBody {
        pub(crate) fn get_biomes_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "CelestialBody_get_Biomes",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_biomes_stream(
            &self,
        ) -> Result<crate::stream::Stream<std::collections::HashSet<String>>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_biomes_call()?)
        }
        pub fn get_biomes(&self) -> Result<std::collections::HashSet<String>, RpcError> {
            let request = crate::schema::Request::from(self.get_biomes_call()?);
            let response = self.client.call(request)?;
            <std::collections::HashSet<
                String,
            >>::from_response(response, self.client.clone())
        }
    }
    impl CelestialBody {
        pub(crate) fn get_equatorial_radius_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "CelestialBody_get_EquatorialRadius",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_equatorial_radius_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_equatorial_radius_call()?,
            )
        }
        pub fn get_equatorial_radius(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(
                self.get_equatorial_radius_call()?,
            );
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl CelestialBody {
        pub(crate) fn get_flying_high_altitude_threshold_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "CelestialBody_get_FlyingHighAltitudeThreshold",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_flying_high_altitude_threshold_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_flying_high_altitude_threshold_call()?,
            )
        }
        pub fn get_flying_high_altitude_threshold(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(
                self.get_flying_high_altitude_threshold_call()?,
            );
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl CelestialBody {
        pub(crate) fn get_gravitational_parameter_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "CelestialBody_get_GravitationalParameter",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_gravitational_parameter_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_gravitational_parameter_call()?,
            )
        }
        pub fn get_gravitational_parameter(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(
                self.get_gravitational_parameter_call()?,
            );
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl CelestialBody {
        pub(crate) fn get_has_atmosphere_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "CelestialBody_get_HasAtmosphere",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_has_atmosphere_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_has_atmosphere_call()?,
            )
        }
        pub fn get_has_atmosphere(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_has_atmosphere_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl CelestialBody {
        pub(crate) fn get_has_atmospheric_oxygen_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "CelestialBody_get_HasAtmosphericOxygen",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_has_atmospheric_oxygen_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_has_atmospheric_oxygen_call()?,
            )
        }
        pub fn get_has_atmospheric_oxygen(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(
                self.get_has_atmospheric_oxygen_call()?,
            );
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl CelestialBody {
        pub(crate) fn get_has_solid_surface_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "CelestialBody_get_HasSolidSurface",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_has_solid_surface_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_has_solid_surface_call()?,
            )
        }
        pub fn get_has_solid_surface(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(
                self.get_has_solid_surface_call()?,
            );
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl CelestialBody {
        pub(crate) fn get_initial_rotation_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "CelestialBody_get_InitialRotation",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_initial_rotation_stream(
            &self,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_initial_rotation_call()?,
            )
        }
        pub fn get_initial_rotation(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(
                self.get_initial_rotation_call()?,
            );
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl CelestialBody {
        pub(crate) fn get_is_star_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "CelestialBody_get_IsStar",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_is_star_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_is_star_call()?)
        }
        pub fn get_is_star(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_is_star_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl CelestialBody {
        pub(crate) fn get_mass_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "CelestialBody_get_Mass",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_mass_stream(&self) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_mass_call()?)
        }
        pub fn get_mass(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_mass_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl CelestialBody {
        pub(crate) fn get_name_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "CelestialBody_get_Name",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_name_stream(
            &self,
        ) -> Result<crate::stream::Stream<String>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_name_call()?)
        }
        pub fn get_name(&self) -> Result<String, RpcError> {
            let request = crate::schema::Request::from(self.get_name_call()?);
            let response = self.client.call(request)?;
            <String>::from_response(response, self.client.clone())
        }
    }
    impl CelestialBody {
        pub(crate) fn get_non_rotating_reference_frame_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "CelestialBody_get_NonRotatingReferenceFrame",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_non_rotating_reference_frame_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::ReferenceFrame>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_non_rotating_reference_frame_call()?,
            )
        }
        pub fn get_non_rotating_reference_frame(
            &self,
        ) -> Result<crate::services::space_center::ReferenceFrame, RpcError> {
            let request = crate::schema::Request::from(
                self.get_non_rotating_reference_frame_call()?,
            );
            let response = self.client.call(request)?;
            <crate::services::space_center::ReferenceFrame>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl CelestialBody {
        pub(crate) fn get_orbit_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "CelestialBody_get_Orbit",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_orbit_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Option<crate::services::space_center::Orbit>>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_orbit_call()?)
        }
        pub fn get_orbit(
            &self,
        ) -> Result<Option<crate::services::space_center::Orbit>, RpcError> {
            let request = crate::schema::Request::from(self.get_orbit_call()?);
            let response = self.client.call(request)?;
            <Option<
                crate::services::space_center::Orbit,
            >>::from_response(response, self.client.clone())
        }
    }
    impl CelestialBody {
        pub(crate) fn get_orbital_reference_frame_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "CelestialBody_get_OrbitalReferenceFrame",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_orbital_reference_frame_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::ReferenceFrame>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_orbital_reference_frame_call()?,
            )
        }
        pub fn get_orbital_reference_frame(
            &self,
        ) -> Result<crate::services::space_center::ReferenceFrame, RpcError> {
            let request = crate::schema::Request::from(
                self.get_orbital_reference_frame_call()?,
            );
            let response = self.client.call(request)?;
            <crate::services::space_center::ReferenceFrame>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl CelestialBody {
        pub(crate) fn get_reference_frame_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "CelestialBody_get_ReferenceFrame",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_reference_frame_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::ReferenceFrame>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_reference_frame_call()?,
            )
        }
        pub fn get_reference_frame(
            &self,
        ) -> Result<crate::services::space_center::ReferenceFrame, RpcError> {
            let request = crate::schema::Request::from(self.get_reference_frame_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::ReferenceFrame>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl CelestialBody {
        pub(crate) fn get_rotation_angle_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "CelestialBody_get_RotationAngle",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_rotation_angle_stream(
            &self,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_rotation_angle_call()?,
            )
        }
        pub fn get_rotation_angle(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(self.get_rotation_angle_call()?);
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl CelestialBody {
        pub(crate) fn get_rotational_period_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "CelestialBody_get_RotationalPeriod",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_rotational_period_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_rotational_period_call()?,
            )
        }
        pub fn get_rotational_period(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(
                self.get_rotational_period_call()?,
            );
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl CelestialBody {
        pub(crate) fn get_rotational_speed_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "CelestialBody_get_RotationalSpeed",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_rotational_speed_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_rotational_speed_call()?,
            )
        }
        pub fn get_rotational_speed(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(
                self.get_rotational_speed_call()?,
            );
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl CelestialBody {
        pub(crate) fn get_satellites_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "CelestialBody_get_Satellites",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_satellites_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Vec<crate::services::space_center::CelestialBody>>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_satellites_call()?)
        }
        pub fn get_satellites(
            &self,
        ) -> Result<Vec<crate::services::space_center::CelestialBody>, RpcError> {
            let request = crate::schema::Request::from(self.get_satellites_call()?);
            let response = self.client.call(request)?;
            <Vec<
                crate::services::space_center::CelestialBody,
            >>::from_response(response, self.client.clone())
        }
    }
    impl CelestialBody {
        pub(crate) fn get_space_high_altitude_threshold_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "CelestialBody_get_SpaceHighAltitudeThreshold",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_space_high_altitude_threshold_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_space_high_altitude_threshold_call()?,
            )
        }
        pub fn get_space_high_altitude_threshold(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(
                self.get_space_high_altitude_threshold_call()?,
            );
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl CelestialBody {
        pub(crate) fn get_sphere_of_influence_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "CelestialBody_get_SphereOfInfluence",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_sphere_of_influence_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_sphere_of_influence_call()?,
            )
        }
        pub fn get_sphere_of_influence(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(
                self.get_sphere_of_influence_call()?,
            );
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl CelestialBody {
        pub(crate) fn get_surface_gravity_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "CelestialBody_get_SurfaceGravity",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_surface_gravity_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_surface_gravity_call()?,
            )
        }
        pub fn get_surface_gravity(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_surface_gravity_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl SpaceCenter {
        pub(crate) fn clear_target_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(crate::client::Client::proc_call("SpaceCenter", "ClearTarget", vec![]))
        }
        pub fn clear_target_stream(
            &self,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.clear_target_call()?)
        }
        pub fn clear_target(&self) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.clear_target_call()?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl CommLink {
        pub(crate) fn get_end_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "CommLink_get_End",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_end_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::CommNode>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_end_call()?)
        }
        pub fn get_end(
            &self,
        ) -> Result<crate::services::space_center::CommNode, RpcError> {
            let request = crate::schema::Request::from(self.get_end_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::CommNode>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl CommLink {
        pub(crate) fn get_signal_strength_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "CommLink_get_SignalStrength",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_signal_strength_stream(
            &self,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_signal_strength_call()?,
            )
        }
        pub fn get_signal_strength(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(self.get_signal_strength_call()?);
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl CommLink {
        pub(crate) fn get_start_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "CommLink_get_Start",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_start_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::CommNode>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_start_call()?)
        }
        pub fn get_start(
            &self,
        ) -> Result<crate::services::space_center::CommNode, RpcError> {
            let request = crate::schema::Request::from(self.get_start_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::CommNode>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl CommLink {
        pub(crate) fn get_type_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "CommLink_get_Type",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_type_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::CommLinkType>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_type_call()?)
        }
        pub fn get_type(
            &self,
        ) -> Result<crate::services::space_center::CommLinkType, RpcError> {
            let request = crate::schema::Request::from(self.get_type_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::CommLinkType>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl CommNode {
        pub(crate) fn get_is_control_point_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "CommNode_get_IsControlPoint",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_is_control_point_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_is_control_point_call()?,
            )
        }
        pub fn get_is_control_point(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(
                self.get_is_control_point_call()?,
            );
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl CommNode {
        pub(crate) fn get_is_home_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "CommNode_get_IsHome",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_is_home_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_is_home_call()?)
        }
        pub fn get_is_home(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_is_home_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl CommNode {
        pub(crate) fn get_is_vessel_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "CommNode_get_IsVessel",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_is_vessel_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_is_vessel_call()?)
        }
        pub fn get_is_vessel(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_is_vessel_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl CommNode {
        pub(crate) fn get_name_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "CommNode_get_Name",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_name_stream(
            &self,
        ) -> Result<crate::stream::Stream<String>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_name_call()?)
        }
        pub fn get_name(&self) -> Result<String, RpcError> {
            let request = crate::schema::Request::from(self.get_name_call()?);
            let response = self.client.call(request)?;
            <String>::from_response(response, self.client.clone())
        }
    }
    impl CommNode {
        pub(crate) fn get_vessel_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "CommNode_get_Vessel",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_vessel_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::Vessel>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_vessel_call()?)
        }
        pub fn get_vessel(
            &self,
        ) -> Result<crate::services::space_center::Vessel, RpcError> {
            let request = crate::schema::Request::from(self.get_vessel_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::Vessel>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Comms {
        pub(crate) fn get_can_communicate_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Comms_get_CanCommunicate",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_can_communicate_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_can_communicate_call()?,
            )
        }
        pub fn get_can_communicate(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_can_communicate_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Comms {
        pub(crate) fn get_can_transmit_science_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Comms_get_CanTransmitScience",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_can_transmit_science_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_can_transmit_science_call()?,
            )
        }
        pub fn get_can_transmit_science(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(
                self.get_can_transmit_science_call()?,
            );
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Comms {
        pub(crate) fn get_control_path_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Comms_get_ControlPath",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_control_path_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Vec<crate::services::space_center::CommLink>>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_control_path_call()?,
            )
        }
        pub fn get_control_path(
            &self,
        ) -> Result<Vec<crate::services::space_center::CommLink>, RpcError> {
            let request = crate::schema::Request::from(self.get_control_path_call()?);
            let response = self.client.call(request)?;
            <Vec<
                crate::services::space_center::CommLink,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Comms {
        pub(crate) fn get_power_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Comms_get_Power",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_power_stream(&self) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_power_call()?)
        }
        pub fn get_power(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(self.get_power_call()?);
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Comms {
        pub(crate) fn get_signal_delay_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Comms_get_SignalDelay",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_signal_delay_stream(
            &self,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_signal_delay_call()?,
            )
        }
        pub fn get_signal_delay(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(self.get_signal_delay_call()?);
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Comms {
        pub(crate) fn get_signal_strength_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Comms_get_SignalStrength",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_signal_strength_stream(
            &self,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_signal_strength_call()?,
            )
        }
        pub fn get_signal_strength(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(self.get_signal_strength_call()?);
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl ContractManager {
        pub(crate) fn get_active_contracts_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ContractManager_get_ActiveContracts",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_active_contracts_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Vec<crate::services::space_center::Contract>>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_active_contracts_call()?,
            )
        }
        pub fn get_active_contracts(
            &self,
        ) -> Result<Vec<crate::services::space_center::Contract>, RpcError> {
            let request = crate::schema::Request::from(
                self.get_active_contracts_call()?,
            );
            let response = self.client.call(request)?;
            <Vec<
                crate::services::space_center::Contract,
            >>::from_response(response, self.client.clone())
        }
    }
    impl ContractManager {
        pub(crate) fn get_all_contracts_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ContractManager_get_AllContracts",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_all_contracts_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Vec<crate::services::space_center::Contract>>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_all_contracts_call()?,
            )
        }
        pub fn get_all_contracts(
            &self,
        ) -> Result<Vec<crate::services::space_center::Contract>, RpcError> {
            let request = crate::schema::Request::from(self.get_all_contracts_call()?);
            let response = self.client.call(request)?;
            <Vec<
                crate::services::space_center::Contract,
            >>::from_response(response, self.client.clone())
        }
    }
    impl ContractManager {
        pub(crate) fn get_completed_contracts_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ContractManager_get_CompletedContracts",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_completed_contracts_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Vec<crate::services::space_center::Contract>>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_completed_contracts_call()?,
            )
        }
        pub fn get_completed_contracts(
            &self,
        ) -> Result<Vec<crate::services::space_center::Contract>, RpcError> {
            let request = crate::schema::Request::from(
                self.get_completed_contracts_call()?,
            );
            let response = self.client.call(request)?;
            <Vec<
                crate::services::space_center::Contract,
            >>::from_response(response, self.client.clone())
        }
    }
    impl ContractManager {
        pub(crate) fn get_failed_contracts_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ContractManager_get_FailedContracts",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_failed_contracts_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Vec<crate::services::space_center::Contract>>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_failed_contracts_call()?,
            )
        }
        pub fn get_failed_contracts(
            &self,
        ) -> Result<Vec<crate::services::space_center::Contract>, RpcError> {
            let request = crate::schema::Request::from(
                self.get_failed_contracts_call()?,
            );
            let response = self.client.call(request)?;
            <Vec<
                crate::services::space_center::Contract,
            >>::from_response(response, self.client.clone())
        }
    }
    impl ContractManager {
        pub(crate) fn get_offered_contracts_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ContractManager_get_OfferedContracts",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_offered_contracts_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Vec<crate::services::space_center::Contract>>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_offered_contracts_call()?,
            )
        }
        pub fn get_offered_contracts(
            &self,
        ) -> Result<Vec<crate::services::space_center::Contract>, RpcError> {
            let request = crate::schema::Request::from(
                self.get_offered_contracts_call()?,
            );
            let response = self.client.call(request)?;
            <Vec<
                crate::services::space_center::Contract,
            >>::from_response(response, self.client.clone())
        }
    }
    impl ContractManager {
        pub(crate) fn get_types_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ContractManager_get_Types",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_types_stream(
            &self,
        ) -> Result<crate::stream::Stream<std::collections::HashSet<String>>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_types_call()?)
        }
        pub fn get_types(&self) -> Result<std::collections::HashSet<String>, RpcError> {
            let request = crate::schema::Request::from(self.get_types_call()?);
            let response = self.client.call(request)?;
            <std::collections::HashSet<
                String,
            >>::from_response(response, self.client.clone())
        }
    }
    impl ContractParameter {
        pub(crate) fn get_children_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ContractParameter_get_Children",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_children_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Vec<crate::services::space_center::ContractParameter>>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_children_call()?)
        }
        pub fn get_children(
            &self,
        ) -> Result<Vec<crate::services::space_center::ContractParameter>, RpcError> {
            let request = crate::schema::Request::from(self.get_children_call()?);
            let response = self.client.call(request)?;
            <Vec<
                crate::services::space_center::ContractParameter,
            >>::from_response(response, self.client.clone())
        }
    }
    impl ContractParameter {
        pub(crate) fn get_completed_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ContractParameter_get_Completed",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_completed_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_completed_call()?)
        }
        pub fn get_completed(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_completed_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl ContractParameter {
        pub(crate) fn get_failed_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ContractParameter_get_Failed",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_failed_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_failed_call()?)
        }
        pub fn get_failed(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_failed_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl ContractParameter {
        pub(crate) fn get_funds_completion_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ContractParameter_get_FundsCompletion",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_funds_completion_stream(
            &self,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_funds_completion_call()?,
            )
        }
        pub fn get_funds_completion(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(
                self.get_funds_completion_call()?,
            );
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl ContractParameter {
        pub(crate) fn get_funds_failure_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ContractParameter_get_FundsFailure",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_funds_failure_stream(
            &self,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_funds_failure_call()?,
            )
        }
        pub fn get_funds_failure(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(self.get_funds_failure_call()?);
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl ContractParameter {
        pub(crate) fn get_notes_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ContractParameter_get_Notes",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_notes_stream(
            &self,
        ) -> Result<crate::stream::Stream<String>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_notes_call()?)
        }
        pub fn get_notes(&self) -> Result<String, RpcError> {
            let request = crate::schema::Request::from(self.get_notes_call()?);
            let response = self.client.call(request)?;
            <String>::from_response(response, self.client.clone())
        }
    }
    impl ContractParameter {
        pub(crate) fn get_optional_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ContractParameter_get_Optional",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_optional_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_optional_call()?)
        }
        pub fn get_optional(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_optional_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl ContractParameter {
        pub(crate) fn get_reputation_completion_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ContractParameter_get_ReputationCompletion",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_reputation_completion_stream(
            &self,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_reputation_completion_call()?,
            )
        }
        pub fn get_reputation_completion(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(
                self.get_reputation_completion_call()?,
            );
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl ContractParameter {
        pub(crate) fn get_reputation_failure_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ContractParameter_get_ReputationFailure",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_reputation_failure_stream(
            &self,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_reputation_failure_call()?,
            )
        }
        pub fn get_reputation_failure(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(
                self.get_reputation_failure_call()?,
            );
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl ContractParameter {
        pub(crate) fn get_science_completion_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ContractParameter_get_ScienceCompletion",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_science_completion_stream(
            &self,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_science_completion_call()?,
            )
        }
        pub fn get_science_completion(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(
                self.get_science_completion_call()?,
            );
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl ContractParameter {
        pub(crate) fn get_title_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ContractParameter_get_Title",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_title_stream(
            &self,
        ) -> Result<crate::stream::Stream<String>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_title_call()?)
        }
        pub fn get_title(&self) -> Result<String, RpcError> {
            let request = crate::schema::Request::from(self.get_title_call()?);
            let response = self.client.call(request)?;
            <String>::from_response(response, self.client.clone())
        }
    }
    impl Contract {
        pub(crate) fn accept_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Contract_Accept",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn accept_stream(&self) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.accept_call()?)
        }
        pub fn accept(&self) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.accept_call()?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Contract {
        pub(crate) fn cancel_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Contract_Cancel",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn cancel_stream(&self) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.cancel_call()?)
        }
        pub fn cancel(&self) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.cancel_call()?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Contract {
        pub(crate) fn decline_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Contract_Decline",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn decline_stream(&self) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.decline_call()?)
        }
        pub fn decline(&self) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.decline_call()?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Contract {
        pub(crate) fn get_active_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Contract_get_Active",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_active_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_active_call()?)
        }
        pub fn get_active(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_active_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Contract {
        pub(crate) fn get_can_be_canceled_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Contract_get_CanBeCanceled",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_can_be_canceled_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_can_be_canceled_call()?,
            )
        }
        pub fn get_can_be_canceled(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_can_be_canceled_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Contract {
        pub(crate) fn get_can_be_declined_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Contract_get_CanBeDeclined",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_can_be_declined_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_can_be_declined_call()?,
            )
        }
        pub fn get_can_be_declined(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_can_be_declined_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Contract {
        pub(crate) fn get_can_be_failed_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Contract_get_CanBeFailed",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_can_be_failed_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_can_be_failed_call()?,
            )
        }
        pub fn get_can_be_failed(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_can_be_failed_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Contract {
        pub(crate) fn get_description_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Contract_get_Description",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_description_stream(
            &self,
        ) -> Result<crate::stream::Stream<String>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_description_call()?)
        }
        pub fn get_description(&self) -> Result<String, RpcError> {
            let request = crate::schema::Request::from(self.get_description_call()?);
            let response = self.client.call(request)?;
            <String>::from_response(response, self.client.clone())
        }
    }
    impl Contract {
        pub(crate) fn get_failed_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Contract_get_Failed",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_failed_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_failed_call()?)
        }
        pub fn get_failed(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_failed_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Contract {
        pub(crate) fn get_funds_advance_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Contract_get_FundsAdvance",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_funds_advance_stream(
            &self,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_funds_advance_call()?,
            )
        }
        pub fn get_funds_advance(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(self.get_funds_advance_call()?);
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Contract {
        pub(crate) fn get_funds_completion_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Contract_get_FundsCompletion",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_funds_completion_stream(
            &self,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_funds_completion_call()?,
            )
        }
        pub fn get_funds_completion(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(
                self.get_funds_completion_call()?,
            );
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Contract {
        pub(crate) fn get_funds_failure_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Contract_get_FundsFailure",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_funds_failure_stream(
            &self,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_funds_failure_call()?,
            )
        }
        pub fn get_funds_failure(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(self.get_funds_failure_call()?);
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Contract {
        pub(crate) fn get_keywords_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Contract_get_Keywords",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_keywords_stream(
            &self,
        ) -> Result<crate::stream::Stream<Vec<String>>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_keywords_call()?)
        }
        pub fn get_keywords(&self) -> Result<Vec<String>, RpcError> {
            let request = crate::schema::Request::from(self.get_keywords_call()?);
            let response = self.client.call(request)?;
            <Vec<String>>::from_response(response, self.client.clone())
        }
    }
    impl Contract {
        pub(crate) fn get_notes_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Contract_get_Notes",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_notes_stream(
            &self,
        ) -> Result<crate::stream::Stream<String>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_notes_call()?)
        }
        pub fn get_notes(&self) -> Result<String, RpcError> {
            let request = crate::schema::Request::from(self.get_notes_call()?);
            let response = self.client.call(request)?;
            <String>::from_response(response, self.client.clone())
        }
    }
    impl Contract {
        pub(crate) fn get_parameters_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Contract_get_Parameters",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_parameters_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Vec<crate::services::space_center::ContractParameter>>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_parameters_call()?)
        }
        pub fn get_parameters(
            &self,
        ) -> Result<Vec<crate::services::space_center::ContractParameter>, RpcError> {
            let request = crate::schema::Request::from(self.get_parameters_call()?);
            let response = self.client.call(request)?;
            <Vec<
                crate::services::space_center::ContractParameter,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Contract {
        pub(crate) fn get_read_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Contract_get_Read",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_read_stream(&self) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_read_call()?)
        }
        pub fn get_read(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_read_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Contract {
        pub(crate) fn get_reputation_completion_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Contract_get_ReputationCompletion",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_reputation_completion_stream(
            &self,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_reputation_completion_call()?,
            )
        }
        pub fn get_reputation_completion(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(
                self.get_reputation_completion_call()?,
            );
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Contract {
        pub(crate) fn get_reputation_failure_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Contract_get_ReputationFailure",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_reputation_failure_stream(
            &self,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_reputation_failure_call()?,
            )
        }
        pub fn get_reputation_failure(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(
                self.get_reputation_failure_call()?,
            );
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Contract {
        pub(crate) fn get_science_completion_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Contract_get_ScienceCompletion",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_science_completion_stream(
            &self,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_science_completion_call()?,
            )
        }
        pub fn get_science_completion(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(
                self.get_science_completion_call()?,
            );
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Contract {
        pub(crate) fn get_seen_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Contract_get_Seen",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_seen_stream(&self) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_seen_call()?)
        }
        pub fn get_seen(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_seen_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Contract {
        pub(crate) fn get_state_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Contract_get_State",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_state_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::ContractState>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_state_call()?)
        }
        pub fn get_state(
            &self,
        ) -> Result<crate::services::space_center::ContractState, RpcError> {
            let request = crate::schema::Request::from(self.get_state_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::ContractState>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Contract {
        pub(crate) fn get_synopsis_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Contract_get_Synopsis",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_synopsis_stream(
            &self,
        ) -> Result<crate::stream::Stream<String>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_synopsis_call()?)
        }
        pub fn get_synopsis(&self) -> Result<String, RpcError> {
            let request = crate::schema::Request::from(self.get_synopsis_call()?);
            let response = self.client.call(request)?;
            <String>::from_response(response, self.client.clone())
        }
    }
    impl Contract {
        pub(crate) fn get_title_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Contract_get_Title",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_title_stream(
            &self,
        ) -> Result<crate::stream::Stream<String>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_title_call()?)
        }
        pub fn get_title(&self) -> Result<String, RpcError> {
            let request = crate::schema::Request::from(self.get_title_call()?);
            let response = self.client.call(request)?;
            <String>::from_response(response, self.client.clone())
        }
    }
    impl Contract {
        pub(crate) fn get_type_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Contract_get_Type",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_type_stream(
            &self,
        ) -> Result<crate::stream::Stream<String>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_type_call()?)
        }
        pub fn get_type(&self) -> Result<String, RpcError> {
            let request = crate::schema::Request::from(self.get_type_call()?);
            let response = self.client.call(request)?;
            <String>::from_response(response, self.client.clone())
        }
    }
    impl ControlSurface {
        pub(crate) fn get_authority_limiter_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ControlSurface_get_AuthorityLimiter",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_authority_limiter_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_authority_limiter_call()?,
            )
        }
        pub fn get_authority_limiter(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(
                self.get_authority_limiter_call()?,
            );
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl ControlSurface {
        pub(crate) fn get_available_torque_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ControlSurface_get_AvailableTorque",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_available_torque_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<((f64, f64, f64), (f64, f64, f64))>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_available_torque_call()?,
            )
        }
        pub fn get_available_torque(
            &self,
        ) -> Result<((f64, f64, f64), (f64, f64, f64)), RpcError> {
            let request = crate::schema::Request::from(
                self.get_available_torque_call()?,
            );
            let response = self.client.call(request)?;
            <(
                (f64, f64, f64),
                (f64, f64, f64),
            )>::from_response(response, self.client.clone())
        }
    }
    impl ControlSurface {
        pub(crate) fn get_deployed_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ControlSurface_get_Deployed",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_deployed_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_deployed_call()?)
        }
        pub fn get_deployed(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_deployed_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl ControlSurface {
        pub(crate) fn get_inverted_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ControlSurface_get_Inverted",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_inverted_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_inverted_call()?)
        }
        pub fn get_inverted(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_inverted_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl ControlSurface {
        pub(crate) fn get_part_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ControlSurface_get_Part",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_part_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::Part>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_part_call()?)
        }
        pub fn get_part(&self) -> Result<crate::services::space_center::Part, RpcError> {
            let request = crate::schema::Request::from(self.get_part_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::Part>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl ControlSurface {
        pub(crate) fn get_pitch_enabled_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ControlSurface_get_PitchEnabled",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_pitch_enabled_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_pitch_enabled_call()?,
            )
        }
        pub fn get_pitch_enabled(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_pitch_enabled_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl ControlSurface {
        pub(crate) fn get_roll_enabled_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ControlSurface_get_RollEnabled",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_roll_enabled_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_roll_enabled_call()?,
            )
        }
        pub fn get_roll_enabled(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_roll_enabled_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl ControlSurface {
        pub(crate) fn get_surface_area_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ControlSurface_get_SurfaceArea",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_surface_area_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_surface_area_call()?,
            )
        }
        pub fn get_surface_area(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_surface_area_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl ControlSurface {
        pub(crate) fn get_yaw_enabled_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ControlSurface_get_YawEnabled",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_yaw_enabled_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_yaw_enabled_call()?)
        }
        pub fn get_yaw_enabled(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_yaw_enabled_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl ControlSurface {
        pub(crate) fn set_authority_limiter_call(
            &self,
            value: f32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ControlSurface_set_AuthorityLimiter",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_authority_limiter_stream(
            &self,
            value: f32,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_authority_limiter_call(value)?,
            )
        }
        pub fn set_authority_limiter(&self, value: f32) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_authority_limiter_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl ControlSurface {
        pub(crate) fn set_deployed_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ControlSurface_set_Deployed",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_deployed_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_deployed_call(value)?,
            )
        }
        pub fn set_deployed(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_deployed_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl ControlSurface {
        pub(crate) fn set_inverted_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ControlSurface_set_Inverted",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_inverted_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_inverted_call(value)?,
            )
        }
        pub fn set_inverted(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_inverted_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl ControlSurface {
        pub(crate) fn set_pitch_enabled_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ControlSurface_set_PitchEnabled",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_pitch_enabled_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_pitch_enabled_call(value)?,
            )
        }
        pub fn set_pitch_enabled(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_pitch_enabled_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl ControlSurface {
        pub(crate) fn set_roll_enabled_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ControlSurface_set_RollEnabled",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_roll_enabled_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_roll_enabled_call(value)?,
            )
        }
        pub fn set_roll_enabled(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_roll_enabled_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl ControlSurface {
        pub(crate) fn set_yaw_enabled_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ControlSurface_set_YawEnabled",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_yaw_enabled_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_yaw_enabled_call(value)?,
            )
        }
        pub fn set_yaw_enabled(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_yaw_enabled_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Control {
        pub(crate) fn activate_next_stage_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Control_ActivateNextStage",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn activate_next_stage_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Vec<crate::services::space_center::Vessel>>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.activate_next_stage_call()?,
            )
        }
        pub fn activate_next_stage(
            &self,
        ) -> Result<Vec<crate::services::space_center::Vessel>, RpcError> {
            let request = crate::schema::Request::from(self.activate_next_stage_call()?);
            let response = self.client.call(request)?;
            <Vec<
                crate::services::space_center::Vessel,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Control {
        pub(crate) fn add_node_call(
            &self,
            ut: f64,
            prograde: f32,
            normal: f32,
            radial: f32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Control_AddNode",
                    vec![
                        self.to_argument(0usize as u32) ?, ut.to_argument(1usize as u32)
                        ?, prograde.to_argument(2usize as u32) ?, normal
                        .to_argument(3usize as u32) ?, radial.to_argument(4usize as u32)
                        ?
                    ],
                ),
            )
        }
        pub fn add_node_stream(
            &self,
            ut: f64,
            prograde: f32,
            normal: f32,
            radial: f32,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::Node>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.add_node_call(ut, prograde, normal, radial)?,
            )
        }
        pub fn add_node(
            &self,
            ut: f64,
            prograde: f32,
            normal: f32,
            radial: f32,
        ) -> Result<crate::services::space_center::Node, RpcError> {
            let request = crate::schema::Request::from(
                self.add_node_call(ut, prograde, normal, radial)?,
            );
            let response = self.client.call(request)?;
            <crate::services::space_center::Node>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Control {
        pub(crate) fn get_action_group_call(
            &self,
            group: u32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Control_GetActionGroup",
                    vec![
                        self.to_argument(0usize as u32) ?, group.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn get_action_group_stream(
            &self,
            group: u32,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_action_group_call(group)?,
            )
        }
        pub fn get_action_group(&self, group: u32) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(
                self.get_action_group_call(group)?,
            );
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Control {
        pub(crate) fn remove_nodes_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Control_RemoveNodes",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn remove_nodes_stream(
            &self,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.remove_nodes_call()?)
        }
        pub fn remove_nodes(&self) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.remove_nodes_call()?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Control {
        pub(crate) fn set_action_group_call(
            &self,
            group: u32,
            state: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Control_SetActionGroup",
                    vec![
                        self.to_argument(0usize as u32) ?, group.to_argument(1usize as
                        u32) ?, state.to_argument(2usize as u32) ?
                    ],
                ),
            )
        }
        pub fn set_action_group_stream(
            &self,
            group: u32,
            state: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_action_group_call(group, state)?,
            )
        }
        pub fn set_action_group(&self, group: u32, state: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_action_group_call(group, state)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Control {
        pub(crate) fn toggle_action_group_call(
            &self,
            group: u32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Control_ToggleActionGroup",
                    vec![
                        self.to_argument(0usize as u32) ?, group.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn toggle_action_group_stream(
            &self,
            group: u32,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.toggle_action_group_call(group)?,
            )
        }
        pub fn toggle_action_group(&self, group: u32) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.toggle_action_group_call(group)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Control {
        pub(crate) fn get_abort_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Control_get_Abort",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_abort_stream(&self) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_abort_call()?)
        }
        pub fn get_abort(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_abort_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Control {
        pub(crate) fn get_antennas_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Control_get_Antennas",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_antennas_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_antennas_call()?)
        }
        pub fn get_antennas(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_antennas_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Control {
        pub(crate) fn get_brakes_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Control_get_Brakes",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_brakes_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_brakes_call()?)
        }
        pub fn get_brakes(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_brakes_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Control {
        pub(crate) fn get_cargo_bays_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Control_get_CargoBays",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_cargo_bays_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_cargo_bays_call()?)
        }
        pub fn get_cargo_bays(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_cargo_bays_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Control {
        pub(crate) fn get_current_stage_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Control_get_CurrentStage",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_current_stage_stream(
            &self,
        ) -> Result<crate::stream::Stream<i32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_current_stage_call()?,
            )
        }
        pub fn get_current_stage(&self) -> Result<i32, RpcError> {
            let request = crate::schema::Request::from(self.get_current_stage_call()?);
            let response = self.client.call(request)?;
            <i32>::from_response(response, self.client.clone())
        }
    }
    impl Control {
        pub(crate) fn get_custom_axis_01_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Control_get_CustomAxis01",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_custom_axis_01_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_custom_axis_01_call()?,
            )
        }
        pub fn get_custom_axis_01(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_custom_axis_01_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Control {
        pub(crate) fn get_custom_axis_02_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Control_get_CustomAxis02",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_custom_axis_02_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_custom_axis_02_call()?,
            )
        }
        pub fn get_custom_axis_02(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_custom_axis_02_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Control {
        pub(crate) fn get_custom_axis_03_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Control_get_CustomAxis03",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_custom_axis_03_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_custom_axis_03_call()?,
            )
        }
        pub fn get_custom_axis_03(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_custom_axis_03_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Control {
        pub(crate) fn get_custom_axis_04_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Control_get_CustomAxis04",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_custom_axis_04_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_custom_axis_04_call()?,
            )
        }
        pub fn get_custom_axis_04(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_custom_axis_04_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Control {
        pub(crate) fn get_forward_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Control_get_Forward",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_forward_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_forward_call()?)
        }
        pub fn get_forward(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_forward_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Control {
        pub(crate) fn get_gear_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Control_get_Gear",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_gear_stream(&self) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_gear_call()?)
        }
        pub fn get_gear(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_gear_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Control {
        pub(crate) fn get_input_mode_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Control_get_InputMode",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_input_mode_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::ControlInputMode>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_input_mode_call()?)
        }
        pub fn get_input_mode(
            &self,
        ) -> Result<crate::services::space_center::ControlInputMode, RpcError> {
            let request = crate::schema::Request::from(self.get_input_mode_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::ControlInputMode>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Control {
        pub(crate) fn get_intakes_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Control_get_Intakes",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_intakes_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_intakes_call()?)
        }
        pub fn get_intakes(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_intakes_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Control {
        pub(crate) fn get_legs_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Control_get_Legs",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_legs_stream(&self) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_legs_call()?)
        }
        pub fn get_legs(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_legs_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Control {
        pub(crate) fn get_lights_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Control_get_Lights",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_lights_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_lights_call()?)
        }
        pub fn get_lights(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_lights_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Control {
        pub(crate) fn get_nodes_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Control_get_Nodes",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_nodes_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Vec<crate::services::space_center::Node>>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_nodes_call()?)
        }
        pub fn get_nodes(
            &self,
        ) -> Result<Vec<crate::services::space_center::Node>, RpcError> {
            let request = crate::schema::Request::from(self.get_nodes_call()?);
            let response = self.client.call(request)?;
            <Vec<
                crate::services::space_center::Node,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Control {
        pub(crate) fn get_parachutes_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Control_get_Parachutes",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_parachutes_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_parachutes_call()?)
        }
        pub fn get_parachutes(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_parachutes_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Control {
        pub(crate) fn get_pitch_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Control_get_Pitch",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_pitch_stream(&self) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_pitch_call()?)
        }
        pub fn get_pitch(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_pitch_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Control {
        pub(crate) fn get_rcs_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Control_get_RCS",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_rcs_stream(&self) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_rcs_call()?)
        }
        pub fn get_rcs(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_rcs_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Control {
        pub(crate) fn get_radiators_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Control_get_Radiators",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_radiators_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_radiators_call()?)
        }
        pub fn get_radiators(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_radiators_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Control {
        pub(crate) fn get_reaction_wheels_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Control_get_ReactionWheels",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_reaction_wheels_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_reaction_wheels_call()?,
            )
        }
        pub fn get_reaction_wheels(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_reaction_wheels_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Control {
        pub(crate) fn get_resource_harvesters_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Control_get_ResourceHarvesters",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_resource_harvesters_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_resource_harvesters_call()?,
            )
        }
        pub fn get_resource_harvesters(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(
                self.get_resource_harvesters_call()?,
            );
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Control {
        pub(crate) fn get_resource_harvesters_active_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Control_get_ResourceHarvestersActive",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_resource_harvesters_active_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_resource_harvesters_active_call()?,
            )
        }
        pub fn get_resource_harvesters_active(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(
                self.get_resource_harvesters_active_call()?,
            );
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Control {
        pub(crate) fn get_right_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Control_get_Right",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_right_stream(&self) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_right_call()?)
        }
        pub fn get_right(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_right_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Control {
        pub(crate) fn get_roll_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Control_get_Roll",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_roll_stream(&self) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_roll_call()?)
        }
        pub fn get_roll(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_roll_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Control {
        pub(crate) fn get_sas_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Control_get_SAS",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_sas_stream(&self) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_sas_call()?)
        }
        pub fn get_sas(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_sas_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Control {
        pub(crate) fn get_sas_mode_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Control_get_SASMode",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_sas_mode_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::SASMode>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_sas_mode_call()?)
        }
        pub fn get_sas_mode(
            &self,
        ) -> Result<crate::services::space_center::SASMode, RpcError> {
            let request = crate::schema::Request::from(self.get_sas_mode_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::SASMode>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Control {
        pub(crate) fn get_solar_panels_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Control_get_SolarPanels",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_solar_panels_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_solar_panels_call()?,
            )
        }
        pub fn get_solar_panels(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_solar_panels_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Control {
        pub(crate) fn get_source_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Control_get_Source",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_source_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::ControlSource>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_source_call()?)
        }
        pub fn get_source(
            &self,
        ) -> Result<crate::services::space_center::ControlSource, RpcError> {
            let request = crate::schema::Request::from(self.get_source_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::ControlSource>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Control {
        pub(crate) fn get_speed_mode_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Control_get_SpeedMode",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_speed_mode_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::SpeedMode>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_speed_mode_call()?)
        }
        pub fn get_speed_mode(
            &self,
        ) -> Result<crate::services::space_center::SpeedMode, RpcError> {
            let request = crate::schema::Request::from(self.get_speed_mode_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::SpeedMode>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Control {
        pub(crate) fn get_stage_lock_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Control_get_StageLock",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_stage_lock_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_stage_lock_call()?)
        }
        pub fn get_stage_lock(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_stage_lock_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Control {
        pub(crate) fn get_state_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Control_get_State",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_state_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::ControlState>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_state_call()?)
        }
        pub fn get_state(
            &self,
        ) -> Result<crate::services::space_center::ControlState, RpcError> {
            let request = crate::schema::Request::from(self.get_state_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::ControlState>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Control {
        pub(crate) fn get_throttle_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Control_get_Throttle",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_throttle_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_throttle_call()?)
        }
        pub fn get_throttle(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_throttle_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Control {
        pub(crate) fn get_up_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Control_get_Up",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_up_stream(&self) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_up_call()?)
        }
        pub fn get_up(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_up_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Control {
        pub(crate) fn get_wheel_steering_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Control_get_WheelSteering",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_wheel_steering_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_wheel_steering_call()?,
            )
        }
        pub fn get_wheel_steering(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_wheel_steering_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Control {
        pub(crate) fn get_wheel_throttle_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Control_get_WheelThrottle",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_wheel_throttle_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_wheel_throttle_call()?,
            )
        }
        pub fn get_wheel_throttle(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_wheel_throttle_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Control {
        pub(crate) fn get_wheels_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Control_get_Wheels",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_wheels_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_wheels_call()?)
        }
        pub fn get_wheels(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_wheels_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Control {
        pub(crate) fn get_yaw_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Control_get_Yaw",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_yaw_stream(&self) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_yaw_call()?)
        }
        pub fn get_yaw(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_yaw_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Control {
        pub(crate) fn set_abort_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Control_set_Abort",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_abort_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.set_abort_call(value)?)
        }
        pub fn set_abort(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_abort_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Control {
        pub(crate) fn set_antennas_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Control_set_Antennas",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_antennas_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_antennas_call(value)?,
            )
        }
        pub fn set_antennas(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_antennas_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Control {
        pub(crate) fn set_brakes_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Control_set_Brakes",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_brakes_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.set_brakes_call(value)?)
        }
        pub fn set_brakes(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_brakes_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Control {
        pub(crate) fn set_cargo_bays_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Control_set_CargoBays",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_cargo_bays_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_cargo_bays_call(value)?,
            )
        }
        pub fn set_cargo_bays(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_cargo_bays_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Control {
        pub(crate) fn set_custom_axis_01_call(
            &self,
            value: f32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Control_set_CustomAxis01",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_custom_axis_01_stream(
            &self,
            value: f32,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_custom_axis_01_call(value)?,
            )
        }
        pub fn set_custom_axis_01(&self, value: f32) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_custom_axis_01_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Control {
        pub(crate) fn set_custom_axis_02_call(
            &self,
            value: f32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Control_set_CustomAxis02",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_custom_axis_02_stream(
            &self,
            value: f32,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_custom_axis_02_call(value)?,
            )
        }
        pub fn set_custom_axis_02(&self, value: f32) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_custom_axis_02_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Control {
        pub(crate) fn set_custom_axis_03_call(
            &self,
            value: f32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Control_set_CustomAxis03",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_custom_axis_03_stream(
            &self,
            value: f32,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_custom_axis_03_call(value)?,
            )
        }
        pub fn set_custom_axis_03(&self, value: f32) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_custom_axis_03_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Control {
        pub(crate) fn set_custom_axis_04_call(
            &self,
            value: f32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Control_set_CustomAxis04",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_custom_axis_04_stream(
            &self,
            value: f32,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_custom_axis_04_call(value)?,
            )
        }
        pub fn set_custom_axis_04(&self, value: f32) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_custom_axis_04_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Control {
        pub(crate) fn set_forward_call(
            &self,
            value: f32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Control_set_Forward",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_forward_stream(
            &self,
            value: f32,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_forward_call(value)?,
            )
        }
        pub fn set_forward(&self, value: f32) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_forward_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Control {
        pub(crate) fn set_gear_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Control_set_Gear",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_gear_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.set_gear_call(value)?)
        }
        pub fn set_gear(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_gear_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Control {
        pub(crate) fn set_input_mode_call(
            &self,
            value: crate::services::space_center::ControlInputMode,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Control_set_InputMode",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_input_mode_stream(
            &self,
            value: crate::services::space_center::ControlInputMode,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_input_mode_call(value)?,
            )
        }
        pub fn set_input_mode(
            &self,
            value: crate::services::space_center::ControlInputMode,
        ) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_input_mode_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Control {
        pub(crate) fn set_intakes_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Control_set_Intakes",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_intakes_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_intakes_call(value)?,
            )
        }
        pub fn set_intakes(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_intakes_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Control {
        pub(crate) fn set_legs_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Control_set_Legs",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_legs_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.set_legs_call(value)?)
        }
        pub fn set_legs(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_legs_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Control {
        pub(crate) fn set_lights_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Control_set_Lights",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_lights_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.set_lights_call(value)?)
        }
        pub fn set_lights(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_lights_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Control {
        pub(crate) fn set_parachutes_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Control_set_Parachutes",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_parachutes_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_parachutes_call(value)?,
            )
        }
        pub fn set_parachutes(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_parachutes_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Control {
        pub(crate) fn set_pitch_call(
            &self,
            value: f32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Control_set_Pitch",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_pitch_stream(
            &self,
            value: f32,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.set_pitch_call(value)?)
        }
        pub fn set_pitch(&self, value: f32) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_pitch_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Control {
        pub(crate) fn set_rcs_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Control_set_RCS",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_rcs_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.set_rcs_call(value)?)
        }
        pub fn set_rcs(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_rcs_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Control {
        pub(crate) fn set_radiators_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Control_set_Radiators",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_radiators_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_radiators_call(value)?,
            )
        }
        pub fn set_radiators(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_radiators_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Control {
        pub(crate) fn set_reaction_wheels_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Control_set_ReactionWheels",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_reaction_wheels_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_reaction_wheels_call(value)?,
            )
        }
        pub fn set_reaction_wheels(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_reaction_wheels_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Control {
        pub(crate) fn set_resource_harvesters_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Control_set_ResourceHarvesters",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_resource_harvesters_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_resource_harvesters_call(value)?,
            )
        }
        pub fn set_resource_harvesters(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_resource_harvesters_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Control {
        pub(crate) fn set_resource_harvesters_active_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Control_set_ResourceHarvestersActive",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_resource_harvesters_active_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_resource_harvesters_active_call(value)?,
            )
        }
        pub fn set_resource_harvesters_active(
            &self,
            value: bool,
        ) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_resource_harvesters_active_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Control {
        pub(crate) fn set_right_call(
            &self,
            value: f32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Control_set_Right",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_right_stream(
            &self,
            value: f32,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.set_right_call(value)?)
        }
        pub fn set_right(&self, value: f32) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_right_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Control {
        pub(crate) fn set_roll_call(
            &self,
            value: f32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Control_set_Roll",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_roll_stream(
            &self,
            value: f32,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.set_roll_call(value)?)
        }
        pub fn set_roll(&self, value: f32) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_roll_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Control {
        pub(crate) fn set_sas_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Control_set_SAS",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_sas_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.set_sas_call(value)?)
        }
        pub fn set_sas(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_sas_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Control {
        pub(crate) fn set_sas_mode_call(
            &self,
            value: crate::services::space_center::SASMode,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Control_set_SASMode",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_sas_mode_stream(
            &self,
            value: crate::services::space_center::SASMode,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_sas_mode_call(value)?,
            )
        }
        pub fn set_sas_mode(
            &self,
            value: crate::services::space_center::SASMode,
        ) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_sas_mode_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Control {
        pub(crate) fn set_solar_panels_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Control_set_SolarPanels",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_solar_panels_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_solar_panels_call(value)?,
            )
        }
        pub fn set_solar_panels(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_solar_panels_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Control {
        pub(crate) fn set_speed_mode_call(
            &self,
            value: crate::services::space_center::SpeedMode,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Control_set_SpeedMode",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_speed_mode_stream(
            &self,
            value: crate::services::space_center::SpeedMode,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_speed_mode_call(value)?,
            )
        }
        pub fn set_speed_mode(
            &self,
            value: crate::services::space_center::SpeedMode,
        ) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_speed_mode_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Control {
        pub(crate) fn set_stage_lock_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Control_set_StageLock",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_stage_lock_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_stage_lock_call(value)?,
            )
        }
        pub fn set_stage_lock(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_stage_lock_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Control {
        pub(crate) fn set_throttle_call(
            &self,
            value: f32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Control_set_Throttle",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_throttle_stream(
            &self,
            value: f32,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_throttle_call(value)?,
            )
        }
        pub fn set_throttle(&self, value: f32) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_throttle_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Control {
        pub(crate) fn set_up_call(
            &self,
            value: f32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Control_set_Up",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_up_stream(
            &self,
            value: f32,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.set_up_call(value)?)
        }
        pub fn set_up(&self, value: f32) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_up_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Control {
        pub(crate) fn set_wheel_steering_call(
            &self,
            value: f32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Control_set_WheelSteering",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_wheel_steering_stream(
            &self,
            value: f32,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_wheel_steering_call(value)?,
            )
        }
        pub fn set_wheel_steering(&self, value: f32) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_wheel_steering_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Control {
        pub(crate) fn set_wheel_throttle_call(
            &self,
            value: f32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Control_set_WheelThrottle",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_wheel_throttle_stream(
            &self,
            value: f32,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_wheel_throttle_call(value)?,
            )
        }
        pub fn set_wheel_throttle(&self, value: f32) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_wheel_throttle_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Control {
        pub(crate) fn set_wheels_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Control_set_Wheels",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_wheels_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.set_wheels_call(value)?)
        }
        pub fn set_wheels(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_wheels_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Control {
        pub(crate) fn set_yaw_call(
            &self,
            value: f32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Control_set_Yaw",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_yaw_stream(
            &self,
            value: f32,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.set_yaw_call(value)?)
        }
        pub fn set_yaw(&self, value: f32) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_yaw_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl SpaceCenter {
        pub(crate) fn create_kerbal_call(
            &self,
            name: String,
            job: String,
            male: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "CreateKerbal",
                    vec![
                        name.to_argument(0usize as u32) ?, job.to_argument(1usize as u32)
                        ?, male.to_argument(2usize as u32) ?
                    ],
                ),
            )
        }
        pub fn create_kerbal_stream(
            &self,
            name: String,
            job: String,
            male: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.create_kerbal_call(name, job, male)?,
            )
        }
        pub fn create_kerbal(
            &self,
            name: String,
            job: String,
            male: bool,
        ) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.create_kerbal_call(name, job, male)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl CrewMember {
        pub(crate) fn get_badass_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "CrewMember_get_Badass",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_badass_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_badass_call()?)
        }
        pub fn get_badass(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_badass_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl CrewMember {
        pub(crate) fn get_career_log_flights_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "CrewMember_get_CareerLogFlights",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_career_log_flights_stream(
            &self,
        ) -> Result<crate::stream::Stream<Vec<i32>>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_career_log_flights_call()?,
            )
        }
        pub fn get_career_log_flights(&self) -> Result<Vec<i32>, RpcError> {
            let request = crate::schema::Request::from(
                self.get_career_log_flights_call()?,
            );
            let response = self.client.call(request)?;
            <Vec<i32>>::from_response(response, self.client.clone())
        }
    }
    impl CrewMember {
        pub(crate) fn get_career_log_targets_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "CrewMember_get_CareerLogTargets",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_career_log_targets_stream(
            &self,
        ) -> Result<crate::stream::Stream<Vec<String>>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_career_log_targets_call()?,
            )
        }
        pub fn get_career_log_targets(&self) -> Result<Vec<String>, RpcError> {
            let request = crate::schema::Request::from(
                self.get_career_log_targets_call()?,
            );
            let response = self.client.call(request)?;
            <Vec<String>>::from_response(response, self.client.clone())
        }
    }
    impl CrewMember {
        pub(crate) fn get_career_log_types_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "CrewMember_get_CareerLogTypes",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_career_log_types_stream(
            &self,
        ) -> Result<crate::stream::Stream<Vec<String>>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_career_log_types_call()?,
            )
        }
        pub fn get_career_log_types(&self) -> Result<Vec<String>, RpcError> {
            let request = crate::schema::Request::from(
                self.get_career_log_types_call()?,
            );
            let response = self.client.call(request)?;
            <Vec<String>>::from_response(response, self.client.clone())
        }
    }
    impl CrewMember {
        pub(crate) fn get_courage_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "CrewMember_get_Courage",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_courage_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_courage_call()?)
        }
        pub fn get_courage(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_courage_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl CrewMember {
        pub(crate) fn get_experience_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "CrewMember_get_Experience",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_experience_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_experience_call()?)
        }
        pub fn get_experience(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_experience_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl CrewMember {
        pub(crate) fn get_gender_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "CrewMember_get_Gender",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_gender_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::CrewMemberGender>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_gender_call()?)
        }
        pub fn get_gender(
            &self,
        ) -> Result<crate::services::space_center::CrewMemberGender, RpcError> {
            let request = crate::schema::Request::from(self.get_gender_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::CrewMemberGender>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl CrewMember {
        pub(crate) fn get_name_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "CrewMember_get_Name",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_name_stream(
            &self,
        ) -> Result<crate::stream::Stream<String>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_name_call()?)
        }
        pub fn get_name(&self) -> Result<String, RpcError> {
            let request = crate::schema::Request::from(self.get_name_call()?);
            let response = self.client.call(request)?;
            <String>::from_response(response, self.client.clone())
        }
    }
    impl CrewMember {
        pub(crate) fn get_on_mission_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "CrewMember_get_OnMission",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_on_mission_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_on_mission_call()?)
        }
        pub fn get_on_mission(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_on_mission_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl CrewMember {
        pub(crate) fn get_roster_status_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "CrewMember_get_RosterStatus",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_roster_status_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::RosterStatus>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_roster_status_call()?,
            )
        }
        pub fn get_roster_status(
            &self,
        ) -> Result<crate::services::space_center::RosterStatus, RpcError> {
            let request = crate::schema::Request::from(self.get_roster_status_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::RosterStatus>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl CrewMember {
        pub(crate) fn get_stupidity_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "CrewMember_get_Stupidity",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_stupidity_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_stupidity_call()?)
        }
        pub fn get_stupidity(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_stupidity_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl CrewMember {
        pub(crate) fn get_suit_type_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "CrewMember_get_SuitType",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_suit_type_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::SuitType>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_suit_type_call()?)
        }
        pub fn get_suit_type(
            &self,
        ) -> Result<crate::services::space_center::SuitType, RpcError> {
            let request = crate::schema::Request::from(self.get_suit_type_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::SuitType>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl CrewMember {
        pub(crate) fn get_trait_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "CrewMember_get_Trait",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_trait_stream(
            &self,
        ) -> Result<crate::stream::Stream<String>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_trait_call()?)
        }
        pub fn get_trait(&self) -> Result<String, RpcError> {
            let request = crate::schema::Request::from(self.get_trait_call()?);
            let response = self.client.call(request)?;
            <String>::from_response(response, self.client.clone())
        }
    }
    impl CrewMember {
        pub(crate) fn get_type_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "CrewMember_get_Type",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_type_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::CrewMemberType>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_type_call()?)
        }
        pub fn get_type(
            &self,
        ) -> Result<crate::services::space_center::CrewMemberType, RpcError> {
            let request = crate::schema::Request::from(self.get_type_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::CrewMemberType>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl CrewMember {
        pub(crate) fn get_veteran_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "CrewMember_get_Veteran",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_veteran_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_veteran_call()?)
        }
        pub fn get_veteran(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_veteran_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl CrewMember {
        pub(crate) fn set_badass_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "CrewMember_set_Badass",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_badass_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.set_badass_call(value)?)
        }
        pub fn set_badass(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_badass_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl CrewMember {
        pub(crate) fn set_courage_call(
            &self,
            value: f32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "CrewMember_set_Courage",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_courage_stream(
            &self,
            value: f32,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_courage_call(value)?,
            )
        }
        pub fn set_courage(&self, value: f32) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_courage_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl CrewMember {
        pub(crate) fn set_experience_call(
            &self,
            value: f32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "CrewMember_set_Experience",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_experience_stream(
            &self,
            value: f32,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_experience_call(value)?,
            )
        }
        pub fn set_experience(&self, value: f32) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_experience_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl CrewMember {
        pub(crate) fn set_name_call(
            &self,
            value: String,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "CrewMember_set_Name",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_name_stream(
            &self,
            value: String,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.set_name_call(value)?)
        }
        pub fn set_name(&self, value: String) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_name_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl CrewMember {
        pub(crate) fn set_stupidity_call(
            &self,
            value: f32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "CrewMember_set_Stupidity",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_stupidity_stream(
            &self,
            value: f32,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_stupidity_call(value)?,
            )
        }
        pub fn set_stupidity(&self, value: f32) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_stupidity_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl CrewMember {
        pub(crate) fn set_suit_type_call(
            &self,
            value: crate::services::space_center::SuitType,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "CrewMember_set_SuitType",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_suit_type_stream(
            &self,
            value: crate::services::space_center::SuitType,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_suit_type_call(value)?,
            )
        }
        pub fn set_suit_type(
            &self,
            value: crate::services::space_center::SuitType,
        ) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_suit_type_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl CrewMember {
        pub(crate) fn set_veteran_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "CrewMember_set_Veteran",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_veteran_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_veteran_call(value)?,
            )
        }
        pub fn set_veteran(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_veteran_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Decoupler {
        pub(crate) fn decouple_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Decoupler_Decouple",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn decouple_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::Vessel>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.decouple_call()?)
        }
        pub fn decouple(
            &self,
        ) -> Result<crate::services::space_center::Vessel, RpcError> {
            let request = crate::schema::Request::from(self.decouple_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::Vessel>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Decoupler {
        pub(crate) fn get_decoupled_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Decoupler_get_Decoupled",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_decoupled_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_decoupled_call()?)
        }
        pub fn get_decoupled(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_decoupled_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Decoupler {
        pub(crate) fn get_impulse_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Decoupler_get_Impulse",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_impulse_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_impulse_call()?)
        }
        pub fn get_impulse(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_impulse_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Decoupler {
        pub(crate) fn get_part_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Decoupler_get_Part",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_part_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::Part>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_part_call()?)
        }
        pub fn get_part(&self) -> Result<crate::services::space_center::Part, RpcError> {
            let request = crate::schema::Request::from(self.get_part_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::Part>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Decoupler {
        pub(crate) fn get_staged_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Decoupler_get_Staged",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_staged_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_staged_call()?)
        }
        pub fn get_staged(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_staged_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl DockingPort {
        pub(crate) fn direction_call(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "DockingPort_Direction",
                    vec![
                        self.to_argument(0usize as u32) ?, reference_frame
                        .to_argument(1usize as u32) ?
                    ],
                ),
            )
        }
        pub fn direction_stream(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::stream::Stream<(f64, f64, f64)>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.direction_call(reference_frame)?,
            )
        }
        pub fn direction(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<(f64, f64, f64), RpcError> {
            let request = crate::schema::Request::from(
                self.direction_call(reference_frame)?,
            );
            let response = self.client.call(request)?;
            <(f64, f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl DockingPort {
        pub(crate) fn position_call(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "DockingPort_Position",
                    vec![
                        self.to_argument(0usize as u32) ?, reference_frame
                        .to_argument(1usize as u32) ?
                    ],
                ),
            )
        }
        pub fn position_stream(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::stream::Stream<(f64, f64, f64)>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.position_call(reference_frame)?,
            )
        }
        pub fn position(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<(f64, f64, f64), RpcError> {
            let request = crate::schema::Request::from(
                self.position_call(reference_frame)?,
            );
            let response = self.client.call(request)?;
            <(f64, f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl DockingPort {
        pub(crate) fn rotation_call(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "DockingPort_Rotation",
                    vec![
                        self.to_argument(0usize as u32) ?, reference_frame
                        .to_argument(1usize as u32) ?
                    ],
                ),
            )
        }
        pub fn rotation_stream(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::stream::Stream<(f64, f64, f64, f64)>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.rotation_call(reference_frame)?,
            )
        }
        pub fn rotation(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<(f64, f64, f64, f64), RpcError> {
            let request = crate::schema::Request::from(
                self.rotation_call(reference_frame)?,
            );
            let response = self.client.call(request)?;
            <(f64, f64, f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl DockingPort {
        pub(crate) fn undock_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "DockingPort_Undock",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn undock_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::Vessel>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.undock_call()?)
        }
        pub fn undock(&self) -> Result<crate::services::space_center::Vessel, RpcError> {
            let request = crate::schema::Request::from(self.undock_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::Vessel>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl DockingPort {
        pub(crate) fn get_can_rotate_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "DockingPort_get_CanRotate",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_can_rotate_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_can_rotate_call()?)
        }
        pub fn get_can_rotate(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_can_rotate_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl DockingPort {
        pub(crate) fn get_docked_part_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "DockingPort_get_DockedPart",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_docked_part_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Option<crate::services::space_center::Part>>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_docked_part_call()?)
        }
        pub fn get_docked_part(
            &self,
        ) -> Result<Option<crate::services::space_center::Part>, RpcError> {
            let request = crate::schema::Request::from(self.get_docked_part_call()?);
            let response = self.client.call(request)?;
            <Option<
                crate::services::space_center::Part,
            >>::from_response(response, self.client.clone())
        }
    }
    impl DockingPort {
        pub(crate) fn get_has_shield_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "DockingPort_get_HasShield",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_has_shield_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_has_shield_call()?)
        }
        pub fn get_has_shield(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_has_shield_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl DockingPort {
        pub(crate) fn get_maximum_rotation_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "DockingPort_get_MaximumRotation",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_maximum_rotation_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_maximum_rotation_call()?,
            )
        }
        pub fn get_maximum_rotation(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(
                self.get_maximum_rotation_call()?,
            );
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl DockingPort {
        pub(crate) fn get_minimum_rotation_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "DockingPort_get_MinimumRotation",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_minimum_rotation_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_minimum_rotation_call()?,
            )
        }
        pub fn get_minimum_rotation(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(
                self.get_minimum_rotation_call()?,
            );
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl DockingPort {
        pub(crate) fn get_part_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "DockingPort_get_Part",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_part_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::Part>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_part_call()?)
        }
        pub fn get_part(&self) -> Result<crate::services::space_center::Part, RpcError> {
            let request = crate::schema::Request::from(self.get_part_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::Part>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl DockingPort {
        pub(crate) fn get_reengage_distance_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "DockingPort_get_ReengageDistance",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_reengage_distance_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_reengage_distance_call()?,
            )
        }
        pub fn get_reengage_distance(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(
                self.get_reengage_distance_call()?,
            );
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl DockingPort {
        pub(crate) fn get_reference_frame_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "DockingPort_get_ReferenceFrame",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_reference_frame_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::ReferenceFrame>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_reference_frame_call()?,
            )
        }
        pub fn get_reference_frame(
            &self,
        ) -> Result<crate::services::space_center::ReferenceFrame, RpcError> {
            let request = crate::schema::Request::from(self.get_reference_frame_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::ReferenceFrame>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl DockingPort {
        pub(crate) fn get_rotation_locked_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "DockingPort_get_RotationLocked",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_rotation_locked_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_rotation_locked_call()?,
            )
        }
        pub fn get_rotation_locked(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_rotation_locked_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl DockingPort {
        pub(crate) fn get_rotation_target_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "DockingPort_get_RotationTarget",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_rotation_target_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_rotation_target_call()?,
            )
        }
        pub fn get_rotation_target(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_rotation_target_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl DockingPort {
        pub(crate) fn get_shielded_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "DockingPort_get_Shielded",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_shielded_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_shielded_call()?)
        }
        pub fn get_shielded(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_shielded_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl DockingPort {
        pub(crate) fn get_state_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "DockingPort_get_State",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_state_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::DockingPortState>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_state_call()?)
        }
        pub fn get_state(
            &self,
        ) -> Result<crate::services::space_center::DockingPortState, RpcError> {
            let request = crate::schema::Request::from(self.get_state_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::DockingPortState>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl DockingPort {
        pub(crate) fn set_rotation_locked_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "DockingPort_set_RotationLocked",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_rotation_locked_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_rotation_locked_call(value)?,
            )
        }
        pub fn set_rotation_locked(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_rotation_locked_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl DockingPort {
        pub(crate) fn set_rotation_target_call(
            &self,
            value: f32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "DockingPort_set_RotationTarget",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_rotation_target_stream(
            &self,
            value: f32,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_rotation_target_call(value)?,
            )
        }
        pub fn set_rotation_target(&self, value: f32) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_rotation_target_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl DockingPort {
        pub(crate) fn set_shielded_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "DockingPort_set_Shielded",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_shielded_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_shielded_call(value)?,
            )
        }
        pub fn set_shielded(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_shielded_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Engine {
        pub(crate) fn available_thrust_at_call(
            &self,
            pressure: f64,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Engine_AvailableThrustAt",
                    vec![
                        self.to_argument(0usize as u32) ?, pressure.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn available_thrust_at_stream(
            &self,
            pressure: f64,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.available_thrust_at_call(pressure)?,
            )
        }
        pub fn available_thrust_at(&self, pressure: f64) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(
                self.available_thrust_at_call(pressure)?,
            );
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Engine {
        pub(crate) fn max_thrust_at_call(
            &self,
            pressure: f64,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Engine_MaxThrustAt",
                    vec![
                        self.to_argument(0usize as u32) ?, pressure.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn max_thrust_at_stream(
            &self,
            pressure: f64,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.max_thrust_at_call(pressure)?,
            )
        }
        pub fn max_thrust_at(&self, pressure: f64) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(
                self.max_thrust_at_call(pressure)?,
            );
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Engine {
        pub(crate) fn specific_impulse_at_call(
            &self,
            pressure: f64,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Engine_SpecificImpulseAt",
                    vec![
                        self.to_argument(0usize as u32) ?, pressure.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn specific_impulse_at_stream(
            &self,
            pressure: f64,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.specific_impulse_at_call(pressure)?,
            )
        }
        pub fn specific_impulse_at(&self, pressure: f64) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(
                self.specific_impulse_at_call(pressure)?,
            );
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Engine {
        pub(crate) fn toggle_mode_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Engine_ToggleMode",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn toggle_mode_stream(&self) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.toggle_mode_call()?)
        }
        pub fn toggle_mode(&self) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.toggle_mode_call()?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Engine {
        pub(crate) fn get_active_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Engine_get_Active",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_active_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_active_call()?)
        }
        pub fn get_active(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_active_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Engine {
        pub(crate) fn get_auto_mode_switch_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Engine_get_AutoModeSwitch",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_auto_mode_switch_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_auto_mode_switch_call()?,
            )
        }
        pub fn get_auto_mode_switch(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(
                self.get_auto_mode_switch_call()?,
            );
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Engine {
        pub(crate) fn get_available_thrust_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Engine_get_AvailableThrust",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_available_thrust_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_available_thrust_call()?,
            )
        }
        pub fn get_available_thrust(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(
                self.get_available_thrust_call()?,
            );
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Engine {
        pub(crate) fn get_available_torque_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Engine_get_AvailableTorque",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_available_torque_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<((f64, f64, f64), (f64, f64, f64))>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_available_torque_call()?,
            )
        }
        pub fn get_available_torque(
            &self,
        ) -> Result<((f64, f64, f64), (f64, f64, f64)), RpcError> {
            let request = crate::schema::Request::from(
                self.get_available_torque_call()?,
            );
            let response = self.client.call(request)?;
            <(
                (f64, f64, f64),
                (f64, f64, f64),
            )>::from_response(response, self.client.clone())
        }
    }
    impl Engine {
        pub(crate) fn get_can_restart_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Engine_get_CanRestart",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_can_restart_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_can_restart_call()?)
        }
        pub fn get_can_restart(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_can_restart_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Engine {
        pub(crate) fn get_can_shutdown_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Engine_get_CanShutdown",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_can_shutdown_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_can_shutdown_call()?,
            )
        }
        pub fn get_can_shutdown(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_can_shutdown_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Engine {
        pub(crate) fn get_gimbal_limit_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Engine_get_GimbalLimit",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_gimbal_limit_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_gimbal_limit_call()?,
            )
        }
        pub fn get_gimbal_limit(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_gimbal_limit_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Engine {
        pub(crate) fn get_gimbal_locked_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Engine_get_GimbalLocked",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_gimbal_locked_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_gimbal_locked_call()?,
            )
        }
        pub fn get_gimbal_locked(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_gimbal_locked_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Engine {
        pub(crate) fn get_gimbal_range_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Engine_get_GimbalRange",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_gimbal_range_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_gimbal_range_call()?,
            )
        }
        pub fn get_gimbal_range(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_gimbal_range_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Engine {
        pub(crate) fn get_gimballed_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Engine_get_Gimballed",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_gimballed_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_gimballed_call()?)
        }
        pub fn get_gimballed(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_gimballed_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Engine {
        pub(crate) fn get_has_fuel_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Engine_get_HasFuel",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_has_fuel_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_has_fuel_call()?)
        }
        pub fn get_has_fuel(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_has_fuel_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Engine {
        pub(crate) fn get_has_modes_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Engine_get_HasModes",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_has_modes_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_has_modes_call()?)
        }
        pub fn get_has_modes(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_has_modes_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Engine {
        pub(crate) fn get_independent_throttle_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Engine_get_IndependentThrottle",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_independent_throttle_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_independent_throttle_call()?,
            )
        }
        pub fn get_independent_throttle(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(
                self.get_independent_throttle_call()?,
            );
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Engine {
        pub(crate) fn get_kerbin_sea_level_specific_impulse_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Engine_get_KerbinSeaLevelSpecificImpulse",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_kerbin_sea_level_specific_impulse_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_kerbin_sea_level_specific_impulse_call()?,
            )
        }
        pub fn get_kerbin_sea_level_specific_impulse(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(
                self.get_kerbin_sea_level_specific_impulse_call()?,
            );
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Engine {
        pub(crate) fn get_max_thrust_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Engine_get_MaxThrust",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_max_thrust_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_max_thrust_call()?)
        }
        pub fn get_max_thrust(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_max_thrust_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Engine {
        pub(crate) fn get_max_vacuum_thrust_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Engine_get_MaxVacuumThrust",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_max_vacuum_thrust_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_max_vacuum_thrust_call()?,
            )
        }
        pub fn get_max_vacuum_thrust(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(
                self.get_max_vacuum_thrust_call()?,
            );
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Engine {
        pub(crate) fn get_mode_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Engine_get_Mode",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_mode_stream(
            &self,
        ) -> Result<crate::stream::Stream<String>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_mode_call()?)
        }
        pub fn get_mode(&self) -> Result<String, RpcError> {
            let request = crate::schema::Request::from(self.get_mode_call()?);
            let response = self.client.call(request)?;
            <String>::from_response(response, self.client.clone())
        }
    }
    impl Engine {
        pub(crate) fn get_modes_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Engine_get_Modes",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_modes_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<
                std::collections::HashMap<String, crate::services::space_center::Engine>,
            >,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_modes_call()?)
        }
        pub fn get_modes(
            &self,
        ) -> Result<
            std::collections::HashMap<String, crate::services::space_center::Engine>,
            RpcError,
        > {
            let request = crate::schema::Request::from(self.get_modes_call()?);
            let response = self.client.call(request)?;
            <std::collections::HashMap<
                String,
                crate::services::space_center::Engine,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Engine {
        pub(crate) fn get_part_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Engine_get_Part",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_part_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::Part>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_part_call()?)
        }
        pub fn get_part(&self) -> Result<crate::services::space_center::Part, RpcError> {
            let request = crate::schema::Request::from(self.get_part_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::Part>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Engine {
        pub(crate) fn get_propellant_names_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Engine_get_PropellantNames",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_propellant_names_stream(
            &self,
        ) -> Result<crate::stream::Stream<Vec<String>>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_propellant_names_call()?,
            )
        }
        pub fn get_propellant_names(&self) -> Result<Vec<String>, RpcError> {
            let request = crate::schema::Request::from(
                self.get_propellant_names_call()?,
            );
            let response = self.client.call(request)?;
            <Vec<String>>::from_response(response, self.client.clone())
        }
    }
    impl Engine {
        pub(crate) fn get_propellant_ratios_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Engine_get_PropellantRatios",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_propellant_ratios_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<std::collections::HashMap<String, f32>>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_propellant_ratios_call()?,
            )
        }
        pub fn get_propellant_ratios(
            &self,
        ) -> Result<std::collections::HashMap<String, f32>, RpcError> {
            let request = crate::schema::Request::from(
                self.get_propellant_ratios_call()?,
            );
            let response = self.client.call(request)?;
            <std::collections::HashMap<
                String,
                f32,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Engine {
        pub(crate) fn get_propellants_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Engine_get_Propellants",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_propellants_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Vec<crate::services::space_center::Propellant>>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_propellants_call()?)
        }
        pub fn get_propellants(
            &self,
        ) -> Result<Vec<crate::services::space_center::Propellant>, RpcError> {
            let request = crate::schema::Request::from(self.get_propellants_call()?);
            let response = self.client.call(request)?;
            <Vec<
                crate::services::space_center::Propellant,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Engine {
        pub(crate) fn get_specific_impulse_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Engine_get_SpecificImpulse",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_specific_impulse_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_specific_impulse_call()?,
            )
        }
        pub fn get_specific_impulse(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(
                self.get_specific_impulse_call()?,
            );
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Engine {
        pub(crate) fn get_throttle_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Engine_get_Throttle",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_throttle_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_throttle_call()?)
        }
        pub fn get_throttle(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_throttle_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Engine {
        pub(crate) fn get_throttle_locked_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Engine_get_ThrottleLocked",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_throttle_locked_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_throttle_locked_call()?,
            )
        }
        pub fn get_throttle_locked(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_throttle_locked_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Engine {
        pub(crate) fn get_thrust_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Engine_get_Thrust",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_thrust_stream(&self) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_thrust_call()?)
        }
        pub fn get_thrust(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_thrust_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Engine {
        pub(crate) fn get_thrust_limit_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Engine_get_ThrustLimit",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_thrust_limit_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_thrust_limit_call()?,
            )
        }
        pub fn get_thrust_limit(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_thrust_limit_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Engine {
        pub(crate) fn get_thrusters_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Engine_get_Thrusters",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_thrusters_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Vec<crate::services::space_center::Thruster>>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_thrusters_call()?)
        }
        pub fn get_thrusters(
            &self,
        ) -> Result<Vec<crate::services::space_center::Thruster>, RpcError> {
            let request = crate::schema::Request::from(self.get_thrusters_call()?);
            let response = self.client.call(request)?;
            <Vec<
                crate::services::space_center::Thruster,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Engine {
        pub(crate) fn get_vacuum_specific_impulse_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Engine_get_VacuumSpecificImpulse",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_vacuum_specific_impulse_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_vacuum_specific_impulse_call()?,
            )
        }
        pub fn get_vacuum_specific_impulse(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(
                self.get_vacuum_specific_impulse_call()?,
            );
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Engine {
        pub(crate) fn set_active_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Engine_set_Active",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_active_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.set_active_call(value)?)
        }
        pub fn set_active(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_active_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Engine {
        pub(crate) fn set_auto_mode_switch_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Engine_set_AutoModeSwitch",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_auto_mode_switch_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_auto_mode_switch_call(value)?,
            )
        }
        pub fn set_auto_mode_switch(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_auto_mode_switch_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Engine {
        pub(crate) fn set_gimbal_limit_call(
            &self,
            value: f32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Engine_set_GimbalLimit",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_gimbal_limit_stream(
            &self,
            value: f32,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_gimbal_limit_call(value)?,
            )
        }
        pub fn set_gimbal_limit(&self, value: f32) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_gimbal_limit_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Engine {
        pub(crate) fn set_gimbal_locked_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Engine_set_GimbalLocked",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_gimbal_locked_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_gimbal_locked_call(value)?,
            )
        }
        pub fn set_gimbal_locked(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_gimbal_locked_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Engine {
        pub(crate) fn set_independent_throttle_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Engine_set_IndependentThrottle",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_independent_throttle_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_independent_throttle_call(value)?,
            )
        }
        pub fn set_independent_throttle(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_independent_throttle_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Engine {
        pub(crate) fn set_mode_call(
            &self,
            value: String,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Engine_set_Mode",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_mode_stream(
            &self,
            value: String,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.set_mode_call(value)?)
        }
        pub fn set_mode(&self, value: String) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_mode_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Engine {
        pub(crate) fn set_throttle_call(
            &self,
            value: f32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Engine_set_Throttle",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_throttle_stream(
            &self,
            value: f32,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_throttle_call(value)?,
            )
        }
        pub fn set_throttle(&self, value: f32) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_throttle_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Engine {
        pub(crate) fn set_thrust_limit_call(
            &self,
            value: f32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Engine_set_ThrustLimit",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_thrust_limit_stream(
            &self,
            value: f32,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_thrust_limit_call(value)?,
            )
        }
        pub fn set_thrust_limit(&self, value: f32) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_thrust_limit_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Experiment {
        pub(crate) fn dump_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Experiment_Dump",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn dump_stream(&self) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.dump_call()?)
        }
        pub fn dump(&self) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.dump_call()?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Experiment {
        pub(crate) fn reset_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Experiment_Reset",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn reset_stream(&self) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.reset_call()?)
        }
        pub fn reset(&self) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.reset_call()?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Experiment {
        pub(crate) fn run_call(&self) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Experiment_Run",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn run_stream(&self) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.run_call()?)
        }
        pub fn run(&self) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.run_call()?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Experiment {
        pub(crate) fn transmit_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Experiment_Transmit",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn transmit_stream(&self) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.transmit_call()?)
        }
        pub fn transmit(&self) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.transmit_call()?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Experiment {
        pub(crate) fn get_available_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Experiment_get_Available",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_available_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_available_call()?)
        }
        pub fn get_available(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_available_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Experiment {
        pub(crate) fn get_biome_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Experiment_get_Biome",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_biome_stream(
            &self,
        ) -> Result<crate::stream::Stream<String>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_biome_call()?)
        }
        pub fn get_biome(&self) -> Result<String, RpcError> {
            let request = crate::schema::Request::from(self.get_biome_call()?);
            let response = self.client.call(request)?;
            <String>::from_response(response, self.client.clone())
        }
    }
    impl Experiment {
        pub(crate) fn get_data_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Experiment_get_Data",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_data_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Vec<crate::services::space_center::ScienceData>>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_data_call()?)
        }
        pub fn get_data(
            &self,
        ) -> Result<Vec<crate::services::space_center::ScienceData>, RpcError> {
            let request = crate::schema::Request::from(self.get_data_call()?);
            let response = self.client.call(request)?;
            <Vec<
                crate::services::space_center::ScienceData,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Experiment {
        pub(crate) fn get_deployed_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Experiment_get_Deployed",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_deployed_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_deployed_call()?)
        }
        pub fn get_deployed(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_deployed_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Experiment {
        pub(crate) fn get_has_data_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Experiment_get_HasData",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_has_data_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_has_data_call()?)
        }
        pub fn get_has_data(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_has_data_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Experiment {
        pub(crate) fn get_inoperable_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Experiment_get_Inoperable",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_inoperable_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_inoperable_call()?)
        }
        pub fn get_inoperable(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_inoperable_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Experiment {
        pub(crate) fn get_name_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Experiment_get_Name",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_name_stream(
            &self,
        ) -> Result<crate::stream::Stream<String>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_name_call()?)
        }
        pub fn get_name(&self) -> Result<String, RpcError> {
            let request = crate::schema::Request::from(self.get_name_call()?);
            let response = self.client.call(request)?;
            <String>::from_response(response, self.client.clone())
        }
    }
    impl Experiment {
        pub(crate) fn get_part_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Experiment_get_Part",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_part_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::Part>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_part_call()?)
        }
        pub fn get_part(&self) -> Result<crate::services::space_center::Part, RpcError> {
            let request = crate::schema::Request::from(self.get_part_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::Part>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Experiment {
        pub(crate) fn get_rerunnable_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Experiment_get_Rerunnable",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_rerunnable_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_rerunnable_call()?)
        }
        pub fn get_rerunnable(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_rerunnable_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Experiment {
        pub(crate) fn get_science_subject_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Experiment_get_ScienceSubject",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_science_subject_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::ScienceSubject>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_science_subject_call()?,
            )
        }
        pub fn get_science_subject(
            &self,
        ) -> Result<crate::services::space_center::ScienceSubject, RpcError> {
            let request = crate::schema::Request::from(self.get_science_subject_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::ScienceSubject>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Experiment {
        pub(crate) fn get_title_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Experiment_get_Title",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_title_stream(
            &self,
        ) -> Result<crate::stream::Stream<String>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_title_call()?)
        }
        pub fn get_title(&self) -> Result<String, RpcError> {
            let request = crate::schema::Request::from(self.get_title_call()?);
            let response = self.client.call(request)?;
            <String>::from_response(response, self.client.clone())
        }
    }
    impl Fairing {
        pub(crate) fn jettison_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Fairing_Jettison",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn jettison_stream(&self) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.jettison_call()?)
        }
        pub fn jettison(&self) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.jettison_call()?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Fairing {
        pub(crate) fn get_jettisoned_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Fairing_get_Jettisoned",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_jettisoned_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_jettisoned_call()?)
        }
        pub fn get_jettisoned(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_jettisoned_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Fairing {
        pub(crate) fn get_part_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Fairing_get_Part",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_part_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::Part>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_part_call()?)
        }
        pub fn get_part(&self) -> Result<crate::services::space_center::Part, RpcError> {
            let request = crate::schema::Request::from(self.get_part_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::Part>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Flight {
        pub(crate) fn simulate_aerodynamic_force_at_call(
            &self,
            body: &crate::services::space_center::CelestialBody,
            position: (f64, f64, f64),
            velocity: (f64, f64, f64),
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Flight_SimulateAerodynamicForceAt",
                    vec![
                        self.to_argument(0usize as u32) ?, body.to_argument(1usize as
                        u32) ?, position.to_argument(2usize as u32) ?, velocity
                        .to_argument(3usize as u32) ?
                    ],
                ),
            )
        }
        pub fn simulate_aerodynamic_force_at_stream(
            &self,
            body: &crate::services::space_center::CelestialBody,
            position: (f64, f64, f64),
            velocity: (f64, f64, f64),
        ) -> Result<crate::stream::Stream<(f64, f64, f64)>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.simulate_aerodynamic_force_at_call(body, position, velocity)?,
            )
        }
        pub fn simulate_aerodynamic_force_at(
            &self,
            body: &crate::services::space_center::CelestialBody,
            position: (f64, f64, f64),
            velocity: (f64, f64, f64),
        ) -> Result<(f64, f64, f64), RpcError> {
            let request = crate::schema::Request::from(
                self.simulate_aerodynamic_force_at_call(body, position, velocity)?,
            );
            let response = self.client.call(request)?;
            <(f64, f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl Flight {
        pub(crate) fn get_aerodynamic_force_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Flight_get_AerodynamicForce",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_aerodynamic_force_stream(
            &self,
        ) -> Result<crate::stream::Stream<(f64, f64, f64)>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_aerodynamic_force_call()?,
            )
        }
        pub fn get_aerodynamic_force(&self) -> Result<(f64, f64, f64), RpcError> {
            let request = crate::schema::Request::from(
                self.get_aerodynamic_force_call()?,
            );
            let response = self.client.call(request)?;
            <(f64, f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl Flight {
        pub(crate) fn get_angle_of_attack_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Flight_get_AngleOfAttack",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_angle_of_attack_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_angle_of_attack_call()?,
            )
        }
        pub fn get_angle_of_attack(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_angle_of_attack_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Flight {
        pub(crate) fn get_anti_normal_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Flight_get_AntiNormal",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_anti_normal_stream(
            &self,
        ) -> Result<crate::stream::Stream<(f64, f64, f64)>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_anti_normal_call()?)
        }
        pub fn get_anti_normal(&self) -> Result<(f64, f64, f64), RpcError> {
            let request = crate::schema::Request::from(self.get_anti_normal_call()?);
            let response = self.client.call(request)?;
            <(f64, f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl Flight {
        pub(crate) fn get_anti_radial_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Flight_get_AntiRadial",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_anti_radial_stream(
            &self,
        ) -> Result<crate::stream::Stream<(f64, f64, f64)>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_anti_radial_call()?)
        }
        pub fn get_anti_radial(&self) -> Result<(f64, f64, f64), RpcError> {
            let request = crate::schema::Request::from(self.get_anti_radial_call()?);
            let response = self.client.call(request)?;
            <(f64, f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl Flight {
        pub(crate) fn get_atmosphere_density_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Flight_get_AtmosphereDensity",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_atmosphere_density_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_atmosphere_density_call()?,
            )
        }
        pub fn get_atmosphere_density(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(
                self.get_atmosphere_density_call()?,
            );
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Flight {
        pub(crate) fn get_ballistic_coefficient_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Flight_get_BallisticCoefficient",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_ballistic_coefficient_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_ballistic_coefficient_call()?,
            )
        }
        pub fn get_ballistic_coefficient(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(
                self.get_ballistic_coefficient_call()?,
            );
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Flight {
        pub(crate) fn get_bedrock_altitude_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Flight_get_BedrockAltitude",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_bedrock_altitude_stream(
            &self,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_bedrock_altitude_call()?,
            )
        }
        pub fn get_bedrock_altitude(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(
                self.get_bedrock_altitude_call()?,
            );
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Flight {
        pub(crate) fn get_center_of_mass_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Flight_get_CenterOfMass",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_center_of_mass_stream(
            &self,
        ) -> Result<crate::stream::Stream<(f64, f64, f64)>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_center_of_mass_call()?,
            )
        }
        pub fn get_center_of_mass(&self) -> Result<(f64, f64, f64), RpcError> {
            let request = crate::schema::Request::from(self.get_center_of_mass_call()?);
            let response = self.client.call(request)?;
            <(f64, f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl Flight {
        pub(crate) fn get_direction_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Flight_get_Direction",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_direction_stream(
            &self,
        ) -> Result<crate::stream::Stream<(f64, f64, f64)>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_direction_call()?)
        }
        pub fn get_direction(&self) -> Result<(f64, f64, f64), RpcError> {
            let request = crate::schema::Request::from(self.get_direction_call()?);
            let response = self.client.call(request)?;
            <(f64, f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl Flight {
        pub(crate) fn get_drag_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Flight_get_Drag",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_drag_stream(
            &self,
        ) -> Result<crate::stream::Stream<(f64, f64, f64)>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_drag_call()?)
        }
        pub fn get_drag(&self) -> Result<(f64, f64, f64), RpcError> {
            let request = crate::schema::Request::from(self.get_drag_call()?);
            let response = self.client.call(request)?;
            <(f64, f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl Flight {
        pub(crate) fn get_drag_coefficient_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Flight_get_DragCoefficient",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_drag_coefficient_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_drag_coefficient_call()?,
            )
        }
        pub fn get_drag_coefficient(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(
                self.get_drag_coefficient_call()?,
            );
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Flight {
        pub(crate) fn get_dynamic_pressure_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Flight_get_DynamicPressure",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_dynamic_pressure_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_dynamic_pressure_call()?,
            )
        }
        pub fn get_dynamic_pressure(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(
                self.get_dynamic_pressure_call()?,
            );
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Flight {
        pub(crate) fn get_elevation_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Flight_get_Elevation",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_elevation_stream(
            &self,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_elevation_call()?)
        }
        pub fn get_elevation(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(self.get_elevation_call()?);
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Flight {
        pub(crate) fn get_equivalent_air_speed_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Flight_get_EquivalentAirSpeed",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_equivalent_air_speed_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_equivalent_air_speed_call()?,
            )
        }
        pub fn get_equivalent_air_speed(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(
                self.get_equivalent_air_speed_call()?,
            );
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Flight {
        pub(crate) fn get_g_force_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Flight_get_GForce",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_g_force_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_g_force_call()?)
        }
        pub fn get_g_force(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_g_force_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Flight {
        pub(crate) fn get_heading_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Flight_get_Heading",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_heading_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_heading_call()?)
        }
        pub fn get_heading(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_heading_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Flight {
        pub(crate) fn get_horizontal_speed_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Flight_get_HorizontalSpeed",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_horizontal_speed_stream(
            &self,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_horizontal_speed_call()?,
            )
        }
        pub fn get_horizontal_speed(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(
                self.get_horizontal_speed_call()?,
            );
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Flight {
        pub(crate) fn get_latitude_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Flight_get_Latitude",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_latitude_stream(
            &self,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_latitude_call()?)
        }
        pub fn get_latitude(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(self.get_latitude_call()?);
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Flight {
        pub(crate) fn get_lift_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Flight_get_Lift",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_lift_stream(
            &self,
        ) -> Result<crate::stream::Stream<(f64, f64, f64)>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_lift_call()?)
        }
        pub fn get_lift(&self) -> Result<(f64, f64, f64), RpcError> {
            let request = crate::schema::Request::from(self.get_lift_call()?);
            let response = self.client.call(request)?;
            <(f64, f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl Flight {
        pub(crate) fn get_lift_coefficient_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Flight_get_LiftCoefficient",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_lift_coefficient_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_lift_coefficient_call()?,
            )
        }
        pub fn get_lift_coefficient(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(
                self.get_lift_coefficient_call()?,
            );
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Flight {
        pub(crate) fn get_longitude_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Flight_get_Longitude",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_longitude_stream(
            &self,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_longitude_call()?)
        }
        pub fn get_longitude(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(self.get_longitude_call()?);
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Flight {
        pub(crate) fn get_mach_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Flight_get_Mach",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_mach_stream(&self) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_mach_call()?)
        }
        pub fn get_mach(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_mach_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Flight {
        pub(crate) fn get_mean_altitude_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Flight_get_MeanAltitude",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_mean_altitude_stream(
            &self,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_mean_altitude_call()?,
            )
        }
        pub fn get_mean_altitude(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(self.get_mean_altitude_call()?);
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Flight {
        pub(crate) fn get_normal_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Flight_get_Normal",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_normal_stream(
            &self,
        ) -> Result<crate::stream::Stream<(f64, f64, f64)>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_normal_call()?)
        }
        pub fn get_normal(&self) -> Result<(f64, f64, f64), RpcError> {
            let request = crate::schema::Request::from(self.get_normal_call()?);
            let response = self.client.call(request)?;
            <(f64, f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl Flight {
        pub(crate) fn get_pitch_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Flight_get_Pitch",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_pitch_stream(&self) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_pitch_call()?)
        }
        pub fn get_pitch(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_pitch_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Flight {
        pub(crate) fn get_prograde_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Flight_get_Prograde",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_prograde_stream(
            &self,
        ) -> Result<crate::stream::Stream<(f64, f64, f64)>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_prograde_call()?)
        }
        pub fn get_prograde(&self) -> Result<(f64, f64, f64), RpcError> {
            let request = crate::schema::Request::from(self.get_prograde_call()?);
            let response = self.client.call(request)?;
            <(f64, f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl Flight {
        pub(crate) fn get_radial_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Flight_get_Radial",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_radial_stream(
            &self,
        ) -> Result<crate::stream::Stream<(f64, f64, f64)>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_radial_call()?)
        }
        pub fn get_radial(&self) -> Result<(f64, f64, f64), RpcError> {
            let request = crate::schema::Request::from(self.get_radial_call()?);
            let response = self.client.call(request)?;
            <(f64, f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl Flight {
        pub(crate) fn get_retrograde_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Flight_get_Retrograde",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_retrograde_stream(
            &self,
        ) -> Result<crate::stream::Stream<(f64, f64, f64)>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_retrograde_call()?)
        }
        pub fn get_retrograde(&self) -> Result<(f64, f64, f64), RpcError> {
            let request = crate::schema::Request::from(self.get_retrograde_call()?);
            let response = self.client.call(request)?;
            <(f64, f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl Flight {
        pub(crate) fn get_reynolds_number_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Flight_get_ReynoldsNumber",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_reynolds_number_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_reynolds_number_call()?,
            )
        }
        pub fn get_reynolds_number(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_reynolds_number_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Flight {
        pub(crate) fn get_roll_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Flight_get_Roll",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_roll_stream(&self) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_roll_call()?)
        }
        pub fn get_roll(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_roll_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Flight {
        pub(crate) fn get_rotation_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Flight_get_Rotation",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_rotation_stream(
            &self,
        ) -> Result<crate::stream::Stream<(f64, f64, f64, f64)>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_rotation_call()?)
        }
        pub fn get_rotation(&self) -> Result<(f64, f64, f64, f64), RpcError> {
            let request = crate::schema::Request::from(self.get_rotation_call()?);
            let response = self.client.call(request)?;
            <(f64, f64, f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl Flight {
        pub(crate) fn get_sideslip_angle_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Flight_get_SideslipAngle",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_sideslip_angle_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_sideslip_angle_call()?,
            )
        }
        pub fn get_sideslip_angle(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_sideslip_angle_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Flight {
        pub(crate) fn get_speed_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Flight_get_Speed",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_speed_stream(&self) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_speed_call()?)
        }
        pub fn get_speed(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(self.get_speed_call()?);
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Flight {
        pub(crate) fn get_speed_of_sound_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Flight_get_SpeedOfSound",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_speed_of_sound_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_speed_of_sound_call()?,
            )
        }
        pub fn get_speed_of_sound(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_speed_of_sound_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Flight {
        pub(crate) fn get_stall_fraction_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Flight_get_StallFraction",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_stall_fraction_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_stall_fraction_call()?,
            )
        }
        pub fn get_stall_fraction(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_stall_fraction_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Flight {
        pub(crate) fn get_static_air_temperature_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Flight_get_StaticAirTemperature",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_static_air_temperature_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_static_air_temperature_call()?,
            )
        }
        pub fn get_static_air_temperature(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(
                self.get_static_air_temperature_call()?,
            );
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Flight {
        pub(crate) fn get_static_pressure_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Flight_get_StaticPressure",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_static_pressure_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_static_pressure_call()?,
            )
        }
        pub fn get_static_pressure(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_static_pressure_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Flight {
        pub(crate) fn get_static_pressure_at_msl_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Flight_get_StaticPressureAtMSL",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_static_pressure_at_msl_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_static_pressure_at_msl_call()?,
            )
        }
        pub fn get_static_pressure_at_msl(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(
                self.get_static_pressure_at_msl_call()?,
            );
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Flight {
        pub(crate) fn get_surface_altitude_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Flight_get_SurfaceAltitude",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_surface_altitude_stream(
            &self,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_surface_altitude_call()?,
            )
        }
        pub fn get_surface_altitude(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(
                self.get_surface_altitude_call()?,
            );
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Flight {
        pub(crate) fn get_terminal_velocity_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Flight_get_TerminalVelocity",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_terminal_velocity_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_terminal_velocity_call()?,
            )
        }
        pub fn get_terminal_velocity(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(
                self.get_terminal_velocity_call()?,
            );
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Flight {
        pub(crate) fn get_thrust_specific_fuel_consumption_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Flight_get_ThrustSpecificFuelConsumption",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_thrust_specific_fuel_consumption_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_thrust_specific_fuel_consumption_call()?,
            )
        }
        pub fn get_thrust_specific_fuel_consumption(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(
                self.get_thrust_specific_fuel_consumption_call()?,
            );
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Flight {
        pub(crate) fn get_total_air_temperature_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Flight_get_TotalAirTemperature",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_total_air_temperature_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_total_air_temperature_call()?,
            )
        }
        pub fn get_total_air_temperature(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(
                self.get_total_air_temperature_call()?,
            );
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Flight {
        pub(crate) fn get_true_air_speed_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Flight_get_TrueAirSpeed",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_true_air_speed_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_true_air_speed_call()?,
            )
        }
        pub fn get_true_air_speed(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_true_air_speed_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Flight {
        pub(crate) fn get_velocity_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Flight_get_Velocity",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_velocity_stream(
            &self,
        ) -> Result<crate::stream::Stream<(f64, f64, f64)>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_velocity_call()?)
        }
        pub fn get_velocity(&self) -> Result<(f64, f64, f64), RpcError> {
            let request = crate::schema::Request::from(self.get_velocity_call()?);
            let response = self.client.call(request)?;
            <(f64, f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl Flight {
        pub(crate) fn get_vertical_speed_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Flight_get_VerticalSpeed",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_vertical_speed_stream(
            &self,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_vertical_speed_call()?,
            )
        }
        pub fn get_vertical_speed(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(self.get_vertical_speed_call()?);
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Force {
        pub(crate) fn remove_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Force_Remove",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn remove_stream(&self) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.remove_call()?)
        }
        pub fn remove(&self) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.remove_call()?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Force {
        pub(crate) fn get_force_vector_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Force_get_ForceVector",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_force_vector_stream(
            &self,
        ) -> Result<crate::stream::Stream<(f64, f64, f64)>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_force_vector_call()?,
            )
        }
        pub fn get_force_vector(&self) -> Result<(f64, f64, f64), RpcError> {
            let request = crate::schema::Request::from(self.get_force_vector_call()?);
            let response = self.client.call(request)?;
            <(f64, f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl Force {
        pub(crate) fn get_part_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Force_get_Part",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_part_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::Part>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_part_call()?)
        }
        pub fn get_part(&self) -> Result<crate::services::space_center::Part, RpcError> {
            let request = crate::schema::Request::from(self.get_part_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::Part>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Force {
        pub(crate) fn get_position_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Force_get_Position",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_position_stream(
            &self,
        ) -> Result<crate::stream::Stream<(f64, f64, f64)>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_position_call()?)
        }
        pub fn get_position(&self) -> Result<(f64, f64, f64), RpcError> {
            let request = crate::schema::Request::from(self.get_position_call()?);
            let response = self.client.call(request)?;
            <(f64, f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl Force {
        pub(crate) fn get_reference_frame_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Force_get_ReferenceFrame",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_reference_frame_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::ReferenceFrame>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_reference_frame_call()?,
            )
        }
        pub fn get_reference_frame(
            &self,
        ) -> Result<crate::services::space_center::ReferenceFrame, RpcError> {
            let request = crate::schema::Request::from(self.get_reference_frame_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::ReferenceFrame>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Force {
        pub(crate) fn set_force_vector_call(
            &self,
            value: (f64, f64, f64),
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Force_set_ForceVector",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_force_vector_stream(
            &self,
            value: (f64, f64, f64),
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_force_vector_call(value)?,
            )
        }
        pub fn set_force_vector(&self, value: (f64, f64, f64)) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_force_vector_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Force {
        pub(crate) fn set_position_call(
            &self,
            value: (f64, f64, f64),
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Force_set_Position",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_position_stream(
            &self,
            value: (f64, f64, f64),
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_position_call(value)?,
            )
        }
        pub fn set_position(&self, value: (f64, f64, f64)) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_position_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Force {
        pub(crate) fn set_reference_frame_call(
            &self,
            value: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Force_set_ReferenceFrame",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_reference_frame_stream(
            &self,
            value: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_reference_frame_call(value)?,
            )
        }
        pub fn set_reference_frame(
            &self,
            value: &crate::services::space_center::ReferenceFrame,
        ) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_reference_frame_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl SpaceCenter {
        pub(crate) fn get_kerbal_call(
            &self,
            name: String,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "GetKerbal",
                    vec![name.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_kerbal_stream(
            &self,
            name: String,
        ) -> Result<
            crate::stream::Stream<Option<crate::services::space_center::CrewMember>>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_kerbal_call(name)?)
        }
        pub fn get_kerbal(
            &self,
            name: String,
        ) -> Result<Option<crate::services::space_center::CrewMember>, RpcError> {
            let request = crate::schema::Request::from(self.get_kerbal_call(name)?);
            let response = self.client.call(request)?;
            <Option<
                crate::services::space_center::CrewMember,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Intake {
        pub(crate) fn get_area_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Intake_get_Area",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_area_stream(&self) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_area_call()?)
        }
        pub fn get_area(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_area_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Intake {
        pub(crate) fn get_flow_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Intake_get_Flow",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_flow_stream(&self) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_flow_call()?)
        }
        pub fn get_flow(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_flow_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Intake {
        pub(crate) fn get_open_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Intake_get_Open",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_open_stream(&self) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_open_call()?)
        }
        pub fn get_open(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_open_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Intake {
        pub(crate) fn get_part_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Intake_get_Part",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_part_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::Part>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_part_call()?)
        }
        pub fn get_part(&self) -> Result<crate::services::space_center::Part, RpcError> {
            let request = crate::schema::Request::from(self.get_part_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::Part>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Intake {
        pub(crate) fn get_speed_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Intake_get_Speed",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_speed_stream(&self) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_speed_call()?)
        }
        pub fn get_speed(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_speed_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Intake {
        pub(crate) fn set_open_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Intake_set_Open",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_open_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.set_open_call(value)?)
        }
        pub fn set_open(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_open_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl LaunchClamp {
        pub(crate) fn release_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "LaunchClamp_Release",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn release_stream(&self) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.release_call()?)
        }
        pub fn release(&self) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.release_call()?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl LaunchClamp {
        pub(crate) fn get_part_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "LaunchClamp_get_Part",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_part_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::Part>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_part_call()?)
        }
        pub fn get_part(&self) -> Result<crate::services::space_center::Part, RpcError> {
            let request = crate::schema::Request::from(self.get_part_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::Part>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl LaunchSite {
        pub(crate) fn get_body_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "LaunchSite_get_Body",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_body_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::CelestialBody>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_body_call()?)
        }
        pub fn get_body(
            &self,
        ) -> Result<crate::services::space_center::CelestialBody, RpcError> {
            let request = crate::schema::Request::from(self.get_body_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::CelestialBody>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl LaunchSite {
        pub(crate) fn get_editor_facility_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "LaunchSite_get_EditorFacility",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_editor_facility_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::EditorFacility>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_editor_facility_call()?,
            )
        }
        pub fn get_editor_facility(
            &self,
        ) -> Result<crate::services::space_center::EditorFacility, RpcError> {
            let request = crate::schema::Request::from(self.get_editor_facility_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::EditorFacility>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl LaunchSite {
        pub(crate) fn get_name_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "LaunchSite_get_Name",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_name_stream(
            &self,
        ) -> Result<crate::stream::Stream<String>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_name_call()?)
        }
        pub fn get_name(&self) -> Result<String, RpcError> {
            let request = crate::schema::Request::from(self.get_name_call()?);
            let response = self.client.call(request)?;
            <String>::from_response(response, self.client.clone())
        }
    }
    impl SpaceCenter {
        pub(crate) fn launch_vessel_call(
            &self,
            craft_directory: String,
            name: String,
            launch_site: String,
            recover: bool,
            crew: Option<Vec<String>>,
            flag_url: String,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "LaunchVessel",
                    vec![
                        craft_directory.to_argument(0usize as u32) ?, name
                        .to_argument(1usize as u32) ?, launch_site.to_argument(2usize as
                        u32) ?, recover.to_argument(3usize as u32) ?, crew
                        .to_argument(4usize as u32) ?, flag_url.to_argument(5usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn launch_vessel_stream(
            &self,
            craft_directory: String,
            name: String,
            launch_site: String,
            recover: bool,
            crew: Option<Vec<String>>,
            flag_url: String,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self
                    .launch_vessel_call(
                        craft_directory,
                        name,
                        launch_site,
                        recover,
                        crew,
                        flag_url,
                    )?,
            )
        }
        pub fn launch_vessel(
            &self,
            craft_directory: String,
            name: String,
            launch_site: String,
            recover: bool,
            crew: Option<Vec<String>>,
            flag_url: String,
        ) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self
                    .launch_vessel_call(
                        craft_directory,
                        name,
                        launch_site,
                        recover,
                        crew,
                        flag_url,
                    )?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl SpaceCenter {
        pub(crate) fn launch_vessel_from_sph_call(
            &self,
            name: String,
            recover: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "LaunchVesselFromSPH",
                    vec![
                        name.to_argument(0usize as u32) ?, recover.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn launch_vessel_from_sph_stream(
            &self,
            name: String,
            recover: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.launch_vessel_from_sph_call(name, recover)?,
            )
        }
        pub fn launch_vessel_from_sph(
            &self,
            name: String,
            recover: bool,
        ) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.launch_vessel_from_sph_call(name, recover)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl SpaceCenter {
        pub(crate) fn launch_vessel_from_vab_call(
            &self,
            name: String,
            recover: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "LaunchVesselFromVAB",
                    vec![
                        name.to_argument(0usize as u32) ?, recover.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn launch_vessel_from_vab_stream(
            &self,
            name: String,
            recover: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.launch_vessel_from_vab_call(name, recover)?,
            )
        }
        pub fn launch_vessel_from_vab(
            &self,
            name: String,
            recover: bool,
        ) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.launch_vessel_from_vab_call(name, recover)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl SpaceCenter {
        pub(crate) fn launchable_vessels_call(
            &self,
            craft_directory: String,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "LaunchableVessels",
                    vec![craft_directory.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn launchable_vessels_stream(
            &self,
            craft_directory: String,
        ) -> Result<crate::stream::Stream<Vec<String>>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.launchable_vessels_call(craft_directory)?,
            )
        }
        pub fn launchable_vessels(
            &self,
            craft_directory: String,
        ) -> Result<Vec<String>, RpcError> {
            let request = crate::schema::Request::from(
                self.launchable_vessels_call(craft_directory)?,
            );
            let response = self.client.call(request)?;
            <Vec<String>>::from_response(response, self.client.clone())
        }
    }
    impl Leg {
        pub(crate) fn get_deployable_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Leg_get_Deployable",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_deployable_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_deployable_call()?)
        }
        pub fn get_deployable(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_deployable_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Leg {
        pub(crate) fn get_deployed_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Leg_get_Deployed",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_deployed_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_deployed_call()?)
        }
        pub fn get_deployed(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_deployed_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Leg {
        pub(crate) fn get_is_grounded_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Leg_get_IsGrounded",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_is_grounded_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_is_grounded_call()?)
        }
        pub fn get_is_grounded(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_is_grounded_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Leg {
        pub(crate) fn get_part_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Leg_get_Part",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_part_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::Part>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_part_call()?)
        }
        pub fn get_part(&self) -> Result<crate::services::space_center::Part, RpcError> {
            let request = crate::schema::Request::from(self.get_part_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::Part>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Leg {
        pub(crate) fn get_state_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Leg_get_State",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_state_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::LegState>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_state_call()?)
        }
        pub fn get_state(
            &self,
        ) -> Result<crate::services::space_center::LegState, RpcError> {
            let request = crate::schema::Request::from(self.get_state_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::LegState>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Leg {
        pub(crate) fn set_deployed_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Leg_set_Deployed",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_deployed_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_deployed_call(value)?,
            )
        }
        pub fn set_deployed(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_deployed_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Light {
        pub(crate) fn get_active_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Light_get_Active",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_active_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_active_call()?)
        }
        pub fn get_active(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_active_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Light {
        pub(crate) fn get_blink_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Light_get_Blink",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_blink_stream(&self) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_blink_call()?)
        }
        pub fn get_blink(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_blink_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Light {
        pub(crate) fn get_blink_rate_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Light_get_BlinkRate",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_blink_rate_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_blink_rate_call()?)
        }
        pub fn get_blink_rate(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_blink_rate_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Light {
        pub(crate) fn get_color_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Light_get_Color",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_color_stream(
            &self,
        ) -> Result<crate::stream::Stream<(f32, f32, f32)>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_color_call()?)
        }
        pub fn get_color(&self) -> Result<(f32, f32, f32), RpcError> {
            let request = crate::schema::Request::from(self.get_color_call()?);
            let response = self.client.call(request)?;
            <(f32, f32, f32)>::from_response(response, self.client.clone())
        }
    }
    impl Light {
        pub(crate) fn get_part_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Light_get_Part",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_part_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::Part>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_part_call()?)
        }
        pub fn get_part(&self) -> Result<crate::services::space_center::Part, RpcError> {
            let request = crate::schema::Request::from(self.get_part_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::Part>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Light {
        pub(crate) fn get_power_usage_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Light_get_PowerUsage",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_power_usage_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_power_usage_call()?)
        }
        pub fn get_power_usage(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_power_usage_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Light {
        pub(crate) fn set_active_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Light_set_Active",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_active_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.set_active_call(value)?)
        }
        pub fn set_active(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_active_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Light {
        pub(crate) fn set_blink_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Light_set_Blink",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_blink_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.set_blink_call(value)?)
        }
        pub fn set_blink(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_blink_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Light {
        pub(crate) fn set_blink_rate_call(
            &self,
            value: f32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Light_set_BlinkRate",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_blink_rate_stream(
            &self,
            value: f32,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_blink_rate_call(value)?,
            )
        }
        pub fn set_blink_rate(&self, value: f32) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_blink_rate_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Light {
        pub(crate) fn set_color_call(
            &self,
            value: (f32, f32, f32),
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Light_set_Color",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_color_stream(
            &self,
            value: (f32, f32, f32),
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.set_color_call(value)?)
        }
        pub fn set_color(&self, value: (f32, f32, f32)) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_color_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl SpaceCenter {
        pub(crate) fn load_call(
            &self,
            name: String,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Load",
                    vec![name.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn load_stream(
            &self,
            name: String,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.load_call(name)?)
        }
        pub fn load(&self, name: String) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.load_call(name)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl SpaceCenter {
        pub(crate) fn load_space_center_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "LoadSpaceCenter",
                    vec![],
                ),
            )
        }
        pub fn load_space_center_stream(
            &self,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.load_space_center_call()?,
            )
        }
        pub fn load_space_center(&self) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.load_space_center_call()?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Module {
        pub(crate) fn get_field_call(
            &self,
            name: String,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Module_GetField",
                    vec![
                        self.to_argument(0usize as u32) ?, name.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn get_field_stream(
            &self,
            name: String,
        ) -> Result<crate::stream::Stream<String>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_field_call(name)?)
        }
        pub fn get_field(&self, name: String) -> Result<String, RpcError> {
            let request = crate::schema::Request::from(self.get_field_call(name)?);
            let response = self.client.call(request)?;
            <String>::from_response(response, self.client.clone())
        }
    }
    impl Module {
        pub(crate) fn get_field_by_id_call(
            &self,
            id: String,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Module_GetFieldById",
                    vec![
                        self.to_argument(0usize as u32) ?, id.to_argument(1usize as u32)
                        ?
                    ],
                ),
            )
        }
        pub fn get_field_by_id_stream(
            &self,
            id: String,
        ) -> Result<crate::stream::Stream<String>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_field_by_id_call(id)?,
            )
        }
        pub fn get_field_by_id(&self, id: String) -> Result<String, RpcError> {
            let request = crate::schema::Request::from(self.get_field_by_id_call(id)?);
            let response = self.client.call(request)?;
            <String>::from_response(response, self.client.clone())
        }
    }
    impl Module {
        pub(crate) fn has_action_call(
            &self,
            name: String,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Module_HasAction",
                    vec![
                        self.to_argument(0usize as u32) ?, name.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn has_action_stream(
            &self,
            name: String,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.has_action_call(name)?)
        }
        pub fn has_action(&self, name: String) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.has_action_call(name)?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Module {
        pub(crate) fn has_action_with_id_call(
            &self,
            id: String,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Module_HasActionWithId",
                    vec![
                        self.to_argument(0usize as u32) ?, id.to_argument(1usize as u32)
                        ?
                    ],
                ),
            )
        }
        pub fn has_action_with_id_stream(
            &self,
            id: String,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.has_action_with_id_call(id)?,
            )
        }
        pub fn has_action_with_id(&self, id: String) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(
                self.has_action_with_id_call(id)?,
            );
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Module {
        pub(crate) fn has_event_call(
            &self,
            name: String,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Module_HasEvent",
                    vec![
                        self.to_argument(0usize as u32) ?, name.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn has_event_stream(
            &self,
            name: String,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.has_event_call(name)?)
        }
        pub fn has_event(&self, name: String) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.has_event_call(name)?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Module {
        pub(crate) fn has_event_with_id_call(
            &self,
            id: String,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Module_HasEventWithId",
                    vec![
                        self.to_argument(0usize as u32) ?, id.to_argument(1usize as u32)
                        ?
                    ],
                ),
            )
        }
        pub fn has_event_with_id_stream(
            &self,
            id: String,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.has_event_with_id_call(id)?,
            )
        }
        pub fn has_event_with_id(&self, id: String) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.has_event_with_id_call(id)?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Module {
        pub(crate) fn has_field_call(
            &self,
            name: String,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Module_HasField",
                    vec![
                        self.to_argument(0usize as u32) ?, name.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn has_field_stream(
            &self,
            name: String,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.has_field_call(name)?)
        }
        pub fn has_field(&self, name: String) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.has_field_call(name)?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Module {
        pub(crate) fn has_field_with_id_call(
            &self,
            id: String,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Module_HasFieldWithId",
                    vec![
                        self.to_argument(0usize as u32) ?, id.to_argument(1usize as u32)
                        ?
                    ],
                ),
            )
        }
        pub fn has_field_with_id_stream(
            &self,
            id: String,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.has_field_with_id_call(id)?,
            )
        }
        pub fn has_field_with_id(&self, id: String) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.has_field_with_id_call(id)?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Module {
        pub(crate) fn reset_field_call(
            &self,
            name: String,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Module_ResetField",
                    vec![
                        self.to_argument(0usize as u32) ?, name.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn reset_field_stream(
            &self,
            name: String,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.reset_field_call(name)?)
        }
        pub fn reset_field(&self, name: String) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.reset_field_call(name)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Module {
        pub(crate) fn reset_field_by_id_call(
            &self,
            id: String,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Module_ResetFieldById",
                    vec![
                        self.to_argument(0usize as u32) ?, id.to_argument(1usize as u32)
                        ?
                    ],
                ),
            )
        }
        pub fn reset_field_by_id_stream(
            &self,
            id: String,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.reset_field_by_id_call(id)?,
            )
        }
        pub fn reset_field_by_id(&self, id: String) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.reset_field_by_id_call(id)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Module {
        pub(crate) fn set_action_call(
            &self,
            name: String,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Module_SetAction",
                    vec![
                        self.to_argument(0usize as u32) ?, name.to_argument(1usize as
                        u32) ?, value.to_argument(2usize as u32) ?
                    ],
                ),
            )
        }
        pub fn set_action_stream(
            &self,
            name: String,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_action_call(name, value)?,
            )
        }
        pub fn set_action(&self, name: String, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_action_call(name, value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Module {
        pub(crate) fn set_action_by_id_call(
            &self,
            id: String,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Module_SetActionById",
                    vec![
                        self.to_argument(0usize as u32) ?, id.to_argument(1usize as u32)
                        ?, value.to_argument(2usize as u32) ?
                    ],
                ),
            )
        }
        pub fn set_action_by_id_stream(
            &self,
            id: String,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_action_by_id_call(id, value)?,
            )
        }
        pub fn set_action_by_id(&self, id: String, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_action_by_id_call(id, value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Module {
        pub(crate) fn set_field_bool_call(
            &self,
            name: String,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Module_SetFieldBool",
                    vec![
                        self.to_argument(0usize as u32) ?, name.to_argument(1usize as
                        u32) ?, value.to_argument(2usize as u32) ?
                    ],
                ),
            )
        }
        pub fn set_field_bool_stream(
            &self,
            name: String,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_field_bool_call(name, value)?,
            )
        }
        pub fn set_field_bool(&self, name: String, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_field_bool_call(name, value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Module {
        pub(crate) fn set_field_bool_by_id_call(
            &self,
            id: String,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Module_SetFieldBoolById",
                    vec![
                        self.to_argument(0usize as u32) ?, id.to_argument(1usize as u32)
                        ?, value.to_argument(2usize as u32) ?
                    ],
                ),
            )
        }
        pub fn set_field_bool_by_id_stream(
            &self,
            id: String,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_field_bool_by_id_call(id, value)?,
            )
        }
        pub fn set_field_bool_by_id(
            &self,
            id: String,
            value: bool,
        ) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_field_bool_by_id_call(id, value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Module {
        pub(crate) fn set_field_float_call(
            &self,
            name: String,
            value: f32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Module_SetFieldFloat",
                    vec![
                        self.to_argument(0usize as u32) ?, name.to_argument(1usize as
                        u32) ?, value.to_argument(2usize as u32) ?
                    ],
                ),
            )
        }
        pub fn set_field_float_stream(
            &self,
            name: String,
            value: f32,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_field_float_call(name, value)?,
            )
        }
        pub fn set_field_float(&self, name: String, value: f32) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_field_float_call(name, value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Module {
        pub(crate) fn set_field_float_by_id_call(
            &self,
            id: String,
            value: f32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Module_SetFieldFloatById",
                    vec![
                        self.to_argument(0usize as u32) ?, id.to_argument(1usize as u32)
                        ?, value.to_argument(2usize as u32) ?
                    ],
                ),
            )
        }
        pub fn set_field_float_by_id_stream(
            &self,
            id: String,
            value: f32,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_field_float_by_id_call(id, value)?,
            )
        }
        pub fn set_field_float_by_id(
            &self,
            id: String,
            value: f32,
        ) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_field_float_by_id_call(id, value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Module {
        pub(crate) fn set_field_int_call(
            &self,
            name: String,
            value: i32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Module_SetFieldInt",
                    vec![
                        self.to_argument(0usize as u32) ?, name.to_argument(1usize as
                        u32) ?, value.to_argument(2usize as u32) ?
                    ],
                ),
            )
        }
        pub fn set_field_int_stream(
            &self,
            name: String,
            value: i32,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_field_int_call(name, value)?,
            )
        }
        pub fn set_field_int(&self, name: String, value: i32) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_field_int_call(name, value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Module {
        pub(crate) fn set_field_int_by_id_call(
            &self,
            id: String,
            value: i32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Module_SetFieldIntById",
                    vec![
                        self.to_argument(0usize as u32) ?, id.to_argument(1usize as u32)
                        ?, value.to_argument(2usize as u32) ?
                    ],
                ),
            )
        }
        pub fn set_field_int_by_id_stream(
            &self,
            id: String,
            value: i32,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_field_int_by_id_call(id, value)?,
            )
        }
        pub fn set_field_int_by_id(
            &self,
            id: String,
            value: i32,
        ) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_field_int_by_id_call(id, value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Module {
        pub(crate) fn set_field_string_call(
            &self,
            name: String,
            value: String,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Module_SetFieldString",
                    vec![
                        self.to_argument(0usize as u32) ?, name.to_argument(1usize as
                        u32) ?, value.to_argument(2usize as u32) ?
                    ],
                ),
            )
        }
        pub fn set_field_string_stream(
            &self,
            name: String,
            value: String,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_field_string_call(name, value)?,
            )
        }
        pub fn set_field_string(
            &self,
            name: String,
            value: String,
        ) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_field_string_call(name, value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Module {
        pub(crate) fn set_field_string_by_id_call(
            &self,
            id: String,
            value: String,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Module_SetFieldStringById",
                    vec![
                        self.to_argument(0usize as u32) ?, id.to_argument(1usize as u32)
                        ?, value.to_argument(2usize as u32) ?
                    ],
                ),
            )
        }
        pub fn set_field_string_by_id_stream(
            &self,
            id: String,
            value: String,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_field_string_by_id_call(id, value)?,
            )
        }
        pub fn set_field_string_by_id(
            &self,
            id: String,
            value: String,
        ) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_field_string_by_id_call(id, value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Module {
        pub(crate) fn trigger_event_call(
            &self,
            name: String,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Module_TriggerEvent",
                    vec![
                        self.to_argument(0usize as u32) ?, name.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn trigger_event_stream(
            &self,
            name: String,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.trigger_event_call(name)?,
            )
        }
        pub fn trigger_event(&self, name: String) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.trigger_event_call(name)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Module {
        pub(crate) fn trigger_event_by_id_call(
            &self,
            id: String,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Module_TriggerEventById",
                    vec![
                        self.to_argument(0usize as u32) ?, id.to_argument(1usize as u32)
                        ?
                    ],
                ),
            )
        }
        pub fn trigger_event_by_id_stream(
            &self,
            id: String,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.trigger_event_by_id_call(id)?,
            )
        }
        pub fn trigger_event_by_id(&self, id: String) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.trigger_event_by_id_call(id)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Module {
        pub(crate) fn get_actions_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Module_get_Actions",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_actions_stream(
            &self,
        ) -> Result<crate::stream::Stream<Vec<String>>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_actions_call()?)
        }
        pub fn get_actions(&self) -> Result<Vec<String>, RpcError> {
            let request = crate::schema::Request::from(self.get_actions_call()?);
            let response = self.client.call(request)?;
            <Vec<String>>::from_response(response, self.client.clone())
        }
    }
    impl Module {
        pub(crate) fn get_actions_by_id_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Module_get_ActionsById",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_actions_by_id_stream(
            &self,
        ) -> Result<crate::stream::Stream<Vec<String>>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_actions_by_id_call()?,
            )
        }
        pub fn get_actions_by_id(&self) -> Result<Vec<String>, RpcError> {
            let request = crate::schema::Request::from(self.get_actions_by_id_call()?);
            let response = self.client.call(request)?;
            <Vec<String>>::from_response(response, self.client.clone())
        }
    }
    impl Module {
        pub(crate) fn get_events_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Module_get_Events",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_events_stream(
            &self,
        ) -> Result<crate::stream::Stream<Vec<String>>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_events_call()?)
        }
        pub fn get_events(&self) -> Result<Vec<String>, RpcError> {
            let request = crate::schema::Request::from(self.get_events_call()?);
            let response = self.client.call(request)?;
            <Vec<String>>::from_response(response, self.client.clone())
        }
    }
    impl Module {
        pub(crate) fn get_events_by_id_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Module_get_EventsById",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_events_by_id_stream(
            &self,
        ) -> Result<crate::stream::Stream<Vec<String>>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_events_by_id_call()?,
            )
        }
        pub fn get_events_by_id(&self) -> Result<Vec<String>, RpcError> {
            let request = crate::schema::Request::from(self.get_events_by_id_call()?);
            let response = self.client.call(request)?;
            <Vec<String>>::from_response(response, self.client.clone())
        }
    }
    impl Module {
        pub(crate) fn get_fields_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Module_get_Fields",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_fields_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<std::collections::HashMap<String, String>>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_fields_call()?)
        }
        pub fn get_fields(
            &self,
        ) -> Result<std::collections::HashMap<String, String>, RpcError> {
            let request = crate::schema::Request::from(self.get_fields_call()?);
            let response = self.client.call(request)?;
            <std::collections::HashMap<
                String,
                String,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Module {
        pub(crate) fn get_fields_by_id_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Module_get_FieldsById",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_fields_by_id_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<std::collections::HashMap<String, String>>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_fields_by_id_call()?,
            )
        }
        pub fn get_fields_by_id(
            &self,
        ) -> Result<std::collections::HashMap<String, String>, RpcError> {
            let request = crate::schema::Request::from(self.get_fields_by_id_call()?);
            let response = self.client.call(request)?;
            <std::collections::HashMap<
                String,
                String,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Module {
        pub(crate) fn get_name_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Module_get_Name",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_name_stream(
            &self,
        ) -> Result<crate::stream::Stream<String>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_name_call()?)
        }
        pub fn get_name(&self) -> Result<String, RpcError> {
            let request = crate::schema::Request::from(self.get_name_call()?);
            let response = self.client.call(request)?;
            <String>::from_response(response, self.client.clone())
        }
    }
    impl Module {
        pub(crate) fn get_part_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Module_get_Part",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_part_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::Part>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_part_call()?)
        }
        pub fn get_part(&self) -> Result<crate::services::space_center::Part, RpcError> {
            let request = crate::schema::Request::from(self.get_part_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::Part>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Node {
        pub(crate) fn burn_vector_call(
            &self,
            reference_frame: Option<&crate::services::space_center::ReferenceFrame>,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Node_BurnVector",
                    vec![
                        self.to_argument(0usize as u32) ?, reference_frame
                        .to_argument(1usize as u32) ?
                    ],
                ),
            )
        }
        pub fn burn_vector_stream(
            &self,
            reference_frame: Option<&crate::services::space_center::ReferenceFrame>,
        ) -> Result<crate::stream::Stream<(f64, f64, f64)>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.burn_vector_call(reference_frame)?,
            )
        }
        pub fn burn_vector(
            &self,
            reference_frame: Option<&crate::services::space_center::ReferenceFrame>,
        ) -> Result<(f64, f64, f64), RpcError> {
            let request = crate::schema::Request::from(
                self.burn_vector_call(reference_frame)?,
            );
            let response = self.client.call(request)?;
            <(f64, f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl Node {
        pub(crate) fn direction_call(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Node_Direction",
                    vec![
                        self.to_argument(0usize as u32) ?, reference_frame
                        .to_argument(1usize as u32) ?
                    ],
                ),
            )
        }
        pub fn direction_stream(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::stream::Stream<(f64, f64, f64)>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.direction_call(reference_frame)?,
            )
        }
        pub fn direction(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<(f64, f64, f64), RpcError> {
            let request = crate::schema::Request::from(
                self.direction_call(reference_frame)?,
            );
            let response = self.client.call(request)?;
            <(f64, f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl Node {
        pub(crate) fn position_call(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Node_Position",
                    vec![
                        self.to_argument(0usize as u32) ?, reference_frame
                        .to_argument(1usize as u32) ?
                    ],
                ),
            )
        }
        pub fn position_stream(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::stream::Stream<(f64, f64, f64)>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.position_call(reference_frame)?,
            )
        }
        pub fn position(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<(f64, f64, f64), RpcError> {
            let request = crate::schema::Request::from(
                self.position_call(reference_frame)?,
            );
            let response = self.client.call(request)?;
            <(f64, f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl Node {
        pub(crate) fn remaining_burn_vector_call(
            &self,
            reference_frame: Option<&crate::services::space_center::ReferenceFrame>,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Node_RemainingBurnVector",
                    vec![
                        self.to_argument(0usize as u32) ?, reference_frame
                        .to_argument(1usize as u32) ?
                    ],
                ),
            )
        }
        pub fn remaining_burn_vector_stream(
            &self,
            reference_frame: Option<&crate::services::space_center::ReferenceFrame>,
        ) -> Result<crate::stream::Stream<(f64, f64, f64)>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.remaining_burn_vector_call(reference_frame)?,
            )
        }
        pub fn remaining_burn_vector(
            &self,
            reference_frame: Option<&crate::services::space_center::ReferenceFrame>,
        ) -> Result<(f64, f64, f64), RpcError> {
            let request = crate::schema::Request::from(
                self.remaining_burn_vector_call(reference_frame)?,
            );
            let response = self.client.call(request)?;
            <(f64, f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl Node {
        pub(crate) fn remove_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Node_Remove",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn remove_stream(&self) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.remove_call()?)
        }
        pub fn remove(&self) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.remove_call()?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Node {
        pub(crate) fn get_delta_v_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Node_get_DeltaV",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_delta_v_stream(
            &self,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_delta_v_call()?)
        }
        pub fn get_delta_v(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(self.get_delta_v_call()?);
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Node {
        pub(crate) fn get_normal_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Node_get_Normal",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_normal_stream(&self) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_normal_call()?)
        }
        pub fn get_normal(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(self.get_normal_call()?);
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Node {
        pub(crate) fn get_orbit_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Node_get_Orbit",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_orbit_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::Orbit>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_orbit_call()?)
        }
        pub fn get_orbit(
            &self,
        ) -> Result<crate::services::space_center::Orbit, RpcError> {
            let request = crate::schema::Request::from(self.get_orbit_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::Orbit>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Node {
        pub(crate) fn get_orbital_reference_frame_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Node_get_OrbitalReferenceFrame",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_orbital_reference_frame_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::ReferenceFrame>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_orbital_reference_frame_call()?,
            )
        }
        pub fn get_orbital_reference_frame(
            &self,
        ) -> Result<crate::services::space_center::ReferenceFrame, RpcError> {
            let request = crate::schema::Request::from(
                self.get_orbital_reference_frame_call()?,
            );
            let response = self.client.call(request)?;
            <crate::services::space_center::ReferenceFrame>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Node {
        pub(crate) fn get_prograde_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Node_get_Prograde",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_prograde_stream(
            &self,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_prograde_call()?)
        }
        pub fn get_prograde(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(self.get_prograde_call()?);
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Node {
        pub(crate) fn get_radial_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Node_get_Radial",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_radial_stream(&self) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_radial_call()?)
        }
        pub fn get_radial(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(self.get_radial_call()?);
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Node {
        pub(crate) fn get_reference_frame_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Node_get_ReferenceFrame",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_reference_frame_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::ReferenceFrame>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_reference_frame_call()?,
            )
        }
        pub fn get_reference_frame(
            &self,
        ) -> Result<crate::services::space_center::ReferenceFrame, RpcError> {
            let request = crate::schema::Request::from(self.get_reference_frame_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::ReferenceFrame>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Node {
        pub(crate) fn get_remaining_delta_v_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Node_get_RemainingDeltaV",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_remaining_delta_v_stream(
            &self,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_remaining_delta_v_call()?,
            )
        }
        pub fn get_remaining_delta_v(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(
                self.get_remaining_delta_v_call()?,
            );
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Node {
        pub(crate) fn get_time_to_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Node_get_TimeTo",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_time_to_stream(
            &self,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_time_to_call()?)
        }
        pub fn get_time_to(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(self.get_time_to_call()?);
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Node {
        pub(crate) fn get_ut_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Node_get_UT",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_ut_stream(&self) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_ut_call()?)
        }
        pub fn get_ut(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(self.get_ut_call()?);
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Node {
        pub(crate) fn set_delta_v_call(
            &self,
            value: f64,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Node_set_DeltaV",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_delta_v_stream(
            &self,
            value: f64,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_delta_v_call(value)?,
            )
        }
        pub fn set_delta_v(&self, value: f64) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_delta_v_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Node {
        pub(crate) fn set_normal_call(
            &self,
            value: f64,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Node_set_Normal",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_normal_stream(
            &self,
            value: f64,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.set_normal_call(value)?)
        }
        pub fn set_normal(&self, value: f64) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_normal_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Node {
        pub(crate) fn set_prograde_call(
            &self,
            value: f64,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Node_set_Prograde",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_prograde_stream(
            &self,
            value: f64,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_prograde_call(value)?,
            )
        }
        pub fn set_prograde(&self, value: f64) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_prograde_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Node {
        pub(crate) fn set_radial_call(
            &self,
            value: f64,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Node_set_Radial",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_radial_stream(
            &self,
            value: f64,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.set_radial_call(value)?)
        }
        pub fn set_radial(&self, value: f64) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_radial_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Node {
        pub(crate) fn set_ut_call(
            &self,
            value: f64,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Node_set_UT",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_ut_stream(
            &self,
            value: f64,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.set_ut_call(value)?)
        }
        pub fn set_ut(&self, value: f64) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_ut_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Orbit {
        pub(crate) fn distance_at_closest_approach_call(
            &self,
            target: &crate::services::space_center::Orbit,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Orbit_DistanceAtClosestApproach",
                    vec![
                        self.to_argument(0usize as u32) ?, target.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn distance_at_closest_approach_stream(
            &self,
            target: &crate::services::space_center::Orbit,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.distance_at_closest_approach_call(target)?,
            )
        }
        pub fn distance_at_closest_approach(
            &self,
            target: &crate::services::space_center::Orbit,
        ) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(
                self.distance_at_closest_approach_call(target)?,
            );
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Orbit {
        pub(crate) fn eccentric_anomaly_at_ut_call(
            &self,
            ut: f64,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Orbit_EccentricAnomalyAtUT",
                    vec![
                        self.to_argument(0usize as u32) ?, ut.to_argument(1usize as u32)
                        ?
                    ],
                ),
            )
        }
        pub fn eccentric_anomaly_at_ut_stream(
            &self,
            ut: f64,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.eccentric_anomaly_at_ut_call(ut)?,
            )
        }
        pub fn eccentric_anomaly_at_ut(&self, ut: f64) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(
                self.eccentric_anomaly_at_ut_call(ut)?,
            );
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Orbit {
        pub(crate) fn list_closest_approaches_call(
            &self,
            target: &crate::services::space_center::Orbit,
            orbits: i32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Orbit_ListClosestApproaches",
                    vec![
                        self.to_argument(0usize as u32) ?, target.to_argument(1usize as
                        u32) ?, orbits.to_argument(2usize as u32) ?
                    ],
                ),
            )
        }
        pub fn list_closest_approaches_stream(
            &self,
            target: &crate::services::space_center::Orbit,
            orbits: i32,
        ) -> Result<crate::stream::Stream<Vec<Vec<f64>>>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.list_closest_approaches_call(target, orbits)?,
            )
        }
        pub fn list_closest_approaches(
            &self,
            target: &crate::services::space_center::Orbit,
            orbits: i32,
        ) -> Result<Vec<Vec<f64>>, RpcError> {
            let request = crate::schema::Request::from(
                self.list_closest_approaches_call(target, orbits)?,
            );
            let response = self.client.call(request)?;
            <Vec<Vec<f64>>>::from_response(response, self.client.clone())
        }
    }
    impl Orbit {
        pub(crate) fn mean_anomaly_at_ut_call(
            &self,
            ut: f64,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Orbit_MeanAnomalyAtUT",
                    vec![
                        self.to_argument(0usize as u32) ?, ut.to_argument(1usize as u32)
                        ?
                    ],
                ),
            )
        }
        pub fn mean_anomaly_at_ut_stream(
            &self,
            ut: f64,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.mean_anomaly_at_ut_call(ut)?,
            )
        }
        pub fn mean_anomaly_at_ut(&self, ut: f64) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(
                self.mean_anomaly_at_ut_call(ut)?,
            );
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Orbit {
        pub(crate) fn orbital_speed_at_call(
            &self,
            time: f64,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Orbit_OrbitalSpeedAt",
                    vec![
                        self.to_argument(0usize as u32) ?, time.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn orbital_speed_at_stream(
            &self,
            time: f64,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.orbital_speed_at_call(time)?,
            )
        }
        pub fn orbital_speed_at(&self, time: f64) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(
                self.orbital_speed_at_call(time)?,
            );
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Orbit {
        pub(crate) fn position_at_call(
            &self,
            ut: f64,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Orbit_PositionAt",
                    vec![
                        self.to_argument(0usize as u32) ?, ut.to_argument(1usize as u32)
                        ?, reference_frame.to_argument(2usize as u32) ?
                    ],
                ),
            )
        }
        pub fn position_at_stream(
            &self,
            ut: f64,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::stream::Stream<(f64, f64, f64)>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.position_at_call(ut, reference_frame)?,
            )
        }
        pub fn position_at(
            &self,
            ut: f64,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<(f64, f64, f64), RpcError> {
            let request = crate::schema::Request::from(
                self.position_at_call(ut, reference_frame)?,
            );
            let response = self.client.call(request)?;
            <(f64, f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl Orbit {
        pub(crate) fn radius_at_call(
            &self,
            ut: f64,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Orbit_RadiusAt",
                    vec![
                        self.to_argument(0usize as u32) ?, ut.to_argument(1usize as u32)
                        ?
                    ],
                ),
            )
        }
        pub fn radius_at_stream(
            &self,
            ut: f64,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.radius_at_call(ut)?)
        }
        pub fn radius_at(&self, ut: f64) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(self.radius_at_call(ut)?);
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Orbit {
        pub(crate) fn radius_at_true_anomaly_call(
            &self,
            true_anomaly: f64,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Orbit_RadiusAtTrueAnomaly",
                    vec![
                        self.to_argument(0usize as u32) ?, true_anomaly
                        .to_argument(1usize as u32) ?
                    ],
                ),
            )
        }
        pub fn radius_at_true_anomaly_stream(
            &self,
            true_anomaly: f64,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.radius_at_true_anomaly_call(true_anomaly)?,
            )
        }
        pub fn radius_at_true_anomaly(
            &self,
            true_anomaly: f64,
        ) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(
                self.radius_at_true_anomaly_call(true_anomaly)?,
            );
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Orbit {
        pub(crate) fn relative_inclination_call(
            &self,
            target: &crate::services::space_center::Orbit,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Orbit_RelativeInclination",
                    vec![
                        self.to_argument(0usize as u32) ?, target.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn relative_inclination_stream(
            &self,
            target: &crate::services::space_center::Orbit,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.relative_inclination_call(target)?,
            )
        }
        pub fn relative_inclination(
            &self,
            target: &crate::services::space_center::Orbit,
        ) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(
                self.relative_inclination_call(target)?,
            );
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Orbit {
        pub(crate) fn time_of_closest_approach_call(
            &self,
            target: &crate::services::space_center::Orbit,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Orbit_TimeOfClosestApproach",
                    vec![
                        self.to_argument(0usize as u32) ?, target.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn time_of_closest_approach_stream(
            &self,
            target: &crate::services::space_center::Orbit,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.time_of_closest_approach_call(target)?,
            )
        }
        pub fn time_of_closest_approach(
            &self,
            target: &crate::services::space_center::Orbit,
        ) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(
                self.time_of_closest_approach_call(target)?,
            );
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Orbit {
        pub(crate) fn true_anomaly_at_an_call(
            &self,
            target: &crate::services::space_center::Orbit,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Orbit_TrueAnomalyAtAN",
                    vec![
                        self.to_argument(0usize as u32) ?, target.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn true_anomaly_at_an_stream(
            &self,
            target: &crate::services::space_center::Orbit,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.true_anomaly_at_an_call(target)?,
            )
        }
        pub fn true_anomaly_at_an(
            &self,
            target: &crate::services::space_center::Orbit,
        ) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(
                self.true_anomaly_at_an_call(target)?,
            );
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Orbit {
        pub(crate) fn true_anomaly_at_dn_call(
            &self,
            target: &crate::services::space_center::Orbit,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Orbit_TrueAnomalyAtDN",
                    vec![
                        self.to_argument(0usize as u32) ?, target.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn true_anomaly_at_dn_stream(
            &self,
            target: &crate::services::space_center::Orbit,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.true_anomaly_at_dn_call(target)?,
            )
        }
        pub fn true_anomaly_at_dn(
            &self,
            target: &crate::services::space_center::Orbit,
        ) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(
                self.true_anomaly_at_dn_call(target)?,
            );
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Orbit {
        pub(crate) fn true_anomaly_at_radius_call(
            &self,
            radius: f64,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Orbit_TrueAnomalyAtRadius",
                    vec![
                        self.to_argument(0usize as u32) ?, radius.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn true_anomaly_at_radius_stream(
            &self,
            radius: f64,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.true_anomaly_at_radius_call(radius)?,
            )
        }
        pub fn true_anomaly_at_radius(&self, radius: f64) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(
                self.true_anomaly_at_radius_call(radius)?,
            );
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Orbit {
        pub(crate) fn true_anomaly_at_ut_call(
            &self,
            ut: f64,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Orbit_TrueAnomalyAtUT",
                    vec![
                        self.to_argument(0usize as u32) ?, ut.to_argument(1usize as u32)
                        ?
                    ],
                ),
            )
        }
        pub fn true_anomaly_at_ut_stream(
            &self,
            ut: f64,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.true_anomaly_at_ut_call(ut)?,
            )
        }
        pub fn true_anomaly_at_ut(&self, ut: f64) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(
                self.true_anomaly_at_ut_call(ut)?,
            );
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Orbit {
        pub(crate) fn ut_at_true_anomaly_call(
            &self,
            true_anomaly: f64,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Orbit_UTAtTrueAnomaly",
                    vec![
                        self.to_argument(0usize as u32) ?, true_anomaly
                        .to_argument(1usize as u32) ?
                    ],
                ),
            )
        }
        pub fn ut_at_true_anomaly_stream(
            &self,
            true_anomaly: f64,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.ut_at_true_anomaly_call(true_anomaly)?,
            )
        }
        pub fn ut_at_true_anomaly(&self, true_anomaly: f64) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(
                self.ut_at_true_anomaly_call(true_anomaly)?,
            );
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Orbit {
        pub(crate) fn get_apoapsis_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Orbit_get_Apoapsis",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_apoapsis_stream(
            &self,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_apoapsis_call()?)
        }
        pub fn get_apoapsis(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(self.get_apoapsis_call()?);
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Orbit {
        pub(crate) fn get_apoapsis_altitude_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Orbit_get_ApoapsisAltitude",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_apoapsis_altitude_stream(
            &self,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_apoapsis_altitude_call()?,
            )
        }
        pub fn get_apoapsis_altitude(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(
                self.get_apoapsis_altitude_call()?,
            );
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Orbit {
        pub(crate) fn get_argument_of_periapsis_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Orbit_get_ArgumentOfPeriapsis",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_argument_of_periapsis_stream(
            &self,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_argument_of_periapsis_call()?,
            )
        }
        pub fn get_argument_of_periapsis(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(
                self.get_argument_of_periapsis_call()?,
            );
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Orbit {
        pub(crate) fn get_body_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Orbit_get_Body",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_body_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::CelestialBody>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_body_call()?)
        }
        pub fn get_body(
            &self,
        ) -> Result<crate::services::space_center::CelestialBody, RpcError> {
            let request = crate::schema::Request::from(self.get_body_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::CelestialBody>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Orbit {
        pub(crate) fn get_eccentric_anomaly_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Orbit_get_EccentricAnomaly",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_eccentric_anomaly_stream(
            &self,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_eccentric_anomaly_call()?,
            )
        }
        pub fn get_eccentric_anomaly(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(
                self.get_eccentric_anomaly_call()?,
            );
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Orbit {
        pub(crate) fn get_eccentricity_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Orbit_get_Eccentricity",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_eccentricity_stream(
            &self,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_eccentricity_call()?,
            )
        }
        pub fn get_eccentricity(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(self.get_eccentricity_call()?);
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Orbit {
        pub(crate) fn get_epoch_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Orbit_get_Epoch",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_epoch_stream(&self) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_epoch_call()?)
        }
        pub fn get_epoch(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(self.get_epoch_call()?);
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Orbit {
        pub(crate) fn get_inclination_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Orbit_get_Inclination",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_inclination_stream(
            &self,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_inclination_call()?)
        }
        pub fn get_inclination(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(self.get_inclination_call()?);
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Orbit {
        pub(crate) fn get_longitude_of_ascending_node_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Orbit_get_LongitudeOfAscendingNode",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_longitude_of_ascending_node_stream(
            &self,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_longitude_of_ascending_node_call()?,
            )
        }
        pub fn get_longitude_of_ascending_node(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(
                self.get_longitude_of_ascending_node_call()?,
            );
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Orbit {
        pub(crate) fn get_mean_anomaly_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Orbit_get_MeanAnomaly",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_mean_anomaly_stream(
            &self,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_mean_anomaly_call()?,
            )
        }
        pub fn get_mean_anomaly(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(self.get_mean_anomaly_call()?);
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Orbit {
        pub(crate) fn get_mean_anomaly_at_epoch_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Orbit_get_MeanAnomalyAtEpoch",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_mean_anomaly_at_epoch_stream(
            &self,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_mean_anomaly_at_epoch_call()?,
            )
        }
        pub fn get_mean_anomaly_at_epoch(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(
                self.get_mean_anomaly_at_epoch_call()?,
            );
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Orbit {
        pub(crate) fn get_next_orbit_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Orbit_get_NextOrbit",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_next_orbit_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Option<crate::services::space_center::Orbit>>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_next_orbit_call()?)
        }
        pub fn get_next_orbit(
            &self,
        ) -> Result<Option<crate::services::space_center::Orbit>, RpcError> {
            let request = crate::schema::Request::from(self.get_next_orbit_call()?);
            let response = self.client.call(request)?;
            <Option<
                crate::services::space_center::Orbit,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Orbit {
        pub(crate) fn get_orbital_speed_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Orbit_get_OrbitalSpeed",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_orbital_speed_stream(
            &self,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_orbital_speed_call()?,
            )
        }
        pub fn get_orbital_speed(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(self.get_orbital_speed_call()?);
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Orbit {
        pub(crate) fn get_periapsis_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Orbit_get_Periapsis",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_periapsis_stream(
            &self,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_periapsis_call()?)
        }
        pub fn get_periapsis(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(self.get_periapsis_call()?);
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Orbit {
        pub(crate) fn get_periapsis_altitude_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Orbit_get_PeriapsisAltitude",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_periapsis_altitude_stream(
            &self,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_periapsis_altitude_call()?,
            )
        }
        pub fn get_periapsis_altitude(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(
                self.get_periapsis_altitude_call()?,
            );
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Orbit {
        pub(crate) fn get_period_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Orbit_get_Period",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_period_stream(&self) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_period_call()?)
        }
        pub fn get_period(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(self.get_period_call()?);
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Orbit {
        pub(crate) fn get_radius_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Orbit_get_Radius",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_radius_stream(&self) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_radius_call()?)
        }
        pub fn get_radius(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(self.get_radius_call()?);
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Orbit {
        pub(crate) fn get_semi_major_axis_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Orbit_get_SemiMajorAxis",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_semi_major_axis_stream(
            &self,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_semi_major_axis_call()?,
            )
        }
        pub fn get_semi_major_axis(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(self.get_semi_major_axis_call()?);
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Orbit {
        pub(crate) fn get_semi_minor_axis_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Orbit_get_SemiMinorAxis",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_semi_minor_axis_stream(
            &self,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_semi_minor_axis_call()?,
            )
        }
        pub fn get_semi_minor_axis(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(self.get_semi_minor_axis_call()?);
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Orbit {
        pub(crate) fn get_speed_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Orbit_get_Speed",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_speed_stream(&self) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_speed_call()?)
        }
        pub fn get_speed(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(self.get_speed_call()?);
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Orbit {
        pub(crate) fn get_time_to_apoapsis_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Orbit_get_TimeToApoapsis",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_time_to_apoapsis_stream(
            &self,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_time_to_apoapsis_call()?,
            )
        }
        pub fn get_time_to_apoapsis(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(
                self.get_time_to_apoapsis_call()?,
            );
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Orbit {
        pub(crate) fn get_time_to_periapsis_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Orbit_get_TimeToPeriapsis",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_time_to_periapsis_stream(
            &self,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_time_to_periapsis_call()?,
            )
        }
        pub fn get_time_to_periapsis(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(
                self.get_time_to_periapsis_call()?,
            );
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Orbit {
        pub(crate) fn get_time_to_soi_change_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Orbit_get_TimeToSOIChange",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_time_to_soi_change_stream(
            &self,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_time_to_soi_change_call()?,
            )
        }
        pub fn get_time_to_soi_change(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(
                self.get_time_to_soi_change_call()?,
            );
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Orbit {
        pub(crate) fn get_true_anomaly_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Orbit_get_TrueAnomaly",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_true_anomaly_stream(
            &self,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_true_anomaly_call()?,
            )
        }
        pub fn get_true_anomaly(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(self.get_true_anomaly_call()?);
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Orbit {
        pub(crate) fn static_reference_plane_direction_call(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Orbit_static_ReferencePlaneDirection",
                    vec![reference_frame.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn static_reference_plane_direction_stream(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::stream::Stream<(f64, f64, f64)>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.static_reference_plane_direction_call(reference_frame)?,
            )
        }
        pub fn static_reference_plane_direction(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<(f64, f64, f64), RpcError> {
            let request = crate::schema::Request::from(
                self.static_reference_plane_direction_call(reference_frame)?,
            );
            let response = self.client.call(request)?;
            <(f64, f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl Orbit {
        pub(crate) fn static_reference_plane_normal_call(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Orbit_static_ReferencePlaneNormal",
                    vec![reference_frame.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn static_reference_plane_normal_stream(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::stream::Stream<(f64, f64, f64)>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.static_reference_plane_normal_call(reference_frame)?,
            )
        }
        pub fn static_reference_plane_normal(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<(f64, f64, f64), RpcError> {
            let request = crate::schema::Request::from(
                self.static_reference_plane_normal_call(reference_frame)?,
            );
            let response = self.client.call(request)?;
            <(f64, f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl Parachute {
        pub(crate) fn arm_call(&self) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Parachute_Arm",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn arm_stream(&self) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.arm_call()?)
        }
        pub fn arm(&self) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.arm_call()?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Parachute {
        pub(crate) fn cut_call(&self) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Parachute_Cut",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn cut_stream(&self) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.cut_call()?)
        }
        pub fn cut(&self) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.cut_call()?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Parachute {
        pub(crate) fn deploy_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Parachute_Deploy",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn deploy_stream(&self) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.deploy_call()?)
        }
        pub fn deploy(&self) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.deploy_call()?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Parachute {
        pub(crate) fn get_armed_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Parachute_get_Armed",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_armed_stream(&self) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_armed_call()?)
        }
        pub fn get_armed(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_armed_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Parachute {
        pub(crate) fn get_deploy_altitude_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Parachute_get_DeployAltitude",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_deploy_altitude_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_deploy_altitude_call()?,
            )
        }
        pub fn get_deploy_altitude(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_deploy_altitude_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Parachute {
        pub(crate) fn get_deploy_min_pressure_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Parachute_get_DeployMinPressure",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_deploy_min_pressure_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_deploy_min_pressure_call()?,
            )
        }
        pub fn get_deploy_min_pressure(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(
                self.get_deploy_min_pressure_call()?,
            );
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Parachute {
        pub(crate) fn get_deployed_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Parachute_get_Deployed",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_deployed_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_deployed_call()?)
        }
        pub fn get_deployed(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_deployed_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Parachute {
        pub(crate) fn get_part_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Parachute_get_Part",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_part_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::Part>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_part_call()?)
        }
        pub fn get_part(&self) -> Result<crate::services::space_center::Part, RpcError> {
            let request = crate::schema::Request::from(self.get_part_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::Part>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Parachute {
        pub(crate) fn get_state_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Parachute_get_State",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_state_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::ParachuteState>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_state_call()?)
        }
        pub fn get_state(
            &self,
        ) -> Result<crate::services::space_center::ParachuteState, RpcError> {
            let request = crate::schema::Request::from(self.get_state_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::ParachuteState>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Parachute {
        pub(crate) fn set_deploy_altitude_call(
            &self,
            value: f32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Parachute_set_DeployAltitude",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_deploy_altitude_stream(
            &self,
            value: f32,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_deploy_altitude_call(value)?,
            )
        }
        pub fn set_deploy_altitude(&self, value: f32) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_deploy_altitude_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Parachute {
        pub(crate) fn set_deploy_min_pressure_call(
            &self,
            value: f32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Parachute_set_DeployMinPressure",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_deploy_min_pressure_stream(
            &self,
            value: f32,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_deploy_min_pressure_call(value)?,
            )
        }
        pub fn set_deploy_min_pressure(&self, value: f32) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_deploy_min_pressure_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Part {
        pub(crate) fn add_force_call(
            &self,
            force: (f64, f64, f64),
            position: (f64, f64, f64),
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_AddForce",
                    vec![
                        self.to_argument(0usize as u32) ?, force.to_argument(1usize as
                        u32) ?, position.to_argument(2usize as u32) ?, reference_frame
                        .to_argument(3usize as u32) ?
                    ],
                ),
            )
        }
        pub fn add_force_stream(
            &self,
            force: (f64, f64, f64),
            position: (f64, f64, f64),
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::Force>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.add_force_call(force, position, reference_frame)?,
            )
        }
        pub fn add_force(
            &self,
            force: (f64, f64, f64),
            position: (f64, f64, f64),
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::services::space_center::Force, RpcError> {
            let request = crate::schema::Request::from(
                self.add_force_call(force, position, reference_frame)?,
            );
            let response = self.client.call(request)?;
            <crate::services::space_center::Force>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Part {
        pub(crate) fn bounding_box_call(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_BoundingBox",
                    vec![
                        self.to_argument(0usize as u32) ?, reference_frame
                        .to_argument(1usize as u32) ?
                    ],
                ),
            )
        }
        pub fn bounding_box_stream(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<
            crate::stream::Stream<((f64, f64, f64), (f64, f64, f64))>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.bounding_box_call(reference_frame)?,
            )
        }
        pub fn bounding_box(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<((f64, f64, f64), (f64, f64, f64)), RpcError> {
            let request = crate::schema::Request::from(
                self.bounding_box_call(reference_frame)?,
            );
            let response = self.client.call(request)?;
            <(
                (f64, f64, f64),
                (f64, f64, f64),
            )>::from_response(response, self.client.clone())
        }
    }
    impl Part {
        pub(crate) fn center_of_mass_call(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_CenterOfMass",
                    vec![
                        self.to_argument(0usize as u32) ?, reference_frame
                        .to_argument(1usize as u32) ?
                    ],
                ),
            )
        }
        pub fn center_of_mass_stream(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::stream::Stream<(f64, f64, f64)>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.center_of_mass_call(reference_frame)?,
            )
        }
        pub fn center_of_mass(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<(f64, f64, f64), RpcError> {
            let request = crate::schema::Request::from(
                self.center_of_mass_call(reference_frame)?,
            );
            let response = self.client.call(request)?;
            <(f64, f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl Part {
        pub(crate) fn direction_call(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_Direction",
                    vec![
                        self.to_argument(0usize as u32) ?, reference_frame
                        .to_argument(1usize as u32) ?
                    ],
                ),
            )
        }
        pub fn direction_stream(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::stream::Stream<(f64, f64, f64)>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.direction_call(reference_frame)?,
            )
        }
        pub fn direction(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<(f64, f64, f64), RpcError> {
            let request = crate::schema::Request::from(
                self.direction_call(reference_frame)?,
            );
            let response = self.client.call(request)?;
            <(f64, f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl Part {
        pub(crate) fn instantaneous_force_call(
            &self,
            force: (f64, f64, f64),
            position: (f64, f64, f64),
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_InstantaneousForce",
                    vec![
                        self.to_argument(0usize as u32) ?, force.to_argument(1usize as
                        u32) ?, position.to_argument(2usize as u32) ?, reference_frame
                        .to_argument(3usize as u32) ?
                    ],
                ),
            )
        }
        pub fn instantaneous_force_stream(
            &self,
            force: (f64, f64, f64),
            position: (f64, f64, f64),
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.instantaneous_force_call(force, position, reference_frame)?,
            )
        }
        pub fn instantaneous_force(
            &self,
            force: (f64, f64, f64),
            position: (f64, f64, f64),
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.instantaneous_force_call(force, position, reference_frame)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Part {
        pub(crate) fn position_call(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_Position",
                    vec![
                        self.to_argument(0usize as u32) ?, reference_frame
                        .to_argument(1usize as u32) ?
                    ],
                ),
            )
        }
        pub fn position_stream(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::stream::Stream<(f64, f64, f64)>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.position_call(reference_frame)?,
            )
        }
        pub fn position(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<(f64, f64, f64), RpcError> {
            let request = crate::schema::Request::from(
                self.position_call(reference_frame)?,
            );
            let response = self.client.call(request)?;
            <(f64, f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl Part {
        pub(crate) fn rotation_call(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_Rotation",
                    vec![
                        self.to_argument(0usize as u32) ?, reference_frame
                        .to_argument(1usize as u32) ?
                    ],
                ),
            )
        }
        pub fn rotation_stream(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::stream::Stream<(f64, f64, f64, f64)>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.rotation_call(reference_frame)?,
            )
        }
        pub fn rotation(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<(f64, f64, f64, f64), RpcError> {
            let request = crate::schema::Request::from(
                self.rotation_call(reference_frame)?,
            );
            let response = self.client.call(request)?;
            <(f64, f64, f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl Part {
        pub(crate) fn velocity_call(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_Velocity",
                    vec![
                        self.to_argument(0usize as u32) ?, reference_frame
                        .to_argument(1usize as u32) ?
                    ],
                ),
            )
        }
        pub fn velocity_stream(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::stream::Stream<(f64, f64, f64)>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.velocity_call(reference_frame)?,
            )
        }
        pub fn velocity(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<(f64, f64, f64), RpcError> {
            let request = crate::schema::Request::from(
                self.velocity_call(reference_frame)?,
            );
            let response = self.client.call(request)?;
            <(f64, f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl Part {
        pub(crate) fn get_antenna_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_get_Antenna",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_antenna_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Option<crate::services::space_center::Antenna>>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_antenna_call()?)
        }
        pub fn get_antenna(
            &self,
        ) -> Result<Option<crate::services::space_center::Antenna>, RpcError> {
            let request = crate::schema::Request::from(self.get_antenna_call()?);
            let response = self.client.call(request)?;
            <Option<
                crate::services::space_center::Antenna,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Part {
        pub(crate) fn get_auto_strut_mode_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_get_AutoStrutMode",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_auto_strut_mode_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::AutoStrutMode>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_auto_strut_mode_call()?,
            )
        }
        pub fn get_auto_strut_mode(
            &self,
        ) -> Result<crate::services::space_center::AutoStrutMode, RpcError> {
            let request = crate::schema::Request::from(self.get_auto_strut_mode_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::AutoStrutMode>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Part {
        pub(crate) fn get_available_seats_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_get_AvailableSeats",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_available_seats_stream(
            &self,
        ) -> Result<crate::stream::Stream<u32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_available_seats_call()?,
            )
        }
        pub fn get_available_seats(&self) -> Result<u32, RpcError> {
            let request = crate::schema::Request::from(self.get_available_seats_call()?);
            let response = self.client.call(request)?;
            <u32>::from_response(response, self.client.clone())
        }
    }
    impl Part {
        pub(crate) fn get_axially_attached_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_get_AxiallyAttached",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_axially_attached_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_axially_attached_call()?,
            )
        }
        pub fn get_axially_attached(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(
                self.get_axially_attached_call()?,
            );
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Part {
        pub(crate) fn get_cargo_bay_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_get_CargoBay",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_cargo_bay_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Option<crate::services::space_center::CargoBay>>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_cargo_bay_call()?)
        }
        pub fn get_cargo_bay(
            &self,
        ) -> Result<Option<crate::services::space_center::CargoBay>, RpcError> {
            let request = crate::schema::Request::from(self.get_cargo_bay_call()?);
            let response = self.client.call(request)?;
            <Option<
                crate::services::space_center::CargoBay,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Part {
        pub(crate) fn get_center_of_mass_reference_frame_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_get_CenterOfMassReferenceFrame",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_center_of_mass_reference_frame_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::ReferenceFrame>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_center_of_mass_reference_frame_call()?,
            )
        }
        pub fn get_center_of_mass_reference_frame(
            &self,
        ) -> Result<crate::services::space_center::ReferenceFrame, RpcError> {
            let request = crate::schema::Request::from(
                self.get_center_of_mass_reference_frame_call()?,
            );
            let response = self.client.call(request)?;
            <crate::services::space_center::ReferenceFrame>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Part {
        pub(crate) fn get_children_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_get_Children",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_children_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Vec<crate::services::space_center::Part>>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_children_call()?)
        }
        pub fn get_children(
            &self,
        ) -> Result<Vec<crate::services::space_center::Part>, RpcError> {
            let request = crate::schema::Request::from(self.get_children_call()?);
            let response = self.client.call(request)?;
            <Vec<
                crate::services::space_center::Part,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Part {
        pub(crate) fn get_control_surface_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_get_ControlSurface",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_control_surface_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Option<crate::services::space_center::ControlSurface>>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_control_surface_call()?,
            )
        }
        pub fn get_control_surface(
            &self,
        ) -> Result<Option<crate::services::space_center::ControlSurface>, RpcError> {
            let request = crate::schema::Request::from(self.get_control_surface_call()?);
            let response = self.client.call(request)?;
            <Option<
                crate::services::space_center::ControlSurface,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Part {
        pub(crate) fn get_cost_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_get_Cost",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_cost_stream(&self) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_cost_call()?)
        }
        pub fn get_cost(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(self.get_cost_call()?);
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Part {
        pub(crate) fn get_crossfeed_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_get_Crossfeed",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_crossfeed_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_crossfeed_call()?)
        }
        pub fn get_crossfeed(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_crossfeed_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Part {
        pub(crate) fn get_decouple_stage_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_get_DecoupleStage",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_decouple_stage_stream(
            &self,
        ) -> Result<crate::stream::Stream<i32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_decouple_stage_call()?,
            )
        }
        pub fn get_decouple_stage(&self) -> Result<i32, RpcError> {
            let request = crate::schema::Request::from(self.get_decouple_stage_call()?);
            let response = self.client.call(request)?;
            <i32>::from_response(response, self.client.clone())
        }
    }
    impl Part {
        pub(crate) fn get_decoupler_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_get_Decoupler",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_decoupler_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Option<crate::services::space_center::Decoupler>>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_decoupler_call()?)
        }
        pub fn get_decoupler(
            &self,
        ) -> Result<Option<crate::services::space_center::Decoupler>, RpcError> {
            let request = crate::schema::Request::from(self.get_decoupler_call()?);
            let response = self.client.call(request)?;
            <Option<
                crate::services::space_center::Decoupler,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Part {
        pub(crate) fn get_docking_port_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_get_DockingPort",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_docking_port_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Option<crate::services::space_center::DockingPort>>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_docking_port_call()?,
            )
        }
        pub fn get_docking_port(
            &self,
        ) -> Result<Option<crate::services::space_center::DockingPort>, RpcError> {
            let request = crate::schema::Request::from(self.get_docking_port_call()?);
            let response = self.client.call(request)?;
            <Option<
                crate::services::space_center::DockingPort,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Part {
        pub(crate) fn get_dry_mass_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_get_DryMass",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_dry_mass_stream(
            &self,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_dry_mass_call()?)
        }
        pub fn get_dry_mass(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(self.get_dry_mass_call()?);
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Part {
        pub(crate) fn get_dynamic_pressure_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_get_DynamicPressure",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_dynamic_pressure_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_dynamic_pressure_call()?,
            )
        }
        pub fn get_dynamic_pressure(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(
                self.get_dynamic_pressure_call()?,
            );
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Part {
        pub(crate) fn get_engine_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_get_Engine",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_engine_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Option<crate::services::space_center::Engine>>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_engine_call()?)
        }
        pub fn get_engine(
            &self,
        ) -> Result<Option<crate::services::space_center::Engine>, RpcError> {
            let request = crate::schema::Request::from(self.get_engine_call()?);
            let response = self.client.call(request)?;
            <Option<
                crate::services::space_center::Engine,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Part {
        pub(crate) fn get_experiment_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_get_Experiment",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_experiment_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Option<crate::services::space_center::Experiment>>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_experiment_call()?)
        }
        pub fn get_experiment(
            &self,
        ) -> Result<Option<crate::services::space_center::Experiment>, RpcError> {
            let request = crate::schema::Request::from(self.get_experiment_call()?);
            let response = self.client.call(request)?;
            <Option<
                crate::services::space_center::Experiment,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Part {
        pub(crate) fn get_experiments_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_get_Experiments",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_experiments_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<
                Option<Vec<crate::services::space_center::Experiment>>,
            >,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_experiments_call()?)
        }
        pub fn get_experiments(
            &self,
        ) -> Result<Option<Vec<crate::services::space_center::Experiment>>, RpcError> {
            let request = crate::schema::Request::from(self.get_experiments_call()?);
            let response = self.client.call(request)?;
            <Option<
                Vec<crate::services::space_center::Experiment>,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Part {
        pub(crate) fn get_fairing_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_get_Fairing",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_fairing_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Option<crate::services::space_center::Fairing>>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_fairing_call()?)
        }
        pub fn get_fairing(
            &self,
        ) -> Result<Option<crate::services::space_center::Fairing>, RpcError> {
            let request = crate::schema::Request::from(self.get_fairing_call()?);
            let response = self.client.call(request)?;
            <Option<
                crate::services::space_center::Fairing,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Part {
        pub(crate) fn get_flag_url_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_get_FlagURL",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_flag_url_stream(
            &self,
        ) -> Result<crate::stream::Stream<String>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_flag_url_call()?)
        }
        pub fn get_flag_url(&self) -> Result<String, RpcError> {
            let request = crate::schema::Request::from(self.get_flag_url_call()?);
            let response = self.client.call(request)?;
            <String>::from_response(response, self.client.clone())
        }
    }
    impl Part {
        pub(crate) fn get_fuel_lines_from_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_get_FuelLinesFrom",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_fuel_lines_from_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Vec<crate::services::space_center::Part>>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_fuel_lines_from_call()?,
            )
        }
        pub fn get_fuel_lines_from(
            &self,
        ) -> Result<Vec<crate::services::space_center::Part>, RpcError> {
            let request = crate::schema::Request::from(self.get_fuel_lines_from_call()?);
            let response = self.client.call(request)?;
            <Vec<
                crate::services::space_center::Part,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Part {
        pub(crate) fn get_fuel_lines_to_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_get_FuelLinesTo",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_fuel_lines_to_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Vec<crate::services::space_center::Part>>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_fuel_lines_to_call()?,
            )
        }
        pub fn get_fuel_lines_to(
            &self,
        ) -> Result<Vec<crate::services::space_center::Part>, RpcError> {
            let request = crate::schema::Request::from(self.get_fuel_lines_to_call()?);
            let response = self.client.call(request)?;
            <Vec<
                crate::services::space_center::Part,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Part {
        pub(crate) fn get_highlight_color_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_get_HighlightColor",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_highlight_color_stream(
            &self,
        ) -> Result<crate::stream::Stream<(f64, f64, f64)>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_highlight_color_call()?,
            )
        }
        pub fn get_highlight_color(&self) -> Result<(f64, f64, f64), RpcError> {
            let request = crate::schema::Request::from(self.get_highlight_color_call()?);
            let response = self.client.call(request)?;
            <(f64, f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl Part {
        pub(crate) fn get_highlighted_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_get_Highlighted",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_highlighted_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_highlighted_call()?)
        }
        pub fn get_highlighted(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_highlighted_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Part {
        pub(crate) fn get_impact_tolerance_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_get_ImpactTolerance",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_impact_tolerance_stream(
            &self,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_impact_tolerance_call()?,
            )
        }
        pub fn get_impact_tolerance(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(
                self.get_impact_tolerance_call()?,
            );
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Part {
        pub(crate) fn get_inertia_tensor_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_get_InertiaTensor",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_inertia_tensor_stream(
            &self,
        ) -> Result<crate::stream::Stream<Vec<f64>>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_inertia_tensor_call()?,
            )
        }
        pub fn get_inertia_tensor(&self) -> Result<Vec<f64>, RpcError> {
            let request = crate::schema::Request::from(self.get_inertia_tensor_call()?);
            let response = self.client.call(request)?;
            <Vec<f64>>::from_response(response, self.client.clone())
        }
    }
    impl Part {
        pub(crate) fn get_intake_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_get_Intake",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_intake_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Option<crate::services::space_center::Intake>>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_intake_call()?)
        }
        pub fn get_intake(
            &self,
        ) -> Result<Option<crate::services::space_center::Intake>, RpcError> {
            let request = crate::schema::Request::from(self.get_intake_call()?);
            let response = self.client.call(request)?;
            <Option<
                crate::services::space_center::Intake,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Part {
        pub(crate) fn get_is_fuel_line_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_get_IsFuelLine",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_is_fuel_line_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_is_fuel_line_call()?,
            )
        }
        pub fn get_is_fuel_line(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_is_fuel_line_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Part {
        pub(crate) fn get_launch_clamp_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_get_LaunchClamp",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_launch_clamp_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Option<crate::services::space_center::LaunchClamp>>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_launch_clamp_call()?,
            )
        }
        pub fn get_launch_clamp(
            &self,
        ) -> Result<Option<crate::services::space_center::LaunchClamp>, RpcError> {
            let request = crate::schema::Request::from(self.get_launch_clamp_call()?);
            let response = self.client.call(request)?;
            <Option<
                crate::services::space_center::LaunchClamp,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Part {
        pub(crate) fn get_leg_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_get_Leg",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_leg_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Option<crate::services::space_center::Leg>>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_leg_call()?)
        }
        pub fn get_leg(
            &self,
        ) -> Result<Option<crate::services::space_center::Leg>, RpcError> {
            let request = crate::schema::Request::from(self.get_leg_call()?);
            let response = self.client.call(request)?;
            <Option<
                crate::services::space_center::Leg,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Part {
        pub(crate) fn get_light_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_get_Light",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_light_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Option<crate::services::space_center::Light>>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_light_call()?)
        }
        pub fn get_light(
            &self,
        ) -> Result<Option<crate::services::space_center::Light>, RpcError> {
            let request = crate::schema::Request::from(self.get_light_call()?);
            let response = self.client.call(request)?;
            <Option<
                crate::services::space_center::Light,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Part {
        pub(crate) fn get_mass_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_get_Mass",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_mass_stream(&self) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_mass_call()?)
        }
        pub fn get_mass(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(self.get_mass_call()?);
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Part {
        pub(crate) fn get_massless_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_get_Massless",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_massless_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_massless_call()?)
        }
        pub fn get_massless(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_massless_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Part {
        pub(crate) fn get_max_skin_temperature_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_get_MaxSkinTemperature",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_max_skin_temperature_stream(
            &self,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_max_skin_temperature_call()?,
            )
        }
        pub fn get_max_skin_temperature(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(
                self.get_max_skin_temperature_call()?,
            );
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Part {
        pub(crate) fn get_max_temperature_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_get_MaxTemperature",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_max_temperature_stream(
            &self,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_max_temperature_call()?,
            )
        }
        pub fn get_max_temperature(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(self.get_max_temperature_call()?);
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Part {
        pub(crate) fn get_modules_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_get_Modules",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_modules_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Vec<crate::services::space_center::Module>>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_modules_call()?)
        }
        pub fn get_modules(
            &self,
        ) -> Result<Vec<crate::services::space_center::Module>, RpcError> {
            let request = crate::schema::Request::from(self.get_modules_call()?);
            let response = self.client.call(request)?;
            <Vec<
                crate::services::space_center::Module,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Part {
        pub(crate) fn get_moment_of_inertia_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_get_MomentOfInertia",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_moment_of_inertia_stream(
            &self,
        ) -> Result<crate::stream::Stream<(f64, f64, f64)>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_moment_of_inertia_call()?,
            )
        }
        pub fn get_moment_of_inertia(&self) -> Result<(f64, f64, f64), RpcError> {
            let request = crate::schema::Request::from(
                self.get_moment_of_inertia_call()?,
            );
            let response = self.client.call(request)?;
            <(f64, f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl Part {
        pub(crate) fn get_name_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_get_Name",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_name_stream(
            &self,
        ) -> Result<crate::stream::Stream<String>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_name_call()?)
        }
        pub fn get_name(&self) -> Result<String, RpcError> {
            let request = crate::schema::Request::from(self.get_name_call()?);
            let response = self.client.call(request)?;
            <String>::from_response(response, self.client.clone())
        }
    }
    impl Part {
        pub(crate) fn get_parachute_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_get_Parachute",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_parachute_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Option<crate::services::space_center::Parachute>>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_parachute_call()?)
        }
        pub fn get_parachute(
            &self,
        ) -> Result<Option<crate::services::space_center::Parachute>, RpcError> {
            let request = crate::schema::Request::from(self.get_parachute_call()?);
            let response = self.client.call(request)?;
            <Option<
                crate::services::space_center::Parachute,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Part {
        pub(crate) fn get_parent_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_get_Parent",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_parent_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Option<crate::services::space_center::Part>>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_parent_call()?)
        }
        pub fn get_parent(
            &self,
        ) -> Result<Option<crate::services::space_center::Part>, RpcError> {
            let request = crate::schema::Request::from(self.get_parent_call()?);
            let response = self.client.call(request)?;
            <Option<
                crate::services::space_center::Part,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Part {
        pub(crate) fn get_rcs_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_get_RCS",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_rcs_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Option<crate::services::space_center::RCS>>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_rcs_call()?)
        }
        pub fn get_rcs(
            &self,
        ) -> Result<Option<crate::services::space_center::RCS>, RpcError> {
            let request = crate::schema::Request::from(self.get_rcs_call()?);
            let response = self.client.call(request)?;
            <Option<
                crate::services::space_center::RCS,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Part {
        pub(crate) fn get_radially_attached_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_get_RadiallyAttached",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_radially_attached_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_radially_attached_call()?,
            )
        }
        pub fn get_radially_attached(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(
                self.get_radially_attached_call()?,
            );
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Part {
        pub(crate) fn get_radiator_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_get_Radiator",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_radiator_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Option<crate::services::space_center::Radiator>>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_radiator_call()?)
        }
        pub fn get_radiator(
            &self,
        ) -> Result<Option<crate::services::space_center::Radiator>, RpcError> {
            let request = crate::schema::Request::from(self.get_radiator_call()?);
            let response = self.client.call(request)?;
            <Option<
                crate::services::space_center::Radiator,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Part {
        pub(crate) fn get_reaction_wheel_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_get_ReactionWheel",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_reaction_wheel_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Option<crate::services::space_center::ReactionWheel>>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_reaction_wheel_call()?,
            )
        }
        pub fn get_reaction_wheel(
            &self,
        ) -> Result<Option<crate::services::space_center::ReactionWheel>, RpcError> {
            let request = crate::schema::Request::from(self.get_reaction_wheel_call()?);
            let response = self.client.call(request)?;
            <Option<
                crate::services::space_center::ReactionWheel,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Part {
        pub(crate) fn get_reference_frame_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_get_ReferenceFrame",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_reference_frame_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::ReferenceFrame>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_reference_frame_call()?,
            )
        }
        pub fn get_reference_frame(
            &self,
        ) -> Result<crate::services::space_center::ReferenceFrame, RpcError> {
            let request = crate::schema::Request::from(self.get_reference_frame_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::ReferenceFrame>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Part {
        pub(crate) fn get_resource_converter_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_get_ResourceConverter",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_resource_converter_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<
                Option<crate::services::space_center::ResourceConverter>,
            >,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_resource_converter_call()?,
            )
        }
        pub fn get_resource_converter(
            &self,
        ) -> Result<Option<crate::services::space_center::ResourceConverter>, RpcError> {
            let request = crate::schema::Request::from(
                self.get_resource_converter_call()?,
            );
            let response = self.client.call(request)?;
            <Option<
                crate::services::space_center::ResourceConverter,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Part {
        pub(crate) fn get_resource_drain_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_get_ResourceDrain",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_resource_drain_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Option<crate::services::space_center::ResourceDrain>>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_resource_drain_call()?,
            )
        }
        pub fn get_resource_drain(
            &self,
        ) -> Result<Option<crate::services::space_center::ResourceDrain>, RpcError> {
            let request = crate::schema::Request::from(self.get_resource_drain_call()?);
            let response = self.client.call(request)?;
            <Option<
                crate::services::space_center::ResourceDrain,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Part {
        pub(crate) fn get_resource_harvester_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_get_ResourceHarvester",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_resource_harvester_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<
                Option<crate::services::space_center::ResourceHarvester>,
            >,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_resource_harvester_call()?,
            )
        }
        pub fn get_resource_harvester(
            &self,
        ) -> Result<Option<crate::services::space_center::ResourceHarvester>, RpcError> {
            let request = crate::schema::Request::from(
                self.get_resource_harvester_call()?,
            );
            let response = self.client.call(request)?;
            <Option<
                crate::services::space_center::ResourceHarvester,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Part {
        pub(crate) fn get_resources_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_get_Resources",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_resources_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::Resources>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_resources_call()?)
        }
        pub fn get_resources(
            &self,
        ) -> Result<crate::services::space_center::Resources, RpcError> {
            let request = crate::schema::Request::from(self.get_resources_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::Resources>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Part {
        pub(crate) fn get_robotic_controller_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_get_RoboticController",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_robotic_controller_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<
                Option<crate::services::space_center::RoboticController>,
            >,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_robotic_controller_call()?,
            )
        }
        pub fn get_robotic_controller(
            &self,
        ) -> Result<Option<crate::services::space_center::RoboticController>, RpcError> {
            let request = crate::schema::Request::from(
                self.get_robotic_controller_call()?,
            );
            let response = self.client.call(request)?;
            <Option<
                crate::services::space_center::RoboticController,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Part {
        pub(crate) fn get_robotic_hinge_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_get_RoboticHinge",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_robotic_hinge_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Option<crate::services::space_center::RoboticHinge>>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_robotic_hinge_call()?,
            )
        }
        pub fn get_robotic_hinge(
            &self,
        ) -> Result<Option<crate::services::space_center::RoboticHinge>, RpcError> {
            let request = crate::schema::Request::from(self.get_robotic_hinge_call()?);
            let response = self.client.call(request)?;
            <Option<
                crate::services::space_center::RoboticHinge,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Part {
        pub(crate) fn get_robotic_piston_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_get_RoboticPiston",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_robotic_piston_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Option<crate::services::space_center::RoboticPiston>>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_robotic_piston_call()?,
            )
        }
        pub fn get_robotic_piston(
            &self,
        ) -> Result<Option<crate::services::space_center::RoboticPiston>, RpcError> {
            let request = crate::schema::Request::from(self.get_robotic_piston_call()?);
            let response = self.client.call(request)?;
            <Option<
                crate::services::space_center::RoboticPiston,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Part {
        pub(crate) fn get_robotic_rotation_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_get_RoboticRotation",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_robotic_rotation_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<
                Option<crate::services::space_center::RoboticRotation>,
            >,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_robotic_rotation_call()?,
            )
        }
        pub fn get_robotic_rotation(
            &self,
        ) -> Result<Option<crate::services::space_center::RoboticRotation>, RpcError> {
            let request = crate::schema::Request::from(
                self.get_robotic_rotation_call()?,
            );
            let response = self.client.call(request)?;
            <Option<
                crate::services::space_center::RoboticRotation,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Part {
        pub(crate) fn get_robotic_rotor_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_get_RoboticRotor",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_robotic_rotor_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Option<crate::services::space_center::RoboticRotor>>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_robotic_rotor_call()?,
            )
        }
        pub fn get_robotic_rotor(
            &self,
        ) -> Result<Option<crate::services::space_center::RoboticRotor>, RpcError> {
            let request = crate::schema::Request::from(self.get_robotic_rotor_call()?);
            let response = self.client.call(request)?;
            <Option<
                crate::services::space_center::RoboticRotor,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Part {
        pub(crate) fn get_sensor_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_get_Sensor",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_sensor_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Option<crate::services::space_center::Sensor>>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_sensor_call()?)
        }
        pub fn get_sensor(
            &self,
        ) -> Result<Option<crate::services::space_center::Sensor>, RpcError> {
            let request = crate::schema::Request::from(self.get_sensor_call()?);
            let response = self.client.call(request)?;
            <Option<
                crate::services::space_center::Sensor,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Part {
        pub(crate) fn get_shielded_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_get_Shielded",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_shielded_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_shielded_call()?)
        }
        pub fn get_shielded(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_shielded_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Part {
        pub(crate) fn get_skin_temperature_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_get_SkinTemperature",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_skin_temperature_stream(
            &self,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_skin_temperature_call()?,
            )
        }
        pub fn get_skin_temperature(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(
                self.get_skin_temperature_call()?,
            );
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Part {
        pub(crate) fn get_solar_panel_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_get_SolarPanel",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_solar_panel_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Option<crate::services::space_center::SolarPanel>>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_solar_panel_call()?)
        }
        pub fn get_solar_panel(
            &self,
        ) -> Result<Option<crate::services::space_center::SolarPanel>, RpcError> {
            let request = crate::schema::Request::from(self.get_solar_panel_call()?);
            let response = self.client.call(request)?;
            <Option<
                crate::services::space_center::SolarPanel,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Part {
        pub(crate) fn get_stage_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_get_Stage",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_stage_stream(&self) -> Result<crate::stream::Stream<i32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_stage_call()?)
        }
        pub fn get_stage(&self) -> Result<i32, RpcError> {
            let request = crate::schema::Request::from(self.get_stage_call()?);
            let response = self.client.call(request)?;
            <i32>::from_response(response, self.client.clone())
        }
    }
    impl Part {
        pub(crate) fn get_tag_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_get_Tag",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_tag_stream(&self) -> Result<crate::stream::Stream<String>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_tag_call()?)
        }
        pub fn get_tag(&self) -> Result<String, RpcError> {
            let request = crate::schema::Request::from(self.get_tag_call()?);
            let response = self.client.call(request)?;
            <String>::from_response(response, self.client.clone())
        }
    }
    impl Part {
        pub(crate) fn get_temperature_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_get_Temperature",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_temperature_stream(
            &self,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_temperature_call()?)
        }
        pub fn get_temperature(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(self.get_temperature_call()?);
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Part {
        pub(crate) fn get_thermal_conduction_flux_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_get_ThermalConductionFlux",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_thermal_conduction_flux_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_thermal_conduction_flux_call()?,
            )
        }
        pub fn get_thermal_conduction_flux(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(
                self.get_thermal_conduction_flux_call()?,
            );
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Part {
        pub(crate) fn get_thermal_convection_flux_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_get_ThermalConvectionFlux",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_thermal_convection_flux_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_thermal_convection_flux_call()?,
            )
        }
        pub fn get_thermal_convection_flux(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(
                self.get_thermal_convection_flux_call()?,
            );
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Part {
        pub(crate) fn get_thermal_internal_flux_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_get_ThermalInternalFlux",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_thermal_internal_flux_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_thermal_internal_flux_call()?,
            )
        }
        pub fn get_thermal_internal_flux(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(
                self.get_thermal_internal_flux_call()?,
            );
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Part {
        pub(crate) fn get_thermal_mass_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_get_ThermalMass",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_thermal_mass_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_thermal_mass_call()?,
            )
        }
        pub fn get_thermal_mass(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_thermal_mass_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Part {
        pub(crate) fn get_thermal_radiation_flux_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_get_ThermalRadiationFlux",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_thermal_radiation_flux_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_thermal_radiation_flux_call()?,
            )
        }
        pub fn get_thermal_radiation_flux(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(
                self.get_thermal_radiation_flux_call()?,
            );
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Part {
        pub(crate) fn get_thermal_resource_mass_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_get_ThermalResourceMass",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_thermal_resource_mass_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_thermal_resource_mass_call()?,
            )
        }
        pub fn get_thermal_resource_mass(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(
                self.get_thermal_resource_mass_call()?,
            );
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Part {
        pub(crate) fn get_thermal_skin_mass_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_get_ThermalSkinMass",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_thermal_skin_mass_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_thermal_skin_mass_call()?,
            )
        }
        pub fn get_thermal_skin_mass(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(
                self.get_thermal_skin_mass_call()?,
            );
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Part {
        pub(crate) fn get_thermal_skin_to_internal_flux_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_get_ThermalSkinToInternalFlux",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_thermal_skin_to_internal_flux_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_thermal_skin_to_internal_flux_call()?,
            )
        }
        pub fn get_thermal_skin_to_internal_flux(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(
                self.get_thermal_skin_to_internal_flux_call()?,
            );
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Part {
        pub(crate) fn get_title_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_get_Title",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_title_stream(
            &self,
        ) -> Result<crate::stream::Stream<String>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_title_call()?)
        }
        pub fn get_title(&self) -> Result<String, RpcError> {
            let request = crate::schema::Request::from(self.get_title_call()?);
            let response = self.client.call(request)?;
            <String>::from_response(response, self.client.clone())
        }
    }
    impl Part {
        pub(crate) fn get_vessel_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_get_Vessel",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_vessel_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::Vessel>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_vessel_call()?)
        }
        pub fn get_vessel(
            &self,
        ) -> Result<crate::services::space_center::Vessel, RpcError> {
            let request = crate::schema::Request::from(self.get_vessel_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::Vessel>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Part {
        pub(crate) fn get_wheel_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_get_Wheel",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_wheel_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Option<crate::services::space_center::Wheel>>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_wheel_call()?)
        }
        pub fn get_wheel(
            &self,
        ) -> Result<Option<crate::services::space_center::Wheel>, RpcError> {
            let request = crate::schema::Request::from(self.get_wheel_call()?);
            let response = self.client.call(request)?;
            <Option<
                crate::services::space_center::Wheel,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Part {
        pub(crate) fn set_flag_url_call(
            &self,
            value: String,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_set_FlagURL",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_flag_url_stream(
            &self,
            value: String,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_flag_url_call(value)?,
            )
        }
        pub fn set_flag_url(&self, value: String) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_flag_url_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Part {
        pub(crate) fn set_glow_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_set_Glow",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_glow_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.set_glow_call(value)?)
        }
        pub fn set_glow(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_glow_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Part {
        pub(crate) fn set_highlight_color_call(
            &self,
            value: (f64, f64, f64),
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_set_HighlightColor",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_highlight_color_stream(
            &self,
            value: (f64, f64, f64),
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_highlight_color_call(value)?,
            )
        }
        pub fn set_highlight_color(
            &self,
            value: (f64, f64, f64),
        ) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_highlight_color_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Part {
        pub(crate) fn set_highlighted_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_set_Highlighted",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_highlighted_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_highlighted_call(value)?,
            )
        }
        pub fn set_highlighted(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_highlighted_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Part {
        pub(crate) fn set_tag_call(
            &self,
            value: String,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Part_set_Tag",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_tag_stream(
            &self,
            value: String,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.set_tag_call(value)?)
        }
        pub fn set_tag(&self, value: String) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_tag_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Parts {
        pub(crate) fn in_decouple_stage_call(
            &self,
            stage: i32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Parts_InDecoupleStage",
                    vec![
                        self.to_argument(0usize as u32) ?, stage.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn in_decouple_stage_stream(
            &self,
            stage: i32,
        ) -> Result<
            crate::stream::Stream<Vec<crate::services::space_center::Part>>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.in_decouple_stage_call(stage)?,
            )
        }
        pub fn in_decouple_stage(
            &self,
            stage: i32,
        ) -> Result<Vec<crate::services::space_center::Part>, RpcError> {
            let request = crate::schema::Request::from(
                self.in_decouple_stage_call(stage)?,
            );
            let response = self.client.call(request)?;
            <Vec<
                crate::services::space_center::Part,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Parts {
        pub(crate) fn in_stage_call(
            &self,
            stage: i32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Parts_InStage",
                    vec![
                        self.to_argument(0usize as u32) ?, stage.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn in_stage_stream(
            &self,
            stage: i32,
        ) -> Result<
            crate::stream::Stream<Vec<crate::services::space_center::Part>>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.in_stage_call(stage)?)
        }
        pub fn in_stage(
            &self,
            stage: i32,
        ) -> Result<Vec<crate::services::space_center::Part>, RpcError> {
            let request = crate::schema::Request::from(self.in_stage_call(stage)?);
            let response = self.client.call(request)?;
            <Vec<
                crate::services::space_center::Part,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Parts {
        pub(crate) fn modules_with_name_call(
            &self,
            module_name: String,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Parts_ModulesWithName",
                    vec![
                        self.to_argument(0usize as u32) ?, module_name.to_argument(1usize
                        as u32) ?
                    ],
                ),
            )
        }
        pub fn modules_with_name_stream(
            &self,
            module_name: String,
        ) -> Result<
            crate::stream::Stream<Vec<crate::services::space_center::Module>>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.modules_with_name_call(module_name)?,
            )
        }
        pub fn modules_with_name(
            &self,
            module_name: String,
        ) -> Result<Vec<crate::services::space_center::Module>, RpcError> {
            let request = crate::schema::Request::from(
                self.modules_with_name_call(module_name)?,
            );
            let response = self.client.call(request)?;
            <Vec<
                crate::services::space_center::Module,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Parts {
        pub(crate) fn with_module_call(
            &self,
            module_name: String,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Parts_WithModule",
                    vec![
                        self.to_argument(0usize as u32) ?, module_name.to_argument(1usize
                        as u32) ?
                    ],
                ),
            )
        }
        pub fn with_module_stream(
            &self,
            module_name: String,
        ) -> Result<
            crate::stream::Stream<Vec<crate::services::space_center::Part>>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.with_module_call(module_name)?,
            )
        }
        pub fn with_module(
            &self,
            module_name: String,
        ) -> Result<Vec<crate::services::space_center::Part>, RpcError> {
            let request = crate::schema::Request::from(
                self.with_module_call(module_name)?,
            );
            let response = self.client.call(request)?;
            <Vec<
                crate::services::space_center::Part,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Parts {
        pub(crate) fn with_name_call(
            &self,
            name: String,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Parts_WithName",
                    vec![
                        self.to_argument(0usize as u32) ?, name.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn with_name_stream(
            &self,
            name: String,
        ) -> Result<
            crate::stream::Stream<Vec<crate::services::space_center::Part>>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.with_name_call(name)?)
        }
        pub fn with_name(
            &self,
            name: String,
        ) -> Result<Vec<crate::services::space_center::Part>, RpcError> {
            let request = crate::schema::Request::from(self.with_name_call(name)?);
            let response = self.client.call(request)?;
            <Vec<
                crate::services::space_center::Part,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Parts {
        pub(crate) fn with_tag_call(
            &self,
            tag: String,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Parts_WithTag",
                    vec![
                        self.to_argument(0usize as u32) ?, tag.to_argument(1usize as u32)
                        ?
                    ],
                ),
            )
        }
        pub fn with_tag_stream(
            &self,
            tag: String,
        ) -> Result<
            crate::stream::Stream<Vec<crate::services::space_center::Part>>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.with_tag_call(tag)?)
        }
        pub fn with_tag(
            &self,
            tag: String,
        ) -> Result<Vec<crate::services::space_center::Part>, RpcError> {
            let request = crate::schema::Request::from(self.with_tag_call(tag)?);
            let response = self.client.call(request)?;
            <Vec<
                crate::services::space_center::Part,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Parts {
        pub(crate) fn with_title_call(
            &self,
            title: String,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Parts_WithTitle",
                    vec![
                        self.to_argument(0usize as u32) ?, title.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn with_title_stream(
            &self,
            title: String,
        ) -> Result<
            crate::stream::Stream<Vec<crate::services::space_center::Part>>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.with_title_call(title)?)
        }
        pub fn with_title(
            &self,
            title: String,
        ) -> Result<Vec<crate::services::space_center::Part>, RpcError> {
            let request = crate::schema::Request::from(self.with_title_call(title)?);
            let response = self.client.call(request)?;
            <Vec<
                crate::services::space_center::Part,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Parts {
        pub(crate) fn get_all_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Parts_get_All",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_all_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Vec<crate::services::space_center::Part>>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_all_call()?)
        }
        pub fn get_all(
            &self,
        ) -> Result<Vec<crate::services::space_center::Part>, RpcError> {
            let request = crate::schema::Request::from(self.get_all_call()?);
            let response = self.client.call(request)?;
            <Vec<
                crate::services::space_center::Part,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Parts {
        pub(crate) fn get_antennas_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Parts_get_Antennas",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_antennas_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Vec<crate::services::space_center::Antenna>>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_antennas_call()?)
        }
        pub fn get_antennas(
            &self,
        ) -> Result<Vec<crate::services::space_center::Antenna>, RpcError> {
            let request = crate::schema::Request::from(self.get_antennas_call()?);
            let response = self.client.call(request)?;
            <Vec<
                crate::services::space_center::Antenna,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Parts {
        pub(crate) fn get_cargo_bays_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Parts_get_CargoBays",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_cargo_bays_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Vec<crate::services::space_center::CargoBay>>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_cargo_bays_call()?)
        }
        pub fn get_cargo_bays(
            &self,
        ) -> Result<Vec<crate::services::space_center::CargoBay>, RpcError> {
            let request = crate::schema::Request::from(self.get_cargo_bays_call()?);
            let response = self.client.call(request)?;
            <Vec<
                crate::services::space_center::CargoBay,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Parts {
        pub(crate) fn get_control_surfaces_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Parts_get_ControlSurfaces",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_control_surfaces_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Vec<crate::services::space_center::ControlSurface>>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_control_surfaces_call()?,
            )
        }
        pub fn get_control_surfaces(
            &self,
        ) -> Result<Vec<crate::services::space_center::ControlSurface>, RpcError> {
            let request = crate::schema::Request::from(
                self.get_control_surfaces_call()?,
            );
            let response = self.client.call(request)?;
            <Vec<
                crate::services::space_center::ControlSurface,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Parts {
        pub(crate) fn get_controlling_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Parts_get_Controlling",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_controlling_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::Part>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_controlling_call()?)
        }
        pub fn get_controlling(
            &self,
        ) -> Result<crate::services::space_center::Part, RpcError> {
            let request = crate::schema::Request::from(self.get_controlling_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::Part>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Parts {
        pub(crate) fn get_decouplers_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Parts_get_Decouplers",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_decouplers_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Vec<crate::services::space_center::Decoupler>>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_decouplers_call()?)
        }
        pub fn get_decouplers(
            &self,
        ) -> Result<Vec<crate::services::space_center::Decoupler>, RpcError> {
            let request = crate::schema::Request::from(self.get_decouplers_call()?);
            let response = self.client.call(request)?;
            <Vec<
                crate::services::space_center::Decoupler,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Parts {
        pub(crate) fn get_docking_ports_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Parts_get_DockingPorts",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_docking_ports_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Vec<crate::services::space_center::DockingPort>>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_docking_ports_call()?,
            )
        }
        pub fn get_docking_ports(
            &self,
        ) -> Result<Vec<crate::services::space_center::DockingPort>, RpcError> {
            let request = crate::schema::Request::from(self.get_docking_ports_call()?);
            let response = self.client.call(request)?;
            <Vec<
                crate::services::space_center::DockingPort,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Parts {
        pub(crate) fn get_engines_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Parts_get_Engines",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_engines_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Vec<crate::services::space_center::Engine>>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_engines_call()?)
        }
        pub fn get_engines(
            &self,
        ) -> Result<Vec<crate::services::space_center::Engine>, RpcError> {
            let request = crate::schema::Request::from(self.get_engines_call()?);
            let response = self.client.call(request)?;
            <Vec<
                crate::services::space_center::Engine,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Parts {
        pub(crate) fn get_experiments_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Parts_get_Experiments",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_experiments_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Vec<crate::services::space_center::Experiment>>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_experiments_call()?)
        }
        pub fn get_experiments(
            &self,
        ) -> Result<Vec<crate::services::space_center::Experiment>, RpcError> {
            let request = crate::schema::Request::from(self.get_experiments_call()?);
            let response = self.client.call(request)?;
            <Vec<
                crate::services::space_center::Experiment,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Parts {
        pub(crate) fn get_fairings_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Parts_get_Fairings",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_fairings_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Vec<crate::services::space_center::Fairing>>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_fairings_call()?)
        }
        pub fn get_fairings(
            &self,
        ) -> Result<Vec<crate::services::space_center::Fairing>, RpcError> {
            let request = crate::schema::Request::from(self.get_fairings_call()?);
            let response = self.client.call(request)?;
            <Vec<
                crate::services::space_center::Fairing,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Parts {
        pub(crate) fn get_intakes_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Parts_get_Intakes",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_intakes_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Vec<crate::services::space_center::Intake>>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_intakes_call()?)
        }
        pub fn get_intakes(
            &self,
        ) -> Result<Vec<crate::services::space_center::Intake>, RpcError> {
            let request = crate::schema::Request::from(self.get_intakes_call()?);
            let response = self.client.call(request)?;
            <Vec<
                crate::services::space_center::Intake,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Parts {
        pub(crate) fn get_launch_clamps_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Parts_get_LaunchClamps",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_launch_clamps_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Vec<crate::services::space_center::LaunchClamp>>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_launch_clamps_call()?,
            )
        }
        pub fn get_launch_clamps(
            &self,
        ) -> Result<Vec<crate::services::space_center::LaunchClamp>, RpcError> {
            let request = crate::schema::Request::from(self.get_launch_clamps_call()?);
            let response = self.client.call(request)?;
            <Vec<
                crate::services::space_center::LaunchClamp,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Parts {
        pub(crate) fn get_legs_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Parts_get_Legs",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_legs_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Vec<crate::services::space_center::Leg>>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_legs_call()?)
        }
        pub fn get_legs(
            &self,
        ) -> Result<Vec<crate::services::space_center::Leg>, RpcError> {
            let request = crate::schema::Request::from(self.get_legs_call()?);
            let response = self.client.call(request)?;
            <Vec<
                crate::services::space_center::Leg,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Parts {
        pub(crate) fn get_lights_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Parts_get_Lights",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_lights_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Vec<crate::services::space_center::Light>>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_lights_call()?)
        }
        pub fn get_lights(
            &self,
        ) -> Result<Vec<crate::services::space_center::Light>, RpcError> {
            let request = crate::schema::Request::from(self.get_lights_call()?);
            let response = self.client.call(request)?;
            <Vec<
                crate::services::space_center::Light,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Parts {
        pub(crate) fn get_parachutes_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Parts_get_Parachutes",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_parachutes_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Vec<crate::services::space_center::Parachute>>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_parachutes_call()?)
        }
        pub fn get_parachutes(
            &self,
        ) -> Result<Vec<crate::services::space_center::Parachute>, RpcError> {
            let request = crate::schema::Request::from(self.get_parachutes_call()?);
            let response = self.client.call(request)?;
            <Vec<
                crate::services::space_center::Parachute,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Parts {
        pub(crate) fn get_rcs_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Parts_get_RCS",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_rcs_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Vec<crate::services::space_center::RCS>>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_rcs_call()?)
        }
        pub fn get_rcs(
            &self,
        ) -> Result<Vec<crate::services::space_center::RCS>, RpcError> {
            let request = crate::schema::Request::from(self.get_rcs_call()?);
            let response = self.client.call(request)?;
            <Vec<
                crate::services::space_center::RCS,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Parts {
        pub(crate) fn get_radiators_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Parts_get_Radiators",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_radiators_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Vec<crate::services::space_center::Radiator>>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_radiators_call()?)
        }
        pub fn get_radiators(
            &self,
        ) -> Result<Vec<crate::services::space_center::Radiator>, RpcError> {
            let request = crate::schema::Request::from(self.get_radiators_call()?);
            let response = self.client.call(request)?;
            <Vec<
                crate::services::space_center::Radiator,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Parts {
        pub(crate) fn get_reaction_wheels_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Parts_get_ReactionWheels",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_reaction_wheels_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Vec<crate::services::space_center::ReactionWheel>>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_reaction_wheels_call()?,
            )
        }
        pub fn get_reaction_wheels(
            &self,
        ) -> Result<Vec<crate::services::space_center::ReactionWheel>, RpcError> {
            let request = crate::schema::Request::from(self.get_reaction_wheels_call()?);
            let response = self.client.call(request)?;
            <Vec<
                crate::services::space_center::ReactionWheel,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Parts {
        pub(crate) fn get_resource_converters_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Parts_get_ResourceConverters",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_resource_converters_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Vec<crate::services::space_center::ResourceConverter>>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_resource_converters_call()?,
            )
        }
        pub fn get_resource_converters(
            &self,
        ) -> Result<Vec<crate::services::space_center::ResourceConverter>, RpcError> {
            let request = crate::schema::Request::from(
                self.get_resource_converters_call()?,
            );
            let response = self.client.call(request)?;
            <Vec<
                crate::services::space_center::ResourceConverter,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Parts {
        pub(crate) fn get_resource_drains_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Parts_get_ResourceDrains",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_resource_drains_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Vec<crate::services::space_center::ResourceDrain>>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_resource_drains_call()?,
            )
        }
        pub fn get_resource_drains(
            &self,
        ) -> Result<Vec<crate::services::space_center::ResourceDrain>, RpcError> {
            let request = crate::schema::Request::from(self.get_resource_drains_call()?);
            let response = self.client.call(request)?;
            <Vec<
                crate::services::space_center::ResourceDrain,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Parts {
        pub(crate) fn get_resource_harvesters_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Parts_get_ResourceHarvesters",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_resource_harvesters_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Vec<crate::services::space_center::ResourceHarvester>>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_resource_harvesters_call()?,
            )
        }
        pub fn get_resource_harvesters(
            &self,
        ) -> Result<Vec<crate::services::space_center::ResourceHarvester>, RpcError> {
            let request = crate::schema::Request::from(
                self.get_resource_harvesters_call()?,
            );
            let response = self.client.call(request)?;
            <Vec<
                crate::services::space_center::ResourceHarvester,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Parts {
        pub(crate) fn get_robotic_hinges_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Parts_get_RoboticHinges",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_robotic_hinges_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Vec<crate::services::space_center::RoboticHinge>>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_robotic_hinges_call()?,
            )
        }
        pub fn get_robotic_hinges(
            &self,
        ) -> Result<Vec<crate::services::space_center::RoboticHinge>, RpcError> {
            let request = crate::schema::Request::from(self.get_robotic_hinges_call()?);
            let response = self.client.call(request)?;
            <Vec<
                crate::services::space_center::RoboticHinge,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Parts {
        pub(crate) fn get_robotic_pistons_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Parts_get_RoboticPistons",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_robotic_pistons_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Vec<crate::services::space_center::RoboticPiston>>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_robotic_pistons_call()?,
            )
        }
        pub fn get_robotic_pistons(
            &self,
        ) -> Result<Vec<crate::services::space_center::RoboticPiston>, RpcError> {
            let request = crate::schema::Request::from(self.get_robotic_pistons_call()?);
            let response = self.client.call(request)?;
            <Vec<
                crate::services::space_center::RoboticPiston,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Parts {
        pub(crate) fn get_robotic_rotations_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Parts_get_RoboticRotations",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_robotic_rotations_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Vec<crate::services::space_center::RoboticRotation>>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_robotic_rotations_call()?,
            )
        }
        pub fn get_robotic_rotations(
            &self,
        ) -> Result<Vec<crate::services::space_center::RoboticRotation>, RpcError> {
            let request = crate::schema::Request::from(
                self.get_robotic_rotations_call()?,
            );
            let response = self.client.call(request)?;
            <Vec<
                crate::services::space_center::RoboticRotation,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Parts {
        pub(crate) fn get_robotic_rotors_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Parts_get_RoboticRotors",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_robotic_rotors_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Vec<crate::services::space_center::RoboticRotor>>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_robotic_rotors_call()?,
            )
        }
        pub fn get_robotic_rotors(
            &self,
        ) -> Result<Vec<crate::services::space_center::RoboticRotor>, RpcError> {
            let request = crate::schema::Request::from(self.get_robotic_rotors_call()?);
            let response = self.client.call(request)?;
            <Vec<
                crate::services::space_center::RoboticRotor,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Parts {
        pub(crate) fn get_root_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Parts_get_Root",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_root_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::Part>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_root_call()?)
        }
        pub fn get_root(&self) -> Result<crate::services::space_center::Part, RpcError> {
            let request = crate::schema::Request::from(self.get_root_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::Part>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Parts {
        pub(crate) fn get_sensors_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Parts_get_Sensors",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_sensors_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Vec<crate::services::space_center::Sensor>>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_sensors_call()?)
        }
        pub fn get_sensors(
            &self,
        ) -> Result<Vec<crate::services::space_center::Sensor>, RpcError> {
            let request = crate::schema::Request::from(self.get_sensors_call()?);
            let response = self.client.call(request)?;
            <Vec<
                crate::services::space_center::Sensor,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Parts {
        pub(crate) fn get_solar_panels_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Parts_get_SolarPanels",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_solar_panels_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Vec<crate::services::space_center::SolarPanel>>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_solar_panels_call()?,
            )
        }
        pub fn get_solar_panels(
            &self,
        ) -> Result<Vec<crate::services::space_center::SolarPanel>, RpcError> {
            let request = crate::schema::Request::from(self.get_solar_panels_call()?);
            let response = self.client.call(request)?;
            <Vec<
                crate::services::space_center::SolarPanel,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Parts {
        pub(crate) fn get_wheels_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Parts_get_Wheels",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_wheels_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Vec<crate::services::space_center::Wheel>>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_wheels_call()?)
        }
        pub fn get_wheels(
            &self,
        ) -> Result<Vec<crate::services::space_center::Wheel>, RpcError> {
            let request = crate::schema::Request::from(self.get_wheels_call()?);
            let response = self.client.call(request)?;
            <Vec<
                crate::services::space_center::Wheel,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Parts {
        pub(crate) fn set_controlling_call(
            &self,
            value: &crate::services::space_center::Part,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Parts_set_Controlling",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_controlling_stream(
            &self,
            value: &crate::services::space_center::Part,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_controlling_call(value)?,
            )
        }
        pub fn set_controlling(
            &self,
            value: &crate::services::space_center::Part,
        ) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_controlling_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Propellant {
        pub(crate) fn get_current_amount_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Propellant_get_CurrentAmount",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_current_amount_stream(
            &self,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_current_amount_call()?,
            )
        }
        pub fn get_current_amount(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(self.get_current_amount_call()?);
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Propellant {
        pub(crate) fn get_current_requirement_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Propellant_get_CurrentRequirement",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_current_requirement_stream(
            &self,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_current_requirement_call()?,
            )
        }
        pub fn get_current_requirement(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(
                self.get_current_requirement_call()?,
            );
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Propellant {
        pub(crate) fn get_draw_stack_gauge_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Propellant_get_DrawStackGauge",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_draw_stack_gauge_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_draw_stack_gauge_call()?,
            )
        }
        pub fn get_draw_stack_gauge(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(
                self.get_draw_stack_gauge_call()?,
            );
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Propellant {
        pub(crate) fn get_ignore_for_isp_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Propellant_get_IgnoreForIsp",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_ignore_for_isp_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_ignore_for_isp_call()?,
            )
        }
        pub fn get_ignore_for_isp(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_ignore_for_isp_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Propellant {
        pub(crate) fn get_ignore_for_thrust_curve_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Propellant_get_IgnoreForThrustCurve",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_ignore_for_thrust_curve_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_ignore_for_thrust_curve_call()?,
            )
        }
        pub fn get_ignore_for_thrust_curve(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(
                self.get_ignore_for_thrust_curve_call()?,
            );
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Propellant {
        pub(crate) fn get_is_deprived_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Propellant_get_IsDeprived",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_is_deprived_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_is_deprived_call()?)
        }
        pub fn get_is_deprived(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_is_deprived_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Propellant {
        pub(crate) fn get_name_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Propellant_get_Name",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_name_stream(
            &self,
        ) -> Result<crate::stream::Stream<String>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_name_call()?)
        }
        pub fn get_name(&self) -> Result<String, RpcError> {
            let request = crate::schema::Request::from(self.get_name_call()?);
            let response = self.client.call(request)?;
            <String>::from_response(response, self.client.clone())
        }
    }
    impl Propellant {
        pub(crate) fn get_ratio_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Propellant_get_Ratio",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_ratio_stream(&self) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_ratio_call()?)
        }
        pub fn get_ratio(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_ratio_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Propellant {
        pub(crate) fn get_total_resource_available_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Propellant_get_TotalResourceAvailable",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_total_resource_available_stream(
            &self,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_total_resource_available_call()?,
            )
        }
        pub fn get_total_resource_available(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(
                self.get_total_resource_available_call()?,
            );
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Propellant {
        pub(crate) fn get_total_resource_capacity_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Propellant_get_TotalResourceCapacity",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_total_resource_capacity_stream(
            &self,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_total_resource_capacity_call()?,
            )
        }
        pub fn get_total_resource_capacity(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(
                self.get_total_resource_capacity_call()?,
            );
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl SpaceCenter {
        pub(crate) fn quickload_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(crate::client::Client::proc_call("SpaceCenter", "Quickload", vec![]))
        }
        pub fn quickload_stream(&self) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.quickload_call()?)
        }
        pub fn quickload(&self) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.quickload_call()?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl SpaceCenter {
        pub(crate) fn quicksave_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(crate::client::Client::proc_call("SpaceCenter", "Quicksave", vec![]))
        }
        pub fn quicksave_stream(&self) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.quicksave_call()?)
        }
        pub fn quicksave(&self) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.quicksave_call()?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl RCS {
        pub(crate) fn get_active_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RCS_get_Active",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_active_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_active_call()?)
        }
        pub fn get_active(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_active_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl RCS {
        pub(crate) fn get_available_force_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RCS_get_AvailableForce",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_available_force_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<((f64, f64, f64), (f64, f64, f64))>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_available_force_call()?,
            )
        }
        pub fn get_available_force(
            &self,
        ) -> Result<((f64, f64, f64), (f64, f64, f64)), RpcError> {
            let request = crate::schema::Request::from(self.get_available_force_call()?);
            let response = self.client.call(request)?;
            <(
                (f64, f64, f64),
                (f64, f64, f64),
            )>::from_response(response, self.client.clone())
        }
    }
    impl RCS {
        pub(crate) fn get_available_thrust_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RCS_get_AvailableThrust",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_available_thrust_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_available_thrust_call()?,
            )
        }
        pub fn get_available_thrust(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(
                self.get_available_thrust_call()?,
            );
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl RCS {
        pub(crate) fn get_available_torque_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RCS_get_AvailableTorque",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_available_torque_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<((f64, f64, f64), (f64, f64, f64))>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_available_torque_call()?,
            )
        }
        pub fn get_available_torque(
            &self,
        ) -> Result<((f64, f64, f64), (f64, f64, f64)), RpcError> {
            let request = crate::schema::Request::from(
                self.get_available_torque_call()?,
            );
            let response = self.client.call(request)?;
            <(
                (f64, f64, f64),
                (f64, f64, f64),
            )>::from_response(response, self.client.clone())
        }
    }
    impl RCS {
        pub(crate) fn get_enabled_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RCS_get_Enabled",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_enabled_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_enabled_call()?)
        }
        pub fn get_enabled(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_enabled_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl RCS {
        pub(crate) fn get_forward_enabled_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RCS_get_ForwardEnabled",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_forward_enabled_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_forward_enabled_call()?,
            )
        }
        pub fn get_forward_enabled(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_forward_enabled_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl RCS {
        pub(crate) fn get_has_fuel_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RCS_get_HasFuel",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_has_fuel_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_has_fuel_call()?)
        }
        pub fn get_has_fuel(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_has_fuel_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl RCS {
        pub(crate) fn get_kerbin_sea_level_specific_impulse_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RCS_get_KerbinSeaLevelSpecificImpulse",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_kerbin_sea_level_specific_impulse_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_kerbin_sea_level_specific_impulse_call()?,
            )
        }
        pub fn get_kerbin_sea_level_specific_impulse(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(
                self.get_kerbin_sea_level_specific_impulse_call()?,
            );
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl RCS {
        pub(crate) fn get_max_thrust_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RCS_get_MaxThrust",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_max_thrust_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_max_thrust_call()?)
        }
        pub fn get_max_thrust(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_max_thrust_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl RCS {
        pub(crate) fn get_max_vacuum_thrust_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RCS_get_MaxVacuumThrust",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_max_vacuum_thrust_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_max_vacuum_thrust_call()?,
            )
        }
        pub fn get_max_vacuum_thrust(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(
                self.get_max_vacuum_thrust_call()?,
            );
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl RCS {
        pub(crate) fn get_part_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RCS_get_Part",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_part_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::Part>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_part_call()?)
        }
        pub fn get_part(&self) -> Result<crate::services::space_center::Part, RpcError> {
            let request = crate::schema::Request::from(self.get_part_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::Part>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl RCS {
        pub(crate) fn get_pitch_enabled_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RCS_get_PitchEnabled",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_pitch_enabled_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_pitch_enabled_call()?,
            )
        }
        pub fn get_pitch_enabled(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_pitch_enabled_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl RCS {
        pub(crate) fn get_propellant_ratios_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RCS_get_PropellantRatios",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_propellant_ratios_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<std::collections::HashMap<String, f32>>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_propellant_ratios_call()?,
            )
        }
        pub fn get_propellant_ratios(
            &self,
        ) -> Result<std::collections::HashMap<String, f32>, RpcError> {
            let request = crate::schema::Request::from(
                self.get_propellant_ratios_call()?,
            );
            let response = self.client.call(request)?;
            <std::collections::HashMap<
                String,
                f32,
            >>::from_response(response, self.client.clone())
        }
    }
    impl RCS {
        pub(crate) fn get_propellants_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RCS_get_Propellants",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_propellants_stream(
            &self,
        ) -> Result<crate::stream::Stream<Vec<String>>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_propellants_call()?)
        }
        pub fn get_propellants(&self) -> Result<Vec<String>, RpcError> {
            let request = crate::schema::Request::from(self.get_propellants_call()?);
            let response = self.client.call(request)?;
            <Vec<String>>::from_response(response, self.client.clone())
        }
    }
    impl RCS {
        pub(crate) fn get_right_enabled_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RCS_get_RightEnabled",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_right_enabled_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_right_enabled_call()?,
            )
        }
        pub fn get_right_enabled(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_right_enabled_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl RCS {
        pub(crate) fn get_roll_enabled_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RCS_get_RollEnabled",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_roll_enabled_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_roll_enabled_call()?,
            )
        }
        pub fn get_roll_enabled(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_roll_enabled_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl RCS {
        pub(crate) fn get_specific_impulse_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RCS_get_SpecificImpulse",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_specific_impulse_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_specific_impulse_call()?,
            )
        }
        pub fn get_specific_impulse(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(
                self.get_specific_impulse_call()?,
            );
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl RCS {
        pub(crate) fn get_thrust_limit_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RCS_get_ThrustLimit",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_thrust_limit_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_thrust_limit_call()?,
            )
        }
        pub fn get_thrust_limit(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_thrust_limit_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl RCS {
        pub(crate) fn get_thrusters_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RCS_get_Thrusters",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_thrusters_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Vec<crate::services::space_center::Thruster>>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_thrusters_call()?)
        }
        pub fn get_thrusters(
            &self,
        ) -> Result<Vec<crate::services::space_center::Thruster>, RpcError> {
            let request = crate::schema::Request::from(self.get_thrusters_call()?);
            let response = self.client.call(request)?;
            <Vec<
                crate::services::space_center::Thruster,
            >>::from_response(response, self.client.clone())
        }
    }
    impl RCS {
        pub(crate) fn get_up_enabled_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RCS_get_UpEnabled",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_up_enabled_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_up_enabled_call()?)
        }
        pub fn get_up_enabled(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_up_enabled_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl RCS {
        pub(crate) fn get_vacuum_specific_impulse_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RCS_get_VacuumSpecificImpulse",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_vacuum_specific_impulse_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_vacuum_specific_impulse_call()?,
            )
        }
        pub fn get_vacuum_specific_impulse(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(
                self.get_vacuum_specific_impulse_call()?,
            );
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl RCS {
        pub(crate) fn get_yaw_enabled_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RCS_get_YawEnabled",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_yaw_enabled_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_yaw_enabled_call()?)
        }
        pub fn get_yaw_enabled(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_yaw_enabled_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl RCS {
        pub(crate) fn set_enabled_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RCS_set_Enabled",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_enabled_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_enabled_call(value)?,
            )
        }
        pub fn set_enabled(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_enabled_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl RCS {
        pub(crate) fn set_forward_enabled_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RCS_set_ForwardEnabled",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_forward_enabled_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_forward_enabled_call(value)?,
            )
        }
        pub fn set_forward_enabled(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_forward_enabled_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl RCS {
        pub(crate) fn set_pitch_enabled_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RCS_set_PitchEnabled",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_pitch_enabled_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_pitch_enabled_call(value)?,
            )
        }
        pub fn set_pitch_enabled(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_pitch_enabled_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl RCS {
        pub(crate) fn set_right_enabled_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RCS_set_RightEnabled",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_right_enabled_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_right_enabled_call(value)?,
            )
        }
        pub fn set_right_enabled(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_right_enabled_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl RCS {
        pub(crate) fn set_roll_enabled_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RCS_set_RollEnabled",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_roll_enabled_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_roll_enabled_call(value)?,
            )
        }
        pub fn set_roll_enabled(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_roll_enabled_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl RCS {
        pub(crate) fn set_thrust_limit_call(
            &self,
            value: f32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RCS_set_ThrustLimit",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_thrust_limit_stream(
            &self,
            value: f32,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_thrust_limit_call(value)?,
            )
        }
        pub fn set_thrust_limit(&self, value: f32) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_thrust_limit_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl RCS {
        pub(crate) fn set_up_enabled_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RCS_set_UpEnabled",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_up_enabled_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_up_enabled_call(value)?,
            )
        }
        pub fn set_up_enabled(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_up_enabled_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl RCS {
        pub(crate) fn set_yaw_enabled_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RCS_set_YawEnabled",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_yaw_enabled_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_yaw_enabled_call(value)?,
            )
        }
        pub fn set_yaw_enabled(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_yaw_enabled_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Radiator {
        pub(crate) fn get_deployable_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Radiator_get_Deployable",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_deployable_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_deployable_call()?)
        }
        pub fn get_deployable(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_deployable_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Radiator {
        pub(crate) fn get_deployed_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Radiator_get_Deployed",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_deployed_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_deployed_call()?)
        }
        pub fn get_deployed(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_deployed_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Radiator {
        pub(crate) fn get_part_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Radiator_get_Part",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_part_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::Part>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_part_call()?)
        }
        pub fn get_part(&self) -> Result<crate::services::space_center::Part, RpcError> {
            let request = crate::schema::Request::from(self.get_part_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::Part>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Radiator {
        pub(crate) fn get_state_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Radiator_get_State",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_state_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::RadiatorState>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_state_call()?)
        }
        pub fn get_state(
            &self,
        ) -> Result<crate::services::space_center::RadiatorState, RpcError> {
            let request = crate::schema::Request::from(self.get_state_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::RadiatorState>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Radiator {
        pub(crate) fn set_deployed_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Radiator_set_Deployed",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_deployed_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_deployed_call(value)?,
            )
        }
        pub fn set_deployed(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_deployed_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl SpaceCenter {
        pub(crate) fn raycast_distance_call(
            &self,
            position: (f64, f64, f64),
            direction: (f64, f64, f64),
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RaycastDistance",
                    vec![
                        position.to_argument(0usize as u32) ?, direction
                        .to_argument(1usize as u32) ?, reference_frame.to_argument(2usize
                        as u32) ?
                    ],
                ),
            )
        }
        pub fn raycast_distance_stream(
            &self,
            position: (f64, f64, f64),
            direction: (f64, f64, f64),
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.raycast_distance_call(position, direction, reference_frame)?,
            )
        }
        pub fn raycast_distance(
            &self,
            position: (f64, f64, f64),
            direction: (f64, f64, f64),
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(
                self.raycast_distance_call(position, direction, reference_frame)?,
            );
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl SpaceCenter {
        pub(crate) fn raycast_part_call(
            &self,
            position: (f64, f64, f64),
            direction: (f64, f64, f64),
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RaycastPart",
                    vec![
                        position.to_argument(0usize as u32) ?, direction
                        .to_argument(1usize as u32) ?, reference_frame.to_argument(2usize
                        as u32) ?
                    ],
                ),
            )
        }
        pub fn raycast_part_stream(
            &self,
            position: (f64, f64, f64),
            direction: (f64, f64, f64),
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<
            crate::stream::Stream<Option<crate::services::space_center::Part>>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.raycast_part_call(position, direction, reference_frame)?,
            )
        }
        pub fn raycast_part(
            &self,
            position: (f64, f64, f64),
            direction: (f64, f64, f64),
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<Option<crate::services::space_center::Part>, RpcError> {
            let request = crate::schema::Request::from(
                self.raycast_part_call(position, direction, reference_frame)?,
            );
            let response = self.client.call(request)?;
            <Option<
                crate::services::space_center::Part,
            >>::from_response(response, self.client.clone())
        }
    }
    impl ReactionWheel {
        pub(crate) fn get_active_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ReactionWheel_get_Active",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_active_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_active_call()?)
        }
        pub fn get_active(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_active_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl ReactionWheel {
        pub(crate) fn get_available_torque_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ReactionWheel_get_AvailableTorque",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_available_torque_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<((f64, f64, f64), (f64, f64, f64))>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_available_torque_call()?,
            )
        }
        pub fn get_available_torque(
            &self,
        ) -> Result<((f64, f64, f64), (f64, f64, f64)), RpcError> {
            let request = crate::schema::Request::from(
                self.get_available_torque_call()?,
            );
            let response = self.client.call(request)?;
            <(
                (f64, f64, f64),
                (f64, f64, f64),
            )>::from_response(response, self.client.clone())
        }
    }
    impl ReactionWheel {
        pub(crate) fn get_broken_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ReactionWheel_get_Broken",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_broken_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_broken_call()?)
        }
        pub fn get_broken(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_broken_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl ReactionWheel {
        pub(crate) fn get_max_torque_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ReactionWheel_get_MaxTorque",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_max_torque_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<((f64, f64, f64), (f64, f64, f64))>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_max_torque_call()?)
        }
        pub fn get_max_torque(
            &self,
        ) -> Result<((f64, f64, f64), (f64, f64, f64)), RpcError> {
            let request = crate::schema::Request::from(self.get_max_torque_call()?);
            let response = self.client.call(request)?;
            <(
                (f64, f64, f64),
                (f64, f64, f64),
            )>::from_response(response, self.client.clone())
        }
    }
    impl ReactionWheel {
        pub(crate) fn get_part_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ReactionWheel_get_Part",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_part_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::Part>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_part_call()?)
        }
        pub fn get_part(&self) -> Result<crate::services::space_center::Part, RpcError> {
            let request = crate::schema::Request::from(self.get_part_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::Part>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl ReactionWheel {
        pub(crate) fn set_active_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ReactionWheel_set_Active",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_active_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.set_active_call(value)?)
        }
        pub fn set_active(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_active_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl ReferenceFrame {
        pub(crate) fn static_create_hybrid_call(
            &self,
            position: &crate::services::space_center::ReferenceFrame,
            rotation: &crate::services::space_center::ReferenceFrame,
            velocity: &crate::services::space_center::ReferenceFrame,
            angular_velocity: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ReferenceFrame_static_CreateHybrid",
                    vec![
                        position.to_argument(0usize as u32) ?, rotation
                        .to_argument(1usize as u32) ?, velocity.to_argument(2usize as
                        u32) ?, angular_velocity.to_argument(3usize as u32) ?
                    ],
                ),
            )
        }
        pub fn static_create_hybrid_stream(
            &self,
            position: &crate::services::space_center::ReferenceFrame,
            rotation: &crate::services::space_center::ReferenceFrame,
            velocity: &crate::services::space_center::ReferenceFrame,
            angular_velocity: &crate::services::space_center::ReferenceFrame,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::ReferenceFrame>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self
                    .static_create_hybrid_call(
                        position,
                        rotation,
                        velocity,
                        angular_velocity,
                    )?,
            )
        }
        pub fn static_create_hybrid(
            &self,
            position: &crate::services::space_center::ReferenceFrame,
            rotation: &crate::services::space_center::ReferenceFrame,
            velocity: &crate::services::space_center::ReferenceFrame,
            angular_velocity: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::services::space_center::ReferenceFrame, RpcError> {
            let request = crate::schema::Request::from(
                self
                    .static_create_hybrid_call(
                        position,
                        rotation,
                        velocity,
                        angular_velocity,
                    )?,
            );
            let response = self.client.call(request)?;
            <crate::services::space_center::ReferenceFrame>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl ReferenceFrame {
        pub(crate) fn static_create_relative_call(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
            position: (f64, f64, f64),
            rotation: (f64, f64, f64, f64),
            velocity: (f64, f64, f64),
            angular_velocity: (f64, f64, f64),
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ReferenceFrame_static_CreateRelative",
                    vec![
                        reference_frame.to_argument(0usize as u32) ?, position
                        .to_argument(1usize as u32) ?, rotation.to_argument(2usize as
                        u32) ?, velocity.to_argument(3usize as u32) ?, angular_velocity
                        .to_argument(4usize as u32) ?
                    ],
                ),
            )
        }
        pub fn static_create_relative_stream(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
            position: (f64, f64, f64),
            rotation: (f64, f64, f64, f64),
            velocity: (f64, f64, f64),
            angular_velocity: (f64, f64, f64),
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::ReferenceFrame>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self
                    .static_create_relative_call(
                        reference_frame,
                        position,
                        rotation,
                        velocity,
                        angular_velocity,
                    )?,
            )
        }
        pub fn static_create_relative(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
            position: (f64, f64, f64),
            rotation: (f64, f64, f64, f64),
            velocity: (f64, f64, f64),
            angular_velocity: (f64, f64, f64),
        ) -> Result<crate::services::space_center::ReferenceFrame, RpcError> {
            let request = crate::schema::Request::from(
                self
                    .static_create_relative_call(
                        reference_frame,
                        position,
                        rotation,
                        velocity,
                        angular_velocity,
                    )?,
            );
            let response = self.client.call(request)?;
            <crate::services::space_center::ReferenceFrame>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl ResourceConverter {
        pub(crate) fn active_call(
            &self,
            index: i32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ResourceConverter_Active",
                    vec![
                        self.to_argument(0usize as u32) ?, index.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn active_stream(
            &self,
            index: i32,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.active_call(index)?)
        }
        pub fn active(&self, index: i32) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.active_call(index)?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl ResourceConverter {
        pub(crate) fn inputs_call(
            &self,
            index: i32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ResourceConverter_Inputs",
                    vec![
                        self.to_argument(0usize as u32) ?, index.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn inputs_stream(
            &self,
            index: i32,
        ) -> Result<crate::stream::Stream<Vec<String>>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.inputs_call(index)?)
        }
        pub fn inputs(&self, index: i32) -> Result<Vec<String>, RpcError> {
            let request = crate::schema::Request::from(self.inputs_call(index)?);
            let response = self.client.call(request)?;
            <Vec<String>>::from_response(response, self.client.clone())
        }
    }
    impl ResourceConverter {
        pub(crate) fn name_call(
            &self,
            index: i32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ResourceConverter_Name",
                    vec![
                        self.to_argument(0usize as u32) ?, index.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn name_stream(
            &self,
            index: i32,
        ) -> Result<crate::stream::Stream<String>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.name_call(index)?)
        }
        pub fn name(&self, index: i32) -> Result<String, RpcError> {
            let request = crate::schema::Request::from(self.name_call(index)?);
            let response = self.client.call(request)?;
            <String>::from_response(response, self.client.clone())
        }
    }
    impl ResourceConverter {
        pub(crate) fn outputs_call(
            &self,
            index: i32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ResourceConverter_Outputs",
                    vec![
                        self.to_argument(0usize as u32) ?, index.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn outputs_stream(
            &self,
            index: i32,
        ) -> Result<crate::stream::Stream<Vec<String>>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.outputs_call(index)?)
        }
        pub fn outputs(&self, index: i32) -> Result<Vec<String>, RpcError> {
            let request = crate::schema::Request::from(self.outputs_call(index)?);
            let response = self.client.call(request)?;
            <Vec<String>>::from_response(response, self.client.clone())
        }
    }
    impl ResourceConverter {
        pub(crate) fn start_call(
            &self,
            index: i32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ResourceConverter_Start",
                    vec![
                        self.to_argument(0usize as u32) ?, index.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn start_stream(
            &self,
            index: i32,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.start_call(index)?)
        }
        pub fn start(&self, index: i32) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.start_call(index)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl ResourceConverter {
        pub(crate) fn state_call(
            &self,
            index: i32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ResourceConverter_State",
                    vec![
                        self.to_argument(0usize as u32) ?, index.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn state_stream(
            &self,
            index: i32,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::ResourceConverterState>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.state_call(index)?)
        }
        pub fn state(
            &self,
            index: i32,
        ) -> Result<crate::services::space_center::ResourceConverterState, RpcError> {
            let request = crate::schema::Request::from(self.state_call(index)?);
            let response = self.client.call(request)?;
            <crate::services::space_center::ResourceConverterState>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl ResourceConverter {
        pub(crate) fn status_info_call(
            &self,
            index: i32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ResourceConverter_StatusInfo",
                    vec![
                        self.to_argument(0usize as u32) ?, index.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn status_info_stream(
            &self,
            index: i32,
        ) -> Result<crate::stream::Stream<String>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.status_info_call(index)?,
            )
        }
        pub fn status_info(&self, index: i32) -> Result<String, RpcError> {
            let request = crate::schema::Request::from(self.status_info_call(index)?);
            let response = self.client.call(request)?;
            <String>::from_response(response, self.client.clone())
        }
    }
    impl ResourceConverter {
        pub(crate) fn stop_call(
            &self,
            index: i32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ResourceConverter_Stop",
                    vec![
                        self.to_argument(0usize as u32) ?, index.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn stop_stream(
            &self,
            index: i32,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.stop_call(index)?)
        }
        pub fn stop(&self, index: i32) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.stop_call(index)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl ResourceConverter {
        pub(crate) fn get_core_temperature_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ResourceConverter_get_CoreTemperature",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_core_temperature_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_core_temperature_call()?,
            )
        }
        pub fn get_core_temperature(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(
                self.get_core_temperature_call()?,
            );
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl ResourceConverter {
        pub(crate) fn get_count_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ResourceConverter_get_Count",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_count_stream(&self) -> Result<crate::stream::Stream<i32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_count_call()?)
        }
        pub fn get_count(&self) -> Result<i32, RpcError> {
            let request = crate::schema::Request::from(self.get_count_call()?);
            let response = self.client.call(request)?;
            <i32>::from_response(response, self.client.clone())
        }
    }
    impl ResourceConverter {
        pub(crate) fn get_optimum_core_temperature_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ResourceConverter_get_OptimumCoreTemperature",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_optimum_core_temperature_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_optimum_core_temperature_call()?,
            )
        }
        pub fn get_optimum_core_temperature(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(
                self.get_optimum_core_temperature_call()?,
            );
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl ResourceConverter {
        pub(crate) fn get_part_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ResourceConverter_get_Part",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_part_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::Part>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_part_call()?)
        }
        pub fn get_part(&self) -> Result<crate::services::space_center::Part, RpcError> {
            let request = crate::schema::Request::from(self.get_part_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::Part>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl ResourceConverter {
        pub(crate) fn get_thermal_efficiency_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ResourceConverter_get_ThermalEfficiency",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_thermal_efficiency_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_thermal_efficiency_call()?,
            )
        }
        pub fn get_thermal_efficiency(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(
                self.get_thermal_efficiency_call()?,
            );
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl ResourceDrain {
        pub(crate) fn check_resource_call(
            &self,
            resource: &crate::services::space_center::Resource,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ResourceDrain_CheckResource",
                    vec![
                        self.to_argument(0usize as u32) ?, resource.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn check_resource_stream(
            &self,
            resource: &crate::services::space_center::Resource,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.check_resource_call(resource)?,
            )
        }
        pub fn check_resource(
            &self,
            resource: &crate::services::space_center::Resource,
        ) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(
                self.check_resource_call(resource)?,
            );
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl ResourceDrain {
        pub(crate) fn set_resource_call(
            &self,
            resource: &crate::services::space_center::Resource,
            enabled: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ResourceDrain_SetResource",
                    vec![
                        self.to_argument(0usize as u32) ?, resource.to_argument(1usize as
                        u32) ?, enabled.to_argument(2usize as u32) ?
                    ],
                ),
            )
        }
        pub fn set_resource_stream(
            &self,
            resource: &crate::services::space_center::Resource,
            enabled: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_resource_call(resource, enabled)?,
            )
        }
        pub fn set_resource(
            &self,
            resource: &crate::services::space_center::Resource,
            enabled: bool,
        ) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_resource_call(resource, enabled)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl ResourceDrain {
        pub(crate) fn start_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ResourceDrain_Start",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn start_stream(&self) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.start_call()?)
        }
        pub fn start(&self) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.start_call()?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl ResourceDrain {
        pub(crate) fn stop_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ResourceDrain_Stop",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn stop_stream(&self) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.stop_call()?)
        }
        pub fn stop(&self) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.stop_call()?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl ResourceDrain {
        pub(crate) fn get_available_resources_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ResourceDrain_get_AvailableResources",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_available_resources_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Vec<crate::services::space_center::Resource>>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_available_resources_call()?,
            )
        }
        pub fn get_available_resources(
            &self,
        ) -> Result<Vec<crate::services::space_center::Resource>, RpcError> {
            let request = crate::schema::Request::from(
                self.get_available_resources_call()?,
            );
            let response = self.client.call(request)?;
            <Vec<
                crate::services::space_center::Resource,
            >>::from_response(response, self.client.clone())
        }
    }
    impl ResourceDrain {
        pub(crate) fn get_drain_mode_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ResourceDrain_get_DrainMode",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_drain_mode_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::DrainMode>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_drain_mode_call()?)
        }
        pub fn get_drain_mode(
            &self,
        ) -> Result<crate::services::space_center::DrainMode, RpcError> {
            let request = crate::schema::Request::from(self.get_drain_mode_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::DrainMode>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl ResourceDrain {
        pub(crate) fn get_max_rate_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ResourceDrain_get_MaxRate",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_max_rate_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_max_rate_call()?)
        }
        pub fn get_max_rate(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_max_rate_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl ResourceDrain {
        pub(crate) fn get_min_rate_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ResourceDrain_get_MinRate",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_min_rate_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_min_rate_call()?)
        }
        pub fn get_min_rate(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_min_rate_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl ResourceDrain {
        pub(crate) fn get_part_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ResourceDrain_get_Part",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_part_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::Part>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_part_call()?)
        }
        pub fn get_part(&self) -> Result<crate::services::space_center::Part, RpcError> {
            let request = crate::schema::Request::from(self.get_part_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::Part>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl ResourceDrain {
        pub(crate) fn get_rate_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ResourceDrain_get_Rate",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_rate_stream(&self) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_rate_call()?)
        }
        pub fn get_rate(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_rate_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl ResourceDrain {
        pub(crate) fn set_drain_mode_call(
            &self,
            value: crate::services::space_center::DrainMode,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ResourceDrain_set_DrainMode",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_drain_mode_stream(
            &self,
            value: crate::services::space_center::DrainMode,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_drain_mode_call(value)?,
            )
        }
        pub fn set_drain_mode(
            &self,
            value: crate::services::space_center::DrainMode,
        ) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_drain_mode_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl ResourceDrain {
        pub(crate) fn set_rate_call(
            &self,
            value: f32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ResourceDrain_set_Rate",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_rate_stream(
            &self,
            value: f32,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.set_rate_call(value)?)
        }
        pub fn set_rate(&self, value: f32) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_rate_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl ResourceHarvester {
        pub(crate) fn get_active_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ResourceHarvester_get_Active",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_active_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_active_call()?)
        }
        pub fn get_active(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_active_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl ResourceHarvester {
        pub(crate) fn get_core_temperature_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ResourceHarvester_get_CoreTemperature",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_core_temperature_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_core_temperature_call()?,
            )
        }
        pub fn get_core_temperature(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(
                self.get_core_temperature_call()?,
            );
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl ResourceHarvester {
        pub(crate) fn get_deployed_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ResourceHarvester_get_Deployed",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_deployed_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_deployed_call()?)
        }
        pub fn get_deployed(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_deployed_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl ResourceHarvester {
        pub(crate) fn get_extraction_rate_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ResourceHarvester_get_ExtractionRate",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_extraction_rate_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_extraction_rate_call()?,
            )
        }
        pub fn get_extraction_rate(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_extraction_rate_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl ResourceHarvester {
        pub(crate) fn get_optimum_core_temperature_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ResourceHarvester_get_OptimumCoreTemperature",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_optimum_core_temperature_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_optimum_core_temperature_call()?,
            )
        }
        pub fn get_optimum_core_temperature(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(
                self.get_optimum_core_temperature_call()?,
            );
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl ResourceHarvester {
        pub(crate) fn get_part_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ResourceHarvester_get_Part",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_part_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::Part>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_part_call()?)
        }
        pub fn get_part(&self) -> Result<crate::services::space_center::Part, RpcError> {
            let request = crate::schema::Request::from(self.get_part_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::Part>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl ResourceHarvester {
        pub(crate) fn get_state_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ResourceHarvester_get_State",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_state_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::ResourceHarvesterState>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_state_call()?)
        }
        pub fn get_state(
            &self,
        ) -> Result<crate::services::space_center::ResourceHarvesterState, RpcError> {
            let request = crate::schema::Request::from(self.get_state_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::ResourceHarvesterState>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl ResourceHarvester {
        pub(crate) fn get_thermal_efficiency_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ResourceHarvester_get_ThermalEfficiency",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_thermal_efficiency_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_thermal_efficiency_call()?,
            )
        }
        pub fn get_thermal_efficiency(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(
                self.get_thermal_efficiency_call()?,
            );
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl ResourceHarvester {
        pub(crate) fn set_active_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ResourceHarvester_set_Active",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_active_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.set_active_call(value)?)
        }
        pub fn set_active(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_active_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl ResourceHarvester {
        pub(crate) fn set_deployed_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ResourceHarvester_set_Deployed",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_deployed_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_deployed_call(value)?,
            )
        }
        pub fn set_deployed(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_deployed_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl ResourceTransfer {
        pub(crate) fn get_amount_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ResourceTransfer_get_Amount",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_amount_stream(&self) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_amount_call()?)
        }
        pub fn get_amount(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_amount_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl ResourceTransfer {
        pub(crate) fn get_complete_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ResourceTransfer_get_Complete",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_complete_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_complete_call()?)
        }
        pub fn get_complete(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_complete_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl ResourceTransfer {
        pub(crate) fn static_start_call(
            &self,
            from_part: &crate::services::space_center::Part,
            to_part: &crate::services::space_center::Part,
            resource: String,
            max_amount: f32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ResourceTransfer_static_Start",
                    vec![
                        from_part.to_argument(0usize as u32) ?, to_part
                        .to_argument(1usize as u32) ?, resource.to_argument(2usize as
                        u32) ?, max_amount.to_argument(3usize as u32) ?
                    ],
                ),
            )
        }
        pub fn static_start_stream(
            &self,
            from_part: &crate::services::space_center::Part,
            to_part: &crate::services::space_center::Part,
            resource: String,
            max_amount: f32,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::ResourceTransfer>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.static_start_call(from_part, to_part, resource, max_amount)?,
            )
        }
        pub fn static_start(
            &self,
            from_part: &crate::services::space_center::Part,
            to_part: &crate::services::space_center::Part,
            resource: String,
            max_amount: f32,
        ) -> Result<crate::services::space_center::ResourceTransfer, RpcError> {
            let request = crate::schema::Request::from(
                self.static_start_call(from_part, to_part, resource, max_amount)?,
            );
            let response = self.client.call(request)?;
            <crate::services::space_center::ResourceTransfer>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Resource {
        pub(crate) fn get_amount_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Resource_get_Amount",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_amount_stream(&self) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_amount_call()?)
        }
        pub fn get_amount(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_amount_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Resource {
        pub(crate) fn get_density_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Resource_get_Density",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_density_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_density_call()?)
        }
        pub fn get_density(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_density_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Resource {
        pub(crate) fn get_enabled_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Resource_get_Enabled",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_enabled_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_enabled_call()?)
        }
        pub fn get_enabled(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_enabled_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Resource {
        pub(crate) fn get_flow_mode_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Resource_get_FlowMode",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_flow_mode_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::ResourceFlowMode>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_flow_mode_call()?)
        }
        pub fn get_flow_mode(
            &self,
        ) -> Result<crate::services::space_center::ResourceFlowMode, RpcError> {
            let request = crate::schema::Request::from(self.get_flow_mode_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::ResourceFlowMode>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Resource {
        pub(crate) fn get_max_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Resource_get_Max",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_max_stream(&self) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_max_call()?)
        }
        pub fn get_max(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_max_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Resource {
        pub(crate) fn get_name_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Resource_get_Name",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_name_stream(
            &self,
        ) -> Result<crate::stream::Stream<String>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_name_call()?)
        }
        pub fn get_name(&self) -> Result<String, RpcError> {
            let request = crate::schema::Request::from(self.get_name_call()?);
            let response = self.client.call(request)?;
            <String>::from_response(response, self.client.clone())
        }
    }
    impl Resource {
        pub(crate) fn get_part_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Resource_get_Part",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_part_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::Part>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_part_call()?)
        }
        pub fn get_part(&self) -> Result<crate::services::space_center::Part, RpcError> {
            let request = crate::schema::Request::from(self.get_part_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::Part>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Resource {
        pub(crate) fn set_enabled_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Resource_set_Enabled",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_enabled_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_enabled_call(value)?,
            )
        }
        pub fn set_enabled(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_enabled_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Resources {
        pub(crate) fn amount_call(
            &self,
            name: String,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Resources_Amount",
                    vec![
                        self.to_argument(0usize as u32) ?, name.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn amount_stream(
            &self,
            name: String,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.amount_call(name)?)
        }
        pub fn amount(&self, name: String) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.amount_call(name)?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Resources {
        pub(crate) fn has_resource_call(
            &self,
            name: String,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Resources_HasResource",
                    vec![
                        self.to_argument(0usize as u32) ?, name.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn has_resource_stream(
            &self,
            name: String,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.has_resource_call(name)?,
            )
        }
        pub fn has_resource(&self, name: String) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.has_resource_call(name)?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Resources {
        pub(crate) fn max_call(
            &self,
            name: String,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Resources_Max",
                    vec![
                        self.to_argument(0usize as u32) ?, name.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn max_stream(
            &self,
            name: String,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.max_call(name)?)
        }
        pub fn max(&self, name: String) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.max_call(name)?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Resources {
        pub(crate) fn with_resource_call(
            &self,
            name: String,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Resources_WithResource",
                    vec![
                        self.to_argument(0usize as u32) ?, name.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn with_resource_stream(
            &self,
            name: String,
        ) -> Result<
            crate::stream::Stream<Vec<crate::services::space_center::Resource>>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.with_resource_call(name)?,
            )
        }
        pub fn with_resource(
            &self,
            name: String,
        ) -> Result<Vec<crate::services::space_center::Resource>, RpcError> {
            let request = crate::schema::Request::from(self.with_resource_call(name)?);
            let response = self.client.call(request)?;
            <Vec<
                crate::services::space_center::Resource,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Resources {
        pub(crate) fn get_all_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Resources_get_All",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_all_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Vec<crate::services::space_center::Resource>>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_all_call()?)
        }
        pub fn get_all(
            &self,
        ) -> Result<Vec<crate::services::space_center::Resource>, RpcError> {
            let request = crate::schema::Request::from(self.get_all_call()?);
            let response = self.client.call(request)?;
            <Vec<
                crate::services::space_center::Resource,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Resources {
        pub(crate) fn get_enabled_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Resources_get_Enabled",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_enabled_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_enabled_call()?)
        }
        pub fn get_enabled(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_enabled_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Resources {
        pub(crate) fn get_names_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Resources_get_Names",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_names_stream(
            &self,
        ) -> Result<crate::stream::Stream<Vec<String>>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_names_call()?)
        }
        pub fn get_names(&self) -> Result<Vec<String>, RpcError> {
            let request = crate::schema::Request::from(self.get_names_call()?);
            let response = self.client.call(request)?;
            <Vec<String>>::from_response(response, self.client.clone())
        }
    }
    impl Resources {
        pub(crate) fn set_enabled_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Resources_set_Enabled",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_enabled_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_enabled_call(value)?,
            )
        }
        pub fn set_enabled(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_enabled_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Resources {
        pub(crate) fn static_density_call(
            &self,
            name: String,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Resources_static_Density",
                    vec![name.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn static_density_stream(
            &self,
            name: String,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.static_density_call(name)?,
            )
        }
        pub fn static_density(&self, name: String) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.static_density_call(name)?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Resources {
        pub(crate) fn static_flow_mode_call(
            &self,
            name: String,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Resources_static_FlowMode",
                    vec![name.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn static_flow_mode_stream(
            &self,
            name: String,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::ResourceFlowMode>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.static_flow_mode_call(name)?,
            )
        }
        pub fn static_flow_mode(
            &self,
            name: String,
        ) -> Result<crate::services::space_center::ResourceFlowMode, RpcError> {
            let request = crate::schema::Request::from(
                self.static_flow_mode_call(name)?,
            );
            let response = self.client.call(request)?;
            <crate::services::space_center::ResourceFlowMode>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl SpaceCenter {
        pub(crate) fn revert_to_launch_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(crate::client::Client::proc_call("SpaceCenter", "RevertToLaunch", vec![]))
        }
        pub fn revert_to_launch_stream(
            &self,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.revert_to_launch_call()?,
            )
        }
        pub fn revert_to_launch(&self) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.revert_to_launch_call()?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl RoboticController {
        pub(crate) fn add_axis_call(
            &self,
            module: &crate::services::space_center::Module,
            field_name: String,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RoboticController_AddAxis",
                    vec![
                        self.to_argument(0usize as u32) ?, module.to_argument(1usize as
                        u32) ?, field_name.to_argument(2usize as u32) ?
                    ],
                ),
            )
        }
        pub fn add_axis_stream(
            &self,
            module: &crate::services::space_center::Module,
            field_name: String,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.add_axis_call(module, field_name)?,
            )
        }
        pub fn add_axis(
            &self,
            module: &crate::services::space_center::Module,
            field_name: String,
        ) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(
                self.add_axis_call(module, field_name)?,
            );
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl RoboticController {
        pub(crate) fn add_key_frame_call(
            &self,
            module: &crate::services::space_center::Module,
            field_name: String,
            time: f32,
            value: f32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RoboticController_AddKeyFrame",
                    vec![
                        self.to_argument(0usize as u32) ?, module.to_argument(1usize as
                        u32) ?, field_name.to_argument(2usize as u32) ?, time
                        .to_argument(3usize as u32) ?, value.to_argument(4usize as u32) ?
                    ],
                ),
            )
        }
        pub fn add_key_frame_stream(
            &self,
            module: &crate::services::space_center::Module,
            field_name: String,
            time: f32,
            value: f32,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.add_key_frame_call(module, field_name, time, value)?,
            )
        }
        pub fn add_key_frame(
            &self,
            module: &crate::services::space_center::Module,
            field_name: String,
            time: f32,
            value: f32,
        ) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(
                self.add_key_frame_call(module, field_name, time, value)?,
            );
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl RoboticController {
        pub(crate) fn axes_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RoboticController_Axes",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn axes_stream(
            &self,
        ) -> Result<crate::stream::Stream<Vec<Vec<String>>>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.axes_call()?)
        }
        pub fn axes(&self) -> Result<Vec<Vec<String>>, RpcError> {
            let request = crate::schema::Request::from(self.axes_call()?);
            let response = self.client.call(request)?;
            <Vec<Vec<String>>>::from_response(response, self.client.clone())
        }
    }
    impl RoboticController {
        pub(crate) fn clear_axis_call(
            &self,
            module: &crate::services::space_center::Module,
            field_name: String,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RoboticController_ClearAxis",
                    vec![
                        self.to_argument(0usize as u32) ?, module.to_argument(1usize as
                        u32) ?, field_name.to_argument(2usize as u32) ?
                    ],
                ),
            )
        }
        pub fn clear_axis_stream(
            &self,
            module: &crate::services::space_center::Module,
            field_name: String,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.clear_axis_call(module, field_name)?,
            )
        }
        pub fn clear_axis(
            &self,
            module: &crate::services::space_center::Module,
            field_name: String,
        ) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(
                self.clear_axis_call(module, field_name)?,
            );
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl RoboticController {
        pub(crate) fn has_part_call(
            &self,
            part: &crate::services::space_center::Part,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RoboticController_HasPart",
                    vec![
                        self.to_argument(0usize as u32) ?, part.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn has_part_stream(
            &self,
            part: &crate::services::space_center::Part,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.has_part_call(part)?)
        }
        pub fn has_part(
            &self,
            part: &crate::services::space_center::Part,
        ) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.has_part_call(part)?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl RoboticController {
        pub(crate) fn get_part_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RoboticController_get_Part",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_part_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::Part>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_part_call()?)
        }
        pub fn get_part(&self) -> Result<crate::services::space_center::Part, RpcError> {
            let request = crate::schema::Request::from(self.get_part_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::Part>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl RoboticHinge {
        pub(crate) fn move_home_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RoboticHinge_MoveHome",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn move_home_stream(&self) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.move_home_call()?)
        }
        pub fn move_home(&self) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.move_home_call()?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl RoboticHinge {
        pub(crate) fn get_current_angle_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RoboticHinge_get_CurrentAngle",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_current_angle_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_current_angle_call()?,
            )
        }
        pub fn get_current_angle(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_current_angle_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl RoboticHinge {
        pub(crate) fn get_damping_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RoboticHinge_get_Damping",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_damping_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_damping_call()?)
        }
        pub fn get_damping(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_damping_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl RoboticHinge {
        pub(crate) fn get_locked_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RoboticHinge_get_Locked",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_locked_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_locked_call()?)
        }
        pub fn get_locked(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_locked_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl RoboticHinge {
        pub(crate) fn get_motor_engaged_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RoboticHinge_get_MotorEngaged",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_motor_engaged_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_motor_engaged_call()?,
            )
        }
        pub fn get_motor_engaged(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_motor_engaged_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl RoboticHinge {
        pub(crate) fn get_part_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RoboticHinge_get_Part",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_part_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::Part>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_part_call()?)
        }
        pub fn get_part(&self) -> Result<crate::services::space_center::Part, RpcError> {
            let request = crate::schema::Request::from(self.get_part_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::Part>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl RoboticHinge {
        pub(crate) fn get_rate_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RoboticHinge_get_Rate",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_rate_stream(&self) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_rate_call()?)
        }
        pub fn get_rate(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_rate_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl RoboticHinge {
        pub(crate) fn get_target_angle_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RoboticHinge_get_TargetAngle",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_target_angle_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_target_angle_call()?,
            )
        }
        pub fn get_target_angle(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_target_angle_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl RoboticHinge {
        pub(crate) fn set_damping_call(
            &self,
            value: f32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RoboticHinge_set_Damping",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_damping_stream(
            &self,
            value: f32,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_damping_call(value)?,
            )
        }
        pub fn set_damping(&self, value: f32) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_damping_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl RoboticHinge {
        pub(crate) fn set_locked_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RoboticHinge_set_Locked",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_locked_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.set_locked_call(value)?)
        }
        pub fn set_locked(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_locked_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl RoboticHinge {
        pub(crate) fn set_motor_engaged_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RoboticHinge_set_MotorEngaged",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_motor_engaged_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_motor_engaged_call(value)?,
            )
        }
        pub fn set_motor_engaged(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_motor_engaged_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl RoboticHinge {
        pub(crate) fn set_rate_call(
            &self,
            value: f32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RoboticHinge_set_Rate",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_rate_stream(
            &self,
            value: f32,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.set_rate_call(value)?)
        }
        pub fn set_rate(&self, value: f32) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_rate_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl RoboticHinge {
        pub(crate) fn set_target_angle_call(
            &self,
            value: f32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RoboticHinge_set_TargetAngle",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_target_angle_stream(
            &self,
            value: f32,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_target_angle_call(value)?,
            )
        }
        pub fn set_target_angle(&self, value: f32) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_target_angle_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl RoboticPiston {
        pub(crate) fn move_home_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RoboticPiston_MoveHome",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn move_home_stream(&self) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.move_home_call()?)
        }
        pub fn move_home(&self) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.move_home_call()?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl RoboticPiston {
        pub(crate) fn get_current_extension_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RoboticPiston_get_CurrentExtension",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_current_extension_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_current_extension_call()?,
            )
        }
        pub fn get_current_extension(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(
                self.get_current_extension_call()?,
            );
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl RoboticPiston {
        pub(crate) fn get_damping_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RoboticPiston_get_Damping",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_damping_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_damping_call()?)
        }
        pub fn get_damping(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_damping_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl RoboticPiston {
        pub(crate) fn get_locked_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RoboticPiston_get_Locked",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_locked_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_locked_call()?)
        }
        pub fn get_locked(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_locked_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl RoboticPiston {
        pub(crate) fn get_motor_engaged_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RoboticPiston_get_MotorEngaged",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_motor_engaged_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_motor_engaged_call()?,
            )
        }
        pub fn get_motor_engaged(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_motor_engaged_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl RoboticPiston {
        pub(crate) fn get_part_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RoboticPiston_get_Part",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_part_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::Part>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_part_call()?)
        }
        pub fn get_part(&self) -> Result<crate::services::space_center::Part, RpcError> {
            let request = crate::schema::Request::from(self.get_part_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::Part>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl RoboticPiston {
        pub(crate) fn get_rate_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RoboticPiston_get_Rate",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_rate_stream(&self) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_rate_call()?)
        }
        pub fn get_rate(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_rate_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl RoboticPiston {
        pub(crate) fn get_target_extension_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RoboticPiston_get_TargetExtension",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_target_extension_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_target_extension_call()?,
            )
        }
        pub fn get_target_extension(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(
                self.get_target_extension_call()?,
            );
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl RoboticPiston {
        pub(crate) fn set_damping_call(
            &self,
            value: f32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RoboticPiston_set_Damping",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_damping_stream(
            &self,
            value: f32,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_damping_call(value)?,
            )
        }
        pub fn set_damping(&self, value: f32) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_damping_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl RoboticPiston {
        pub(crate) fn set_locked_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RoboticPiston_set_Locked",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_locked_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.set_locked_call(value)?)
        }
        pub fn set_locked(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_locked_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl RoboticPiston {
        pub(crate) fn set_motor_engaged_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RoboticPiston_set_MotorEngaged",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_motor_engaged_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_motor_engaged_call(value)?,
            )
        }
        pub fn set_motor_engaged(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_motor_engaged_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl RoboticPiston {
        pub(crate) fn set_rate_call(
            &self,
            value: f32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RoboticPiston_set_Rate",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_rate_stream(
            &self,
            value: f32,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.set_rate_call(value)?)
        }
        pub fn set_rate(&self, value: f32) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_rate_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl RoboticPiston {
        pub(crate) fn set_target_extension_call(
            &self,
            value: f32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RoboticPiston_set_TargetExtension",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_target_extension_stream(
            &self,
            value: f32,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_target_extension_call(value)?,
            )
        }
        pub fn set_target_extension(&self, value: f32) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_target_extension_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl RoboticRotation {
        pub(crate) fn move_home_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RoboticRotation_MoveHome",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn move_home_stream(&self) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.move_home_call()?)
        }
        pub fn move_home(&self) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.move_home_call()?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl RoboticRotation {
        pub(crate) fn get_current_angle_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RoboticRotation_get_CurrentAngle",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_current_angle_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_current_angle_call()?,
            )
        }
        pub fn get_current_angle(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_current_angle_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl RoboticRotation {
        pub(crate) fn get_damping_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RoboticRotation_get_Damping",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_damping_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_damping_call()?)
        }
        pub fn get_damping(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_damping_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl RoboticRotation {
        pub(crate) fn get_locked_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RoboticRotation_get_Locked",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_locked_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_locked_call()?)
        }
        pub fn get_locked(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_locked_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl RoboticRotation {
        pub(crate) fn get_motor_engaged_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RoboticRotation_get_MotorEngaged",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_motor_engaged_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_motor_engaged_call()?,
            )
        }
        pub fn get_motor_engaged(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_motor_engaged_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl RoboticRotation {
        pub(crate) fn get_part_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RoboticRotation_get_Part",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_part_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::Part>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_part_call()?)
        }
        pub fn get_part(&self) -> Result<crate::services::space_center::Part, RpcError> {
            let request = crate::schema::Request::from(self.get_part_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::Part>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl RoboticRotation {
        pub(crate) fn get_rate_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RoboticRotation_get_Rate",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_rate_stream(&self) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_rate_call()?)
        }
        pub fn get_rate(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_rate_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl RoboticRotation {
        pub(crate) fn get_target_angle_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RoboticRotation_get_TargetAngle",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_target_angle_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_target_angle_call()?,
            )
        }
        pub fn get_target_angle(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_target_angle_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl RoboticRotation {
        pub(crate) fn set_damping_call(
            &self,
            value: f32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RoboticRotation_set_Damping",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_damping_stream(
            &self,
            value: f32,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_damping_call(value)?,
            )
        }
        pub fn set_damping(&self, value: f32) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_damping_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl RoboticRotation {
        pub(crate) fn set_locked_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RoboticRotation_set_Locked",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_locked_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.set_locked_call(value)?)
        }
        pub fn set_locked(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_locked_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl RoboticRotation {
        pub(crate) fn set_motor_engaged_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RoboticRotation_set_MotorEngaged",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_motor_engaged_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_motor_engaged_call(value)?,
            )
        }
        pub fn set_motor_engaged(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_motor_engaged_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl RoboticRotation {
        pub(crate) fn set_rate_call(
            &self,
            value: f32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RoboticRotation_set_Rate",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_rate_stream(
            &self,
            value: f32,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.set_rate_call(value)?)
        }
        pub fn set_rate(&self, value: f32) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_rate_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl RoboticRotation {
        pub(crate) fn set_target_angle_call(
            &self,
            value: f32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RoboticRotation_set_TargetAngle",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_target_angle_stream(
            &self,
            value: f32,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_target_angle_call(value)?,
            )
        }
        pub fn set_target_angle(&self, value: f32) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_target_angle_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl RoboticRotor {
        pub(crate) fn get_current_rpm_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RoboticRotor_get_CurrentRPM",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_current_rpm_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_current_rpm_call()?)
        }
        pub fn get_current_rpm(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_current_rpm_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl RoboticRotor {
        pub(crate) fn get_inverted_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RoboticRotor_get_Inverted",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_inverted_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_inverted_call()?)
        }
        pub fn get_inverted(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_inverted_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl RoboticRotor {
        pub(crate) fn get_locked_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RoboticRotor_get_Locked",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_locked_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_locked_call()?)
        }
        pub fn get_locked(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_locked_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl RoboticRotor {
        pub(crate) fn get_motor_engaged_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RoboticRotor_get_MotorEngaged",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_motor_engaged_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_motor_engaged_call()?,
            )
        }
        pub fn get_motor_engaged(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_motor_engaged_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl RoboticRotor {
        pub(crate) fn get_part_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RoboticRotor_get_Part",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_part_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::Part>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_part_call()?)
        }
        pub fn get_part(&self) -> Result<crate::services::space_center::Part, RpcError> {
            let request = crate::schema::Request::from(self.get_part_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::Part>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl RoboticRotor {
        pub(crate) fn get_target_rpm_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RoboticRotor_get_TargetRPM",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_target_rpm_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_target_rpm_call()?)
        }
        pub fn get_target_rpm(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_target_rpm_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl RoboticRotor {
        pub(crate) fn get_torque_limit_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RoboticRotor_get_TorqueLimit",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_torque_limit_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_torque_limit_call()?,
            )
        }
        pub fn get_torque_limit(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_torque_limit_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl RoboticRotor {
        pub(crate) fn set_inverted_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RoboticRotor_set_Inverted",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_inverted_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_inverted_call(value)?,
            )
        }
        pub fn set_inverted(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_inverted_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl RoboticRotor {
        pub(crate) fn set_locked_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RoboticRotor_set_Locked",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_locked_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.set_locked_call(value)?)
        }
        pub fn set_locked(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_locked_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl RoboticRotor {
        pub(crate) fn set_motor_engaged_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RoboticRotor_set_MotorEngaged",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_motor_engaged_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_motor_engaged_call(value)?,
            )
        }
        pub fn set_motor_engaged(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_motor_engaged_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl RoboticRotor {
        pub(crate) fn set_target_rpm_call(
            &self,
            value: f32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RoboticRotor_set_TargetRPM",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_target_rpm_stream(
            &self,
            value: f32,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_target_rpm_call(value)?,
            )
        }
        pub fn set_target_rpm(&self, value: f32) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_target_rpm_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl RoboticRotor {
        pub(crate) fn set_torque_limit_call(
            &self,
            value: f32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "RoboticRotor_set_TorqueLimit",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_torque_limit_stream(
            &self,
            value: f32,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_torque_limit_call(value)?,
            )
        }
        pub fn set_torque_limit(&self, value: f32) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_torque_limit_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl SpaceCenter {
        pub(crate) fn save_call(
            &self,
            name: String,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Save",
                    vec![name.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn save_stream(
            &self,
            name: String,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.save_call(name)?)
        }
        pub fn save(&self, name: String) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.save_call(name)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl ScienceData {
        pub(crate) fn get_data_amount_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ScienceData_get_DataAmount",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_data_amount_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_data_amount_call()?)
        }
        pub fn get_data_amount(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_data_amount_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl ScienceData {
        pub(crate) fn get_science_value_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ScienceData_get_ScienceValue",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_science_value_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_science_value_call()?,
            )
        }
        pub fn get_science_value(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_science_value_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl ScienceData {
        pub(crate) fn get_transmit_value_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ScienceData_get_TransmitValue",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_transmit_value_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_transmit_value_call()?,
            )
        }
        pub fn get_transmit_value(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_transmit_value_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl ScienceSubject {
        pub(crate) fn get_data_scale_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ScienceSubject_get_DataScale",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_data_scale_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_data_scale_call()?)
        }
        pub fn get_data_scale(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_data_scale_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl ScienceSubject {
        pub(crate) fn get_is_complete_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ScienceSubject_get_IsComplete",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_is_complete_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_is_complete_call()?)
        }
        pub fn get_is_complete(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_is_complete_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl ScienceSubject {
        pub(crate) fn get_science_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ScienceSubject_get_Science",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_science_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_science_call()?)
        }
        pub fn get_science(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_science_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl ScienceSubject {
        pub(crate) fn get_science_cap_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ScienceSubject_get_ScienceCap",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_science_cap_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_science_cap_call()?)
        }
        pub fn get_science_cap(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_science_cap_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl ScienceSubject {
        pub(crate) fn get_scientific_value_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ScienceSubject_get_ScientificValue",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_scientific_value_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_scientific_value_call()?,
            )
        }
        pub fn get_scientific_value(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(
                self.get_scientific_value_call()?,
            );
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl ScienceSubject {
        pub(crate) fn get_subject_value_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ScienceSubject_get_SubjectValue",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_subject_value_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_subject_value_call()?,
            )
        }
        pub fn get_subject_value(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_subject_value_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl ScienceSubject {
        pub(crate) fn get_title_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "ScienceSubject_get_Title",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_title_stream(
            &self,
        ) -> Result<crate::stream::Stream<String>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_title_call()?)
        }
        pub fn get_title(&self) -> Result<String, RpcError> {
            let request = crate::schema::Request::from(self.get_title_call()?);
            let response = self.client.call(request)?;
            <String>::from_response(response, self.client.clone())
        }
    }
    impl SpaceCenter {
        pub(crate) fn screenshot_call(
            &self,
            file_path: String,
            scale: i32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Screenshot",
                    vec![
                        file_path.to_argument(0usize as u32) ?, scale.to_argument(1usize
                        as u32) ?
                    ],
                ),
            )
        }
        pub fn screenshot_stream(
            &self,
            file_path: String,
            scale: i32,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.screenshot_call(file_path, scale)?,
            )
        }
        pub fn screenshot(&self, file_path: String, scale: i32) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.screenshot_call(file_path, scale)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Sensor {
        pub(crate) fn get_active_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Sensor_get_Active",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_active_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_active_call()?)
        }
        pub fn get_active(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_active_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Sensor {
        pub(crate) fn get_part_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Sensor_get_Part",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_part_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::Part>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_part_call()?)
        }
        pub fn get_part(&self) -> Result<crate::services::space_center::Part, RpcError> {
            let request = crate::schema::Request::from(self.get_part_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::Part>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Sensor {
        pub(crate) fn get_value_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Sensor_get_Value",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_value_stream(
            &self,
        ) -> Result<crate::stream::Stream<String>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_value_call()?)
        }
        pub fn get_value(&self) -> Result<String, RpcError> {
            let request = crate::schema::Request::from(self.get_value_call()?);
            let response = self.client.call(request)?;
            <String>::from_response(response, self.client.clone())
        }
    }
    impl Sensor {
        pub(crate) fn set_active_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Sensor_set_Active",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_active_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.set_active_call(value)?)
        }
        pub fn set_active(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_active_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl SolarPanel {
        pub(crate) fn get_deployable_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "SolarPanel_get_Deployable",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_deployable_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_deployable_call()?)
        }
        pub fn get_deployable(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_deployable_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl SolarPanel {
        pub(crate) fn get_deployed_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "SolarPanel_get_Deployed",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_deployed_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_deployed_call()?)
        }
        pub fn get_deployed(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_deployed_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl SolarPanel {
        pub(crate) fn get_energy_flow_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "SolarPanel_get_EnergyFlow",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_energy_flow_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_energy_flow_call()?)
        }
        pub fn get_energy_flow(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_energy_flow_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl SolarPanel {
        pub(crate) fn get_part_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "SolarPanel_get_Part",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_part_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::Part>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_part_call()?)
        }
        pub fn get_part(&self) -> Result<crate::services::space_center::Part, RpcError> {
            let request = crate::schema::Request::from(self.get_part_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::Part>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl SolarPanel {
        pub(crate) fn get_state_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "SolarPanel_get_State",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_state_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::SolarPanelState>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_state_call()?)
        }
        pub fn get_state(
            &self,
        ) -> Result<crate::services::space_center::SolarPanelState, RpcError> {
            let request = crate::schema::Request::from(self.get_state_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::SolarPanelState>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl SolarPanel {
        pub(crate) fn get_sun_exposure_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "SolarPanel_get_SunExposure",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_sun_exposure_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_sun_exposure_call()?,
            )
        }
        pub fn get_sun_exposure(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_sun_exposure_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl SolarPanel {
        pub(crate) fn set_deployed_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "SolarPanel_set_Deployed",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_deployed_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_deployed_call(value)?,
            )
        }
        pub fn set_deployed(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_deployed_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Thruster {
        pub(crate) fn gimbal_position_call(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Thruster_GimbalPosition",
                    vec![
                        self.to_argument(0usize as u32) ?, reference_frame
                        .to_argument(1usize as u32) ?
                    ],
                ),
            )
        }
        pub fn gimbal_position_stream(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::stream::Stream<(f64, f64, f64)>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.gimbal_position_call(reference_frame)?,
            )
        }
        pub fn gimbal_position(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<(f64, f64, f64), RpcError> {
            let request = crate::schema::Request::from(
                self.gimbal_position_call(reference_frame)?,
            );
            let response = self.client.call(request)?;
            <(f64, f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl Thruster {
        pub(crate) fn initial_thrust_direction_call(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Thruster_InitialThrustDirection",
                    vec![
                        self.to_argument(0usize as u32) ?, reference_frame
                        .to_argument(1usize as u32) ?
                    ],
                ),
            )
        }
        pub fn initial_thrust_direction_stream(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::stream::Stream<(f64, f64, f64)>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.initial_thrust_direction_call(reference_frame)?,
            )
        }
        pub fn initial_thrust_direction(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<(f64, f64, f64), RpcError> {
            let request = crate::schema::Request::from(
                self.initial_thrust_direction_call(reference_frame)?,
            );
            let response = self.client.call(request)?;
            <(f64, f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl Thruster {
        pub(crate) fn initial_thrust_position_call(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Thruster_InitialThrustPosition",
                    vec![
                        self.to_argument(0usize as u32) ?, reference_frame
                        .to_argument(1usize as u32) ?
                    ],
                ),
            )
        }
        pub fn initial_thrust_position_stream(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::stream::Stream<(f64, f64, f64)>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.initial_thrust_position_call(reference_frame)?,
            )
        }
        pub fn initial_thrust_position(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<(f64, f64, f64), RpcError> {
            let request = crate::schema::Request::from(
                self.initial_thrust_position_call(reference_frame)?,
            );
            let response = self.client.call(request)?;
            <(f64, f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl Thruster {
        pub(crate) fn thrust_direction_call(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Thruster_ThrustDirection",
                    vec![
                        self.to_argument(0usize as u32) ?, reference_frame
                        .to_argument(1usize as u32) ?
                    ],
                ),
            )
        }
        pub fn thrust_direction_stream(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::stream::Stream<(f64, f64, f64)>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.thrust_direction_call(reference_frame)?,
            )
        }
        pub fn thrust_direction(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<(f64, f64, f64), RpcError> {
            let request = crate::schema::Request::from(
                self.thrust_direction_call(reference_frame)?,
            );
            let response = self.client.call(request)?;
            <(f64, f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl Thruster {
        pub(crate) fn thrust_position_call(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Thruster_ThrustPosition",
                    vec![
                        self.to_argument(0usize as u32) ?, reference_frame
                        .to_argument(1usize as u32) ?
                    ],
                ),
            )
        }
        pub fn thrust_position_stream(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::stream::Stream<(f64, f64, f64)>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.thrust_position_call(reference_frame)?,
            )
        }
        pub fn thrust_position(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<(f64, f64, f64), RpcError> {
            let request = crate::schema::Request::from(
                self.thrust_position_call(reference_frame)?,
            );
            let response = self.client.call(request)?;
            <(f64, f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl Thruster {
        pub(crate) fn get_gimbal_angle_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Thruster_get_GimbalAngle",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_gimbal_angle_stream(
            &self,
        ) -> Result<crate::stream::Stream<(f64, f64, f64)>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_gimbal_angle_call()?,
            )
        }
        pub fn get_gimbal_angle(&self) -> Result<(f64, f64, f64), RpcError> {
            let request = crate::schema::Request::from(self.get_gimbal_angle_call()?);
            let response = self.client.call(request)?;
            <(f64, f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl Thruster {
        pub(crate) fn get_gimballed_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Thruster_get_Gimballed",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_gimballed_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_gimballed_call()?)
        }
        pub fn get_gimballed(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_gimballed_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Thruster {
        pub(crate) fn get_part_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Thruster_get_Part",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_part_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::Part>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_part_call()?)
        }
        pub fn get_part(&self) -> Result<crate::services::space_center::Part, RpcError> {
            let request = crate::schema::Request::from(self.get_part_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::Part>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Thruster {
        pub(crate) fn get_thrust_reference_frame_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Thruster_get_ThrustReferenceFrame",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_thrust_reference_frame_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::ReferenceFrame>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_thrust_reference_frame_call()?,
            )
        }
        pub fn get_thrust_reference_frame(
            &self,
        ) -> Result<crate::services::space_center::ReferenceFrame, RpcError> {
            let request = crate::schema::Request::from(
                self.get_thrust_reference_frame_call()?,
            );
            let response = self.client.call(request)?;
            <crate::services::space_center::ReferenceFrame>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl SpaceCenter {
        pub(crate) fn transfer_crew_call(
            &self,
            crew_member: &crate::services::space_center::CrewMember,
            target_part: &crate::services::space_center::Part,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "TransferCrew",
                    vec![
                        crew_member.to_argument(0usize as u32) ?, target_part
                        .to_argument(1usize as u32) ?
                    ],
                ),
            )
        }
        pub fn transfer_crew_stream(
            &self,
            crew_member: &crate::services::space_center::CrewMember,
            target_part: &crate::services::space_center::Part,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.transfer_crew_call(crew_member, target_part)?,
            )
        }
        pub fn transfer_crew(
            &self,
            crew_member: &crate::services::space_center::CrewMember,
            target_part: &crate::services::space_center::Part,
        ) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.transfer_crew_call(crew_member, target_part)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl SpaceCenter {
        pub(crate) fn transform_direction_call(
            &self,
            direction: (f64, f64, f64),
            from: &crate::services::space_center::ReferenceFrame,
            to: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "TransformDirection",
                    vec![
                        direction.to_argument(0usize as u32) ?, from.to_argument(1usize
                        as u32) ?, to.to_argument(2usize as u32) ?
                    ],
                ),
            )
        }
        pub fn transform_direction_stream(
            &self,
            direction: (f64, f64, f64),
            from: &crate::services::space_center::ReferenceFrame,
            to: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::stream::Stream<(f64, f64, f64)>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.transform_direction_call(direction, from, to)?,
            )
        }
        pub fn transform_direction(
            &self,
            direction: (f64, f64, f64),
            from: &crate::services::space_center::ReferenceFrame,
            to: &crate::services::space_center::ReferenceFrame,
        ) -> Result<(f64, f64, f64), RpcError> {
            let request = crate::schema::Request::from(
                self.transform_direction_call(direction, from, to)?,
            );
            let response = self.client.call(request)?;
            <(f64, f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl SpaceCenter {
        pub(crate) fn transform_position_call(
            &self,
            position: (f64, f64, f64),
            from: &crate::services::space_center::ReferenceFrame,
            to: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "TransformPosition",
                    vec![
                        position.to_argument(0usize as u32) ?, from.to_argument(1usize as
                        u32) ?, to.to_argument(2usize as u32) ?
                    ],
                ),
            )
        }
        pub fn transform_position_stream(
            &self,
            position: (f64, f64, f64),
            from: &crate::services::space_center::ReferenceFrame,
            to: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::stream::Stream<(f64, f64, f64)>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.transform_position_call(position, from, to)?,
            )
        }
        pub fn transform_position(
            &self,
            position: (f64, f64, f64),
            from: &crate::services::space_center::ReferenceFrame,
            to: &crate::services::space_center::ReferenceFrame,
        ) -> Result<(f64, f64, f64), RpcError> {
            let request = crate::schema::Request::from(
                self.transform_position_call(position, from, to)?,
            );
            let response = self.client.call(request)?;
            <(f64, f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl SpaceCenter {
        pub(crate) fn transform_rotation_call(
            &self,
            rotation: (f64, f64, f64, f64),
            from: &crate::services::space_center::ReferenceFrame,
            to: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "TransformRotation",
                    vec![
                        rotation.to_argument(0usize as u32) ?, from.to_argument(1usize as
                        u32) ?, to.to_argument(2usize as u32) ?
                    ],
                ),
            )
        }
        pub fn transform_rotation_stream(
            &self,
            rotation: (f64, f64, f64, f64),
            from: &crate::services::space_center::ReferenceFrame,
            to: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::stream::Stream<(f64, f64, f64, f64)>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.transform_rotation_call(rotation, from, to)?,
            )
        }
        pub fn transform_rotation(
            &self,
            rotation: (f64, f64, f64, f64),
            from: &crate::services::space_center::ReferenceFrame,
            to: &crate::services::space_center::ReferenceFrame,
        ) -> Result<(f64, f64, f64, f64), RpcError> {
            let request = crate::schema::Request::from(
                self.transform_rotation_call(rotation, from, to)?,
            );
            let response = self.client.call(request)?;
            <(f64, f64, f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl SpaceCenter {
        pub(crate) fn transform_velocity_call(
            &self,
            position: (f64, f64, f64),
            velocity: (f64, f64, f64),
            from: &crate::services::space_center::ReferenceFrame,
            to: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "TransformVelocity",
                    vec![
                        position.to_argument(0usize as u32) ?, velocity
                        .to_argument(1usize as u32) ?, from.to_argument(2usize as u32) ?,
                        to.to_argument(3usize as u32) ?
                    ],
                ),
            )
        }
        pub fn transform_velocity_stream(
            &self,
            position: (f64, f64, f64),
            velocity: (f64, f64, f64),
            from: &crate::services::space_center::ReferenceFrame,
            to: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::stream::Stream<(f64, f64, f64)>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.transform_velocity_call(position, velocity, from, to)?,
            )
        }
        pub fn transform_velocity(
            &self,
            position: (f64, f64, f64),
            velocity: (f64, f64, f64),
            from: &crate::services::space_center::ReferenceFrame,
            to: &crate::services::space_center::ReferenceFrame,
        ) -> Result<(f64, f64, f64), RpcError> {
            let request = crate::schema::Request::from(
                self.transform_velocity_call(position, velocity, from, to)?,
            );
            let response = self.client.call(request)?;
            <(f64, f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl Vessel {
        pub(crate) fn angular_velocity_call(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Vessel_AngularVelocity",
                    vec![
                        self.to_argument(0usize as u32) ?, reference_frame
                        .to_argument(1usize as u32) ?
                    ],
                ),
            )
        }
        pub fn angular_velocity_stream(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::stream::Stream<(f64, f64, f64)>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.angular_velocity_call(reference_frame)?,
            )
        }
        pub fn angular_velocity(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<(f64, f64, f64), RpcError> {
            let request = crate::schema::Request::from(
                self.angular_velocity_call(reference_frame)?,
            );
            let response = self.client.call(request)?;
            <(f64, f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl Vessel {
        pub(crate) fn available_thrust_at_call(
            &self,
            pressure: f64,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Vessel_AvailableThrustAt",
                    vec![
                        self.to_argument(0usize as u32) ?, pressure.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn available_thrust_at_stream(
            &self,
            pressure: f64,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.available_thrust_at_call(pressure)?,
            )
        }
        pub fn available_thrust_at(&self, pressure: f64) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(
                self.available_thrust_at_call(pressure)?,
            );
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Vessel {
        pub(crate) fn bounding_box_call(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Vessel_BoundingBox",
                    vec![
                        self.to_argument(0usize as u32) ?, reference_frame
                        .to_argument(1usize as u32) ?
                    ],
                ),
            )
        }
        pub fn bounding_box_stream(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<
            crate::stream::Stream<((f64, f64, f64), (f64, f64, f64))>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.bounding_box_call(reference_frame)?,
            )
        }
        pub fn bounding_box(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<((f64, f64, f64), (f64, f64, f64)), RpcError> {
            let request = crate::schema::Request::from(
                self.bounding_box_call(reference_frame)?,
            );
            let response = self.client.call(request)?;
            <(
                (f64, f64, f64),
                (f64, f64, f64),
            )>::from_response(response, self.client.clone())
        }
    }
    impl Vessel {
        pub(crate) fn direction_call(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Vessel_Direction",
                    vec![
                        self.to_argument(0usize as u32) ?, reference_frame
                        .to_argument(1usize as u32) ?
                    ],
                ),
            )
        }
        pub fn direction_stream(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::stream::Stream<(f64, f64, f64)>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.direction_call(reference_frame)?,
            )
        }
        pub fn direction(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<(f64, f64, f64), RpcError> {
            let request = crate::schema::Request::from(
                self.direction_call(reference_frame)?,
            );
            let response = self.client.call(request)?;
            <(f64, f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl Vessel {
        pub(crate) fn flight_call(
            &self,
            reference_frame: Option<&crate::services::space_center::ReferenceFrame>,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Vessel_Flight",
                    vec![
                        self.to_argument(0usize as u32) ?, reference_frame
                        .to_argument(1usize as u32) ?
                    ],
                ),
            )
        }
        pub fn flight_stream(
            &self,
            reference_frame: Option<&crate::services::space_center::ReferenceFrame>,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::Flight>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.flight_call(reference_frame)?,
            )
        }
        pub fn flight(
            &self,
            reference_frame: Option<&crate::services::space_center::ReferenceFrame>,
        ) -> Result<crate::services::space_center::Flight, RpcError> {
            let request = crate::schema::Request::from(
                self.flight_call(reference_frame)?,
            );
            let response = self.client.call(request)?;
            <crate::services::space_center::Flight>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Vessel {
        pub(crate) fn max_thrust_at_call(
            &self,
            pressure: f64,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Vessel_MaxThrustAt",
                    vec![
                        self.to_argument(0usize as u32) ?, pressure.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn max_thrust_at_stream(
            &self,
            pressure: f64,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.max_thrust_at_call(pressure)?,
            )
        }
        pub fn max_thrust_at(&self, pressure: f64) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(
                self.max_thrust_at_call(pressure)?,
            );
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Vessel {
        pub(crate) fn position_call(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Vessel_Position",
                    vec![
                        self.to_argument(0usize as u32) ?, reference_frame
                        .to_argument(1usize as u32) ?
                    ],
                ),
            )
        }
        pub fn position_stream(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::stream::Stream<(f64, f64, f64)>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.position_call(reference_frame)?,
            )
        }
        pub fn position(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<(f64, f64, f64), RpcError> {
            let request = crate::schema::Request::from(
                self.position_call(reference_frame)?,
            );
            let response = self.client.call(request)?;
            <(f64, f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl Vessel {
        pub(crate) fn recover_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Vessel_Recover",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn recover_stream(&self) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.recover_call()?)
        }
        pub fn recover(&self) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.recover_call()?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Vessel {
        pub(crate) fn resources_in_decouple_stage_call(
            &self,
            stage: i32,
            cumulative: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Vessel_ResourcesInDecoupleStage",
                    vec![
                        self.to_argument(0usize as u32) ?, stage.to_argument(1usize as
                        u32) ?, cumulative.to_argument(2usize as u32) ?
                    ],
                ),
            )
        }
        pub fn resources_in_decouple_stage_stream(
            &self,
            stage: i32,
            cumulative: bool,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::Resources>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.resources_in_decouple_stage_call(stage, cumulative)?,
            )
        }
        pub fn resources_in_decouple_stage(
            &self,
            stage: i32,
            cumulative: bool,
        ) -> Result<crate::services::space_center::Resources, RpcError> {
            let request = crate::schema::Request::from(
                self.resources_in_decouple_stage_call(stage, cumulative)?,
            );
            let response = self.client.call(request)?;
            <crate::services::space_center::Resources>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Vessel {
        pub(crate) fn rotation_call(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Vessel_Rotation",
                    vec![
                        self.to_argument(0usize as u32) ?, reference_frame
                        .to_argument(1usize as u32) ?
                    ],
                ),
            )
        }
        pub fn rotation_stream(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::stream::Stream<(f64, f64, f64, f64)>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.rotation_call(reference_frame)?,
            )
        }
        pub fn rotation(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<(f64, f64, f64, f64), RpcError> {
            let request = crate::schema::Request::from(
                self.rotation_call(reference_frame)?,
            );
            let response = self.client.call(request)?;
            <(f64, f64, f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl Vessel {
        pub(crate) fn specific_impulse_at_call(
            &self,
            pressure: f64,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Vessel_SpecificImpulseAt",
                    vec![
                        self.to_argument(0usize as u32) ?, pressure.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn specific_impulse_at_stream(
            &self,
            pressure: f64,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.specific_impulse_at_call(pressure)?,
            )
        }
        pub fn specific_impulse_at(&self, pressure: f64) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(
                self.specific_impulse_at_call(pressure)?,
            );
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Vessel {
        pub(crate) fn velocity_call(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Vessel_Velocity",
                    vec![
                        self.to_argument(0usize as u32) ?, reference_frame
                        .to_argument(1usize as u32) ?
                    ],
                ),
            )
        }
        pub fn velocity_stream(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<crate::stream::Stream<(f64, f64, f64)>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.velocity_call(reference_frame)?,
            )
        }
        pub fn velocity(
            &self,
            reference_frame: &crate::services::space_center::ReferenceFrame,
        ) -> Result<(f64, f64, f64), RpcError> {
            let request = crate::schema::Request::from(
                self.velocity_call(reference_frame)?,
            );
            let response = self.client.call(request)?;
            <(f64, f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl Vessel {
        pub(crate) fn get_auto_pilot_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Vessel_get_AutoPilot",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_auto_pilot_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::AutoPilot>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_auto_pilot_call()?)
        }
        pub fn get_auto_pilot(
            &self,
        ) -> Result<crate::services::space_center::AutoPilot, RpcError> {
            let request = crate::schema::Request::from(self.get_auto_pilot_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::AutoPilot>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Vessel {
        pub(crate) fn get_available_control_surface_torque_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Vessel_get_AvailableControlSurfaceTorque",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_available_control_surface_torque_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<((f64, f64, f64), (f64, f64, f64))>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_available_control_surface_torque_call()?,
            )
        }
        pub fn get_available_control_surface_torque(
            &self,
        ) -> Result<((f64, f64, f64), (f64, f64, f64)), RpcError> {
            let request = crate::schema::Request::from(
                self.get_available_control_surface_torque_call()?,
            );
            let response = self.client.call(request)?;
            <(
                (f64, f64, f64),
                (f64, f64, f64),
            )>::from_response(response, self.client.clone())
        }
    }
    impl Vessel {
        pub(crate) fn get_available_engine_torque_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Vessel_get_AvailableEngineTorque",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_available_engine_torque_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<((f64, f64, f64), (f64, f64, f64))>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_available_engine_torque_call()?,
            )
        }
        pub fn get_available_engine_torque(
            &self,
        ) -> Result<((f64, f64, f64), (f64, f64, f64)), RpcError> {
            let request = crate::schema::Request::from(
                self.get_available_engine_torque_call()?,
            );
            let response = self.client.call(request)?;
            <(
                (f64, f64, f64),
                (f64, f64, f64),
            )>::from_response(response, self.client.clone())
        }
    }
    impl Vessel {
        pub(crate) fn get_available_other_torque_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Vessel_get_AvailableOtherTorque",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_available_other_torque_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<((f64, f64, f64), (f64, f64, f64))>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_available_other_torque_call()?,
            )
        }
        pub fn get_available_other_torque(
            &self,
        ) -> Result<((f64, f64, f64), (f64, f64, f64)), RpcError> {
            let request = crate::schema::Request::from(
                self.get_available_other_torque_call()?,
            );
            let response = self.client.call(request)?;
            <(
                (f64, f64, f64),
                (f64, f64, f64),
            )>::from_response(response, self.client.clone())
        }
    }
    impl Vessel {
        pub(crate) fn get_available_rcs_force_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Vessel_get_AvailableRCSForce",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_available_rcs_force_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<((f64, f64, f64), (f64, f64, f64))>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_available_rcs_force_call()?,
            )
        }
        pub fn get_available_rcs_force(
            &self,
        ) -> Result<((f64, f64, f64), (f64, f64, f64)), RpcError> {
            let request = crate::schema::Request::from(
                self.get_available_rcs_force_call()?,
            );
            let response = self.client.call(request)?;
            <(
                (f64, f64, f64),
                (f64, f64, f64),
            )>::from_response(response, self.client.clone())
        }
    }
    impl Vessel {
        pub(crate) fn get_available_rcs_torque_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Vessel_get_AvailableRCSTorque",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_available_rcs_torque_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<((f64, f64, f64), (f64, f64, f64))>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_available_rcs_torque_call()?,
            )
        }
        pub fn get_available_rcs_torque(
            &self,
        ) -> Result<((f64, f64, f64), (f64, f64, f64)), RpcError> {
            let request = crate::schema::Request::from(
                self.get_available_rcs_torque_call()?,
            );
            let response = self.client.call(request)?;
            <(
                (f64, f64, f64),
                (f64, f64, f64),
            )>::from_response(response, self.client.clone())
        }
    }
    impl Vessel {
        pub(crate) fn get_available_reaction_wheel_torque_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Vessel_get_AvailableReactionWheelTorque",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_available_reaction_wheel_torque_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<((f64, f64, f64), (f64, f64, f64))>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_available_reaction_wheel_torque_call()?,
            )
        }
        pub fn get_available_reaction_wheel_torque(
            &self,
        ) -> Result<((f64, f64, f64), (f64, f64, f64)), RpcError> {
            let request = crate::schema::Request::from(
                self.get_available_reaction_wheel_torque_call()?,
            );
            let response = self.client.call(request)?;
            <(
                (f64, f64, f64),
                (f64, f64, f64),
            )>::from_response(response, self.client.clone())
        }
    }
    impl Vessel {
        pub(crate) fn get_available_thrust_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Vessel_get_AvailableThrust",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_available_thrust_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_available_thrust_call()?,
            )
        }
        pub fn get_available_thrust(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(
                self.get_available_thrust_call()?,
            );
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Vessel {
        pub(crate) fn get_available_torque_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Vessel_get_AvailableTorque",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_available_torque_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<((f64, f64, f64), (f64, f64, f64))>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_available_torque_call()?,
            )
        }
        pub fn get_available_torque(
            &self,
        ) -> Result<((f64, f64, f64), (f64, f64, f64)), RpcError> {
            let request = crate::schema::Request::from(
                self.get_available_torque_call()?,
            );
            let response = self.client.call(request)?;
            <(
                (f64, f64, f64),
                (f64, f64, f64),
            )>::from_response(response, self.client.clone())
        }
    }
    impl Vessel {
        pub(crate) fn get_biome_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Vessel_get_Biome",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_biome_stream(
            &self,
        ) -> Result<crate::stream::Stream<String>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_biome_call()?)
        }
        pub fn get_biome(&self) -> Result<String, RpcError> {
            let request = crate::schema::Request::from(self.get_biome_call()?);
            let response = self.client.call(request)?;
            <String>::from_response(response, self.client.clone())
        }
    }
    impl Vessel {
        pub(crate) fn get_comms_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Vessel_get_Comms",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_comms_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::Comms>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_comms_call()?)
        }
        pub fn get_comms(
            &self,
        ) -> Result<crate::services::space_center::Comms, RpcError> {
            let request = crate::schema::Request::from(self.get_comms_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::Comms>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Vessel {
        pub(crate) fn get_control_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Vessel_get_Control",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_control_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::Control>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_control_call()?)
        }
        pub fn get_control(
            &self,
        ) -> Result<crate::services::space_center::Control, RpcError> {
            let request = crate::schema::Request::from(self.get_control_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::Control>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Vessel {
        pub(crate) fn get_crew_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Vessel_get_Crew",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_crew_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Vec<crate::services::space_center::CrewMember>>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_crew_call()?)
        }
        pub fn get_crew(
            &self,
        ) -> Result<Vec<crate::services::space_center::CrewMember>, RpcError> {
            let request = crate::schema::Request::from(self.get_crew_call()?);
            let response = self.client.call(request)?;
            <Vec<
                crate::services::space_center::CrewMember,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Vessel {
        pub(crate) fn get_crew_capacity_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Vessel_get_CrewCapacity",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_crew_capacity_stream(
            &self,
        ) -> Result<crate::stream::Stream<i32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_crew_capacity_call()?,
            )
        }
        pub fn get_crew_capacity(&self) -> Result<i32, RpcError> {
            let request = crate::schema::Request::from(self.get_crew_capacity_call()?);
            let response = self.client.call(request)?;
            <i32>::from_response(response, self.client.clone())
        }
    }
    impl Vessel {
        pub(crate) fn get_crew_count_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Vessel_get_CrewCount",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_crew_count_stream(
            &self,
        ) -> Result<crate::stream::Stream<i32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_crew_count_call()?)
        }
        pub fn get_crew_count(&self) -> Result<i32, RpcError> {
            let request = crate::schema::Request::from(self.get_crew_count_call()?);
            let response = self.client.call(request)?;
            <i32>::from_response(response, self.client.clone())
        }
    }
    impl Vessel {
        pub(crate) fn get_dry_mass_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Vessel_get_DryMass",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_dry_mass_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_dry_mass_call()?)
        }
        pub fn get_dry_mass(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_dry_mass_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Vessel {
        pub(crate) fn get_inertia_tensor_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Vessel_get_InertiaTensor",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_inertia_tensor_stream(
            &self,
        ) -> Result<crate::stream::Stream<Vec<f64>>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_inertia_tensor_call()?,
            )
        }
        pub fn get_inertia_tensor(&self) -> Result<Vec<f64>, RpcError> {
            let request = crate::schema::Request::from(self.get_inertia_tensor_call()?);
            let response = self.client.call(request)?;
            <Vec<f64>>::from_response(response, self.client.clone())
        }
    }
    impl Vessel {
        pub(crate) fn get_kerbin_sea_level_specific_impulse_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Vessel_get_KerbinSeaLevelSpecificImpulse",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_kerbin_sea_level_specific_impulse_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_kerbin_sea_level_specific_impulse_call()?,
            )
        }
        pub fn get_kerbin_sea_level_specific_impulse(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(
                self.get_kerbin_sea_level_specific_impulse_call()?,
            );
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Vessel {
        pub(crate) fn get_met_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Vessel_get_MET",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_met_stream(&self) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_met_call()?)
        }
        pub fn get_met(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(self.get_met_call()?);
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Vessel {
        pub(crate) fn get_mass_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Vessel_get_Mass",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_mass_stream(&self) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_mass_call()?)
        }
        pub fn get_mass(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_mass_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Vessel {
        pub(crate) fn get_max_thrust_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Vessel_get_MaxThrust",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_max_thrust_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_max_thrust_call()?)
        }
        pub fn get_max_thrust(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_max_thrust_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Vessel {
        pub(crate) fn get_max_vacuum_thrust_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Vessel_get_MaxVacuumThrust",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_max_vacuum_thrust_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_max_vacuum_thrust_call()?,
            )
        }
        pub fn get_max_vacuum_thrust(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(
                self.get_max_vacuum_thrust_call()?,
            );
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Vessel {
        pub(crate) fn get_moment_of_inertia_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Vessel_get_MomentOfInertia",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_moment_of_inertia_stream(
            &self,
        ) -> Result<crate::stream::Stream<(f64, f64, f64)>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_moment_of_inertia_call()?,
            )
        }
        pub fn get_moment_of_inertia(&self) -> Result<(f64, f64, f64), RpcError> {
            let request = crate::schema::Request::from(
                self.get_moment_of_inertia_call()?,
            );
            let response = self.client.call(request)?;
            <(f64, f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl Vessel {
        pub(crate) fn get_name_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Vessel_get_Name",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_name_stream(
            &self,
        ) -> Result<crate::stream::Stream<String>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_name_call()?)
        }
        pub fn get_name(&self) -> Result<String, RpcError> {
            let request = crate::schema::Request::from(self.get_name_call()?);
            let response = self.client.call(request)?;
            <String>::from_response(response, self.client.clone())
        }
    }
    impl Vessel {
        pub(crate) fn get_orbit_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Vessel_get_Orbit",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_orbit_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::Orbit>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_orbit_call()?)
        }
        pub fn get_orbit(
            &self,
        ) -> Result<crate::services::space_center::Orbit, RpcError> {
            let request = crate::schema::Request::from(self.get_orbit_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::Orbit>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Vessel {
        pub(crate) fn get_orbital_reference_frame_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Vessel_get_OrbitalReferenceFrame",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_orbital_reference_frame_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::ReferenceFrame>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_orbital_reference_frame_call()?,
            )
        }
        pub fn get_orbital_reference_frame(
            &self,
        ) -> Result<crate::services::space_center::ReferenceFrame, RpcError> {
            let request = crate::schema::Request::from(
                self.get_orbital_reference_frame_call()?,
            );
            let response = self.client.call(request)?;
            <crate::services::space_center::ReferenceFrame>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Vessel {
        pub(crate) fn get_parts_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Vessel_get_Parts",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_parts_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::Parts>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_parts_call()?)
        }
        pub fn get_parts(
            &self,
        ) -> Result<crate::services::space_center::Parts, RpcError> {
            let request = crate::schema::Request::from(self.get_parts_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::Parts>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Vessel {
        pub(crate) fn get_recoverable_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Vessel_get_Recoverable",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_recoverable_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_recoverable_call()?)
        }
        pub fn get_recoverable(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_recoverable_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Vessel {
        pub(crate) fn get_reference_frame_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Vessel_get_ReferenceFrame",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_reference_frame_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::ReferenceFrame>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_reference_frame_call()?,
            )
        }
        pub fn get_reference_frame(
            &self,
        ) -> Result<crate::services::space_center::ReferenceFrame, RpcError> {
            let request = crate::schema::Request::from(self.get_reference_frame_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::ReferenceFrame>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Vessel {
        pub(crate) fn get_resources_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Vessel_get_Resources",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_resources_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::Resources>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_resources_call()?)
        }
        pub fn get_resources(
            &self,
        ) -> Result<crate::services::space_center::Resources, RpcError> {
            let request = crate::schema::Request::from(self.get_resources_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::Resources>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Vessel {
        pub(crate) fn get_situation_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Vessel_get_Situation",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_situation_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::VesselSituation>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_situation_call()?)
        }
        pub fn get_situation(
            &self,
        ) -> Result<crate::services::space_center::VesselSituation, RpcError> {
            let request = crate::schema::Request::from(self.get_situation_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::VesselSituation>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Vessel {
        pub(crate) fn get_specific_impulse_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Vessel_get_SpecificImpulse",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_specific_impulse_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_specific_impulse_call()?,
            )
        }
        pub fn get_specific_impulse(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(
                self.get_specific_impulse_call()?,
            );
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Vessel {
        pub(crate) fn get_surface_reference_frame_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Vessel_get_SurfaceReferenceFrame",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_surface_reference_frame_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::ReferenceFrame>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_surface_reference_frame_call()?,
            )
        }
        pub fn get_surface_reference_frame(
            &self,
        ) -> Result<crate::services::space_center::ReferenceFrame, RpcError> {
            let request = crate::schema::Request::from(
                self.get_surface_reference_frame_call()?,
            );
            let response = self.client.call(request)?;
            <crate::services::space_center::ReferenceFrame>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Vessel {
        pub(crate) fn get_surface_velocity_reference_frame_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Vessel_get_SurfaceVelocityReferenceFrame",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_surface_velocity_reference_frame_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::ReferenceFrame>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_surface_velocity_reference_frame_call()?,
            )
        }
        pub fn get_surface_velocity_reference_frame(
            &self,
        ) -> Result<crate::services::space_center::ReferenceFrame, RpcError> {
            let request = crate::schema::Request::from(
                self.get_surface_velocity_reference_frame_call()?,
            );
            let response = self.client.call(request)?;
            <crate::services::space_center::ReferenceFrame>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Vessel {
        pub(crate) fn get_thrust_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Vessel_get_Thrust",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_thrust_stream(&self) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_thrust_call()?)
        }
        pub fn get_thrust(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_thrust_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Vessel {
        pub(crate) fn get_type_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Vessel_get_Type",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_type_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::VesselType>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_type_call()?)
        }
        pub fn get_type(
            &self,
        ) -> Result<crate::services::space_center::VesselType, RpcError> {
            let request = crate::schema::Request::from(self.get_type_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::VesselType>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Vessel {
        pub(crate) fn get_vacuum_specific_impulse_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Vessel_get_VacuumSpecificImpulse",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_vacuum_specific_impulse_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_vacuum_specific_impulse_call()?,
            )
        }
        pub fn get_vacuum_specific_impulse(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(
                self.get_vacuum_specific_impulse_call()?,
            );
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Vessel {
        pub(crate) fn set_name_call(
            &self,
            value: String,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Vessel_set_Name",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_name_stream(
            &self,
            value: String,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.set_name_call(value)?)
        }
        pub fn set_name(&self, value: String) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_name_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Vessel {
        pub(crate) fn set_type_call(
            &self,
            value: crate::services::space_center::VesselType,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Vessel_set_Type",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_type_stream(
            &self,
            value: crate::services::space_center::VesselType,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.set_type_call(value)?)
        }
        pub fn set_type(
            &self,
            value: crate::services::space_center::VesselType,
        ) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_type_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl SpaceCenter {
        pub(crate) fn warp_to_call(
            &self,
            ut: f64,
            max_rails_rate: f32,
            max_physics_rate: f32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "WarpTo",
                    vec![
                        ut.to_argument(0usize as u32) ?, max_rails_rate
                        .to_argument(1usize as u32) ?, max_physics_rate
                        .to_argument(2usize as u32) ?
                    ],
                ),
            )
        }
        pub fn warp_to_stream(
            &self,
            ut: f64,
            max_rails_rate: f32,
            max_physics_rate: f32,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.warp_to_call(ut, max_rails_rate, max_physics_rate)?,
            )
        }
        pub fn warp_to(
            &self,
            ut: f64,
            max_rails_rate: f32,
            max_physics_rate: f32,
        ) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.warp_to_call(ut, max_rails_rate, max_physics_rate)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl WaypointManager {
        pub(crate) fn add_waypoint_call(
            &self,
            latitude: f64,
            longitude: f64,
            body: &crate::services::space_center::CelestialBody,
            name: String,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "WaypointManager_AddWaypoint",
                    vec![
                        self.to_argument(0usize as u32) ?, latitude.to_argument(1usize as
                        u32) ?, longitude.to_argument(2usize as u32) ?, body
                        .to_argument(3usize as u32) ?, name.to_argument(4usize as u32) ?
                    ],
                ),
            )
        }
        pub fn add_waypoint_stream(
            &self,
            latitude: f64,
            longitude: f64,
            body: &crate::services::space_center::CelestialBody,
            name: String,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::Waypoint>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.add_waypoint_call(latitude, longitude, body, name)?,
            )
        }
        pub fn add_waypoint(
            &self,
            latitude: f64,
            longitude: f64,
            body: &crate::services::space_center::CelestialBody,
            name: String,
        ) -> Result<crate::services::space_center::Waypoint, RpcError> {
            let request = crate::schema::Request::from(
                self.add_waypoint_call(latitude, longitude, body, name)?,
            );
            let response = self.client.call(request)?;
            <crate::services::space_center::Waypoint>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl WaypointManager {
        pub(crate) fn add_waypoint_at_altitude_call(
            &self,
            latitude: f64,
            longitude: f64,
            altitude: f64,
            body: &crate::services::space_center::CelestialBody,
            name: String,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "WaypointManager_AddWaypointAtAltitude",
                    vec![
                        self.to_argument(0usize as u32) ?, latitude.to_argument(1usize as
                        u32) ?, longitude.to_argument(2usize as u32) ?, altitude
                        .to_argument(3usize as u32) ?, body.to_argument(4usize as u32) ?,
                        name.to_argument(5usize as u32) ?
                    ],
                ),
            )
        }
        pub fn add_waypoint_at_altitude_stream(
            &self,
            latitude: f64,
            longitude: f64,
            altitude: f64,
            body: &crate::services::space_center::CelestialBody,
            name: String,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::Waypoint>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self
                    .add_waypoint_at_altitude_call(
                        latitude,
                        longitude,
                        altitude,
                        body,
                        name,
                    )?,
            )
        }
        pub fn add_waypoint_at_altitude(
            &self,
            latitude: f64,
            longitude: f64,
            altitude: f64,
            body: &crate::services::space_center::CelestialBody,
            name: String,
        ) -> Result<crate::services::space_center::Waypoint, RpcError> {
            let request = crate::schema::Request::from(
                self
                    .add_waypoint_at_altitude_call(
                        latitude,
                        longitude,
                        altitude,
                        body,
                        name,
                    )?,
            );
            let response = self.client.call(request)?;
            <crate::services::space_center::Waypoint>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl WaypointManager {
        pub(crate) fn get_colors_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "WaypointManager_get_Colors",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_colors_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<std::collections::HashMap<String, i32>>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_colors_call()?)
        }
        pub fn get_colors(
            &self,
        ) -> Result<std::collections::HashMap<String, i32>, RpcError> {
            let request = crate::schema::Request::from(self.get_colors_call()?);
            let response = self.client.call(request)?;
            <std::collections::HashMap<
                String,
                i32,
            >>::from_response(response, self.client.clone())
        }
    }
    impl WaypointManager {
        pub(crate) fn get_icons_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "WaypointManager_get_Icons",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_icons_stream(
            &self,
        ) -> Result<crate::stream::Stream<Vec<String>>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_icons_call()?)
        }
        pub fn get_icons(&self) -> Result<Vec<String>, RpcError> {
            let request = crate::schema::Request::from(self.get_icons_call()?);
            let response = self.client.call(request)?;
            <Vec<String>>::from_response(response, self.client.clone())
        }
    }
    impl WaypointManager {
        pub(crate) fn get_waypoints_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "WaypointManager_get_Waypoints",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_waypoints_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Vec<crate::services::space_center::Waypoint>>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_waypoints_call()?)
        }
        pub fn get_waypoints(
            &self,
        ) -> Result<Vec<crate::services::space_center::Waypoint>, RpcError> {
            let request = crate::schema::Request::from(self.get_waypoints_call()?);
            let response = self.client.call(request)?;
            <Vec<
                crate::services::space_center::Waypoint,
            >>::from_response(response, self.client.clone())
        }
    }
    impl Waypoint {
        pub(crate) fn remove_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Waypoint_Remove",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn remove_stream(&self) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.remove_call()?)
        }
        pub fn remove(&self) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.remove_call()?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Waypoint {
        pub(crate) fn get_bedrock_altitude_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Waypoint_get_BedrockAltitude",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_bedrock_altitude_stream(
            &self,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_bedrock_altitude_call()?,
            )
        }
        pub fn get_bedrock_altitude(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(
                self.get_bedrock_altitude_call()?,
            );
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Waypoint {
        pub(crate) fn get_body_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Waypoint_get_Body",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_body_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::CelestialBody>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_body_call()?)
        }
        pub fn get_body(
            &self,
        ) -> Result<crate::services::space_center::CelestialBody, RpcError> {
            let request = crate::schema::Request::from(self.get_body_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::CelestialBody>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Waypoint {
        pub(crate) fn get_clustered_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Waypoint_get_Clustered",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_clustered_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_clustered_call()?)
        }
        pub fn get_clustered(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_clustered_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Waypoint {
        pub(crate) fn get_color_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Waypoint_get_Color",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_color_stream(&self) -> Result<crate::stream::Stream<i32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_color_call()?)
        }
        pub fn get_color(&self) -> Result<i32, RpcError> {
            let request = crate::schema::Request::from(self.get_color_call()?);
            let response = self.client.call(request)?;
            <i32>::from_response(response, self.client.clone())
        }
    }
    impl Waypoint {
        pub(crate) fn get_contract_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Waypoint_get_Contract",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_contract_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::Contract>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_contract_call()?)
        }
        pub fn get_contract(
            &self,
        ) -> Result<crate::services::space_center::Contract, RpcError> {
            let request = crate::schema::Request::from(self.get_contract_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::Contract>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Waypoint {
        pub(crate) fn get_grounded_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Waypoint_get_Grounded",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_grounded_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_grounded_call()?)
        }
        pub fn get_grounded(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_grounded_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Waypoint {
        pub(crate) fn get_has_contract_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Waypoint_get_HasContract",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_has_contract_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_has_contract_call()?,
            )
        }
        pub fn get_has_contract(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_has_contract_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Waypoint {
        pub(crate) fn get_icon_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Waypoint_get_Icon",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_icon_stream(
            &self,
        ) -> Result<crate::stream::Stream<String>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_icon_call()?)
        }
        pub fn get_icon(&self) -> Result<String, RpcError> {
            let request = crate::schema::Request::from(self.get_icon_call()?);
            let response = self.client.call(request)?;
            <String>::from_response(response, self.client.clone())
        }
    }
    impl Waypoint {
        pub(crate) fn get_index_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Waypoint_get_Index",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_index_stream(&self) -> Result<crate::stream::Stream<i32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_index_call()?)
        }
        pub fn get_index(&self) -> Result<i32, RpcError> {
            let request = crate::schema::Request::from(self.get_index_call()?);
            let response = self.client.call(request)?;
            <i32>::from_response(response, self.client.clone())
        }
    }
    impl Waypoint {
        pub(crate) fn get_latitude_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Waypoint_get_Latitude",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_latitude_stream(
            &self,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_latitude_call()?)
        }
        pub fn get_latitude(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(self.get_latitude_call()?);
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Waypoint {
        pub(crate) fn get_longitude_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Waypoint_get_Longitude",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_longitude_stream(
            &self,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_longitude_call()?)
        }
        pub fn get_longitude(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(self.get_longitude_call()?);
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Waypoint {
        pub(crate) fn get_mean_altitude_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Waypoint_get_MeanAltitude",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_mean_altitude_stream(
            &self,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_mean_altitude_call()?,
            )
        }
        pub fn get_mean_altitude(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(self.get_mean_altitude_call()?);
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Waypoint {
        pub(crate) fn get_name_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Waypoint_get_Name",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_name_stream(
            &self,
        ) -> Result<crate::stream::Stream<String>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_name_call()?)
        }
        pub fn get_name(&self) -> Result<String, RpcError> {
            let request = crate::schema::Request::from(self.get_name_call()?);
            let response = self.client.call(request)?;
            <String>::from_response(response, self.client.clone())
        }
    }
    impl Waypoint {
        pub(crate) fn get_near_surface_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Waypoint_get_NearSurface",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_near_surface_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_near_surface_call()?,
            )
        }
        pub fn get_near_surface(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_near_surface_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Waypoint {
        pub(crate) fn get_surface_altitude_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Waypoint_get_SurfaceAltitude",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_surface_altitude_stream(
            &self,
        ) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_surface_altitude_call()?,
            )
        }
        pub fn get_surface_altitude(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(
                self.get_surface_altitude_call()?,
            );
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl Waypoint {
        pub(crate) fn set_bedrock_altitude_call(
            &self,
            value: f64,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Waypoint_set_BedrockAltitude",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_bedrock_altitude_stream(
            &self,
            value: f64,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_bedrock_altitude_call(value)?,
            )
        }
        pub fn set_bedrock_altitude(&self, value: f64) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_bedrock_altitude_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Waypoint {
        pub(crate) fn set_body_call(
            &self,
            value: &crate::services::space_center::CelestialBody,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Waypoint_set_Body",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_body_stream(
            &self,
            value: &crate::services::space_center::CelestialBody,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.set_body_call(value)?)
        }
        pub fn set_body(
            &self,
            value: &crate::services::space_center::CelestialBody,
        ) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_body_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Waypoint {
        pub(crate) fn set_color_call(
            &self,
            value: i32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Waypoint_set_Color",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_color_stream(
            &self,
            value: i32,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.set_color_call(value)?)
        }
        pub fn set_color(&self, value: i32) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_color_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Waypoint {
        pub(crate) fn set_icon_call(
            &self,
            value: String,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Waypoint_set_Icon",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_icon_stream(
            &self,
            value: String,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.set_icon_call(value)?)
        }
        pub fn set_icon(&self, value: String) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_icon_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Waypoint {
        pub(crate) fn set_latitude_call(
            &self,
            value: f64,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Waypoint_set_Latitude",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_latitude_stream(
            &self,
            value: f64,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_latitude_call(value)?,
            )
        }
        pub fn set_latitude(&self, value: f64) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_latitude_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Waypoint {
        pub(crate) fn set_longitude_call(
            &self,
            value: f64,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Waypoint_set_Longitude",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_longitude_stream(
            &self,
            value: f64,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_longitude_call(value)?,
            )
        }
        pub fn set_longitude(&self, value: f64) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_longitude_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Waypoint {
        pub(crate) fn set_mean_altitude_call(
            &self,
            value: f64,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Waypoint_set_MeanAltitude",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_mean_altitude_stream(
            &self,
            value: f64,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_mean_altitude_call(value)?,
            )
        }
        pub fn set_mean_altitude(&self, value: f64) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_mean_altitude_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Waypoint {
        pub(crate) fn set_name_call(
            &self,
            value: String,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Waypoint_set_Name",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_name_stream(
            &self,
            value: String,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.set_name_call(value)?)
        }
        pub fn set_name(&self, value: String) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_name_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Waypoint {
        pub(crate) fn set_surface_altitude_call(
            &self,
            value: f64,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Waypoint_set_SurfaceAltitude",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_surface_altitude_stream(
            &self,
            value: f64,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_surface_altitude_call(value)?,
            )
        }
        pub fn set_surface_altitude(&self, value: f64) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_surface_altitude_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Wheel {
        pub(crate) fn get_auto_friction_control_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Wheel_get_AutoFrictionControl",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_auto_friction_control_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_auto_friction_control_call()?,
            )
        }
        pub fn get_auto_friction_control(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(
                self.get_auto_friction_control_call()?,
            );
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Wheel {
        pub(crate) fn get_brakes_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Wheel_get_Brakes",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_brakes_stream(&self) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_brakes_call()?)
        }
        pub fn get_brakes(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_brakes_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Wheel {
        pub(crate) fn get_broken_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Wheel_get_Broken",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_broken_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_broken_call()?)
        }
        pub fn get_broken(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_broken_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Wheel {
        pub(crate) fn get_deflection_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Wheel_get_Deflection",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_deflection_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_deflection_call()?)
        }
        pub fn get_deflection(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_deflection_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Wheel {
        pub(crate) fn get_deployable_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Wheel_get_Deployable",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_deployable_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_deployable_call()?)
        }
        pub fn get_deployable(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_deployable_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Wheel {
        pub(crate) fn get_deployed_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Wheel_get_Deployed",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_deployed_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_deployed_call()?)
        }
        pub fn get_deployed(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_deployed_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Wheel {
        pub(crate) fn get_drive_limiter_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Wheel_get_DriveLimiter",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_drive_limiter_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_drive_limiter_call()?,
            )
        }
        pub fn get_drive_limiter(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_drive_limiter_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Wheel {
        pub(crate) fn get_grounded_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Wheel_get_Grounded",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_grounded_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_grounded_call()?)
        }
        pub fn get_grounded(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_grounded_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Wheel {
        pub(crate) fn get_has_brakes_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Wheel_get_HasBrakes",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_has_brakes_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_has_brakes_call()?)
        }
        pub fn get_has_brakes(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_has_brakes_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Wheel {
        pub(crate) fn get_has_suspension_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Wheel_get_HasSuspension",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_has_suspension_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_has_suspension_call()?,
            )
        }
        pub fn get_has_suspension(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_has_suspension_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Wheel {
        pub(crate) fn get_manual_friction_control_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Wheel_get_ManualFrictionControl",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_manual_friction_control_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_manual_friction_control_call()?,
            )
        }
        pub fn get_manual_friction_control(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(
                self.get_manual_friction_control_call()?,
            );
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Wheel {
        pub(crate) fn get_motor_enabled_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Wheel_get_MotorEnabled",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_motor_enabled_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_motor_enabled_call()?,
            )
        }
        pub fn get_motor_enabled(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_motor_enabled_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Wheel {
        pub(crate) fn get_motor_inverted_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Wheel_get_MotorInverted",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_motor_inverted_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_motor_inverted_call()?,
            )
        }
        pub fn get_motor_inverted(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_motor_inverted_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Wheel {
        pub(crate) fn get_motor_output_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Wheel_get_MotorOutput",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_motor_output_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_motor_output_call()?,
            )
        }
        pub fn get_motor_output(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_motor_output_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Wheel {
        pub(crate) fn get_motor_state_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Wheel_get_MotorState",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_motor_state_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::MotorState>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_motor_state_call()?)
        }
        pub fn get_motor_state(
            &self,
        ) -> Result<crate::services::space_center::MotorState, RpcError> {
            let request = crate::schema::Request::from(self.get_motor_state_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::MotorState>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Wheel {
        pub(crate) fn get_part_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Wheel_get_Part",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_part_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::Part>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_part_call()?)
        }
        pub fn get_part(&self) -> Result<crate::services::space_center::Part, RpcError> {
            let request = crate::schema::Request::from(self.get_part_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::Part>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Wheel {
        pub(crate) fn get_powered_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Wheel_get_Powered",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_powered_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_powered_call()?)
        }
        pub fn get_powered(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_powered_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Wheel {
        pub(crate) fn get_radius_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Wheel_get_Radius",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_radius_stream(&self) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_radius_call()?)
        }
        pub fn get_radius(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_radius_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Wheel {
        pub(crate) fn get_repairable_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Wheel_get_Repairable",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_repairable_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_repairable_call()?)
        }
        pub fn get_repairable(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_repairable_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Wheel {
        pub(crate) fn get_slip_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Wheel_get_Slip",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_slip_stream(&self) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_slip_call()?)
        }
        pub fn get_slip(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_slip_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Wheel {
        pub(crate) fn get_state_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Wheel_get_State",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_state_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::WheelState>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_state_call()?)
        }
        pub fn get_state(
            &self,
        ) -> Result<crate::services::space_center::WheelState, RpcError> {
            let request = crate::schema::Request::from(self.get_state_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::WheelState>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Wheel {
        pub(crate) fn get_steerable_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Wheel_get_Steerable",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_steerable_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_steerable_call()?)
        }
        pub fn get_steerable(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_steerable_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Wheel {
        pub(crate) fn get_steering_angle_limit_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Wheel_get_SteeringAngleLimit",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_steering_angle_limit_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_steering_angle_limit_call()?,
            )
        }
        pub fn get_steering_angle_limit(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(
                self.get_steering_angle_limit_call()?,
            );
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Wheel {
        pub(crate) fn get_steering_enabled_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Wheel_get_SteeringEnabled",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_steering_enabled_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_steering_enabled_call()?,
            )
        }
        pub fn get_steering_enabled(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(
                self.get_steering_enabled_call()?,
            );
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Wheel {
        pub(crate) fn get_steering_inverted_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Wheel_get_SteeringInverted",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_steering_inverted_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_steering_inverted_call()?,
            )
        }
        pub fn get_steering_inverted(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(
                self.get_steering_inverted_call()?,
            );
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Wheel {
        pub(crate) fn get_steering_response_time_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Wheel_get_SteeringResponseTime",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_steering_response_time_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_steering_response_time_call()?,
            )
        }
        pub fn get_steering_response_time(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(
                self.get_steering_response_time_call()?,
            );
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Wheel {
        pub(crate) fn get_stress_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Wheel_get_Stress",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_stress_stream(&self) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_stress_call()?)
        }
        pub fn get_stress(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_stress_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Wheel {
        pub(crate) fn get_stress_percentage_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Wheel_get_StressPercentage",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_stress_percentage_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_stress_percentage_call()?,
            )
        }
        pub fn get_stress_percentage(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(
                self.get_stress_percentage_call()?,
            );
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Wheel {
        pub(crate) fn get_stress_tolerance_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Wheel_get_StressTolerance",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_stress_tolerance_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_stress_tolerance_call()?,
            )
        }
        pub fn get_stress_tolerance(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(
                self.get_stress_tolerance_call()?,
            );
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Wheel {
        pub(crate) fn get_suspension_damper_strength_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Wheel_get_SuspensionDamperStrength",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_suspension_damper_strength_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_suspension_damper_strength_call()?,
            )
        }
        pub fn get_suspension_damper_strength(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(
                self.get_suspension_damper_strength_call()?,
            );
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Wheel {
        pub(crate) fn get_suspension_spring_strength_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Wheel_get_SuspensionSpringStrength",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_suspension_spring_strength_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_suspension_spring_strength_call()?,
            )
        }
        pub fn get_suspension_spring_strength(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(
                self.get_suspension_spring_strength_call()?,
            );
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Wheel {
        pub(crate) fn get_traction_control_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Wheel_get_TractionControl",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_traction_control_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_traction_control_call()?,
            )
        }
        pub fn get_traction_control(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(
                self.get_traction_control_call()?,
            );
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Wheel {
        pub(crate) fn get_traction_control_enabled_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Wheel_get_TractionControlEnabled",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_traction_control_enabled_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_traction_control_enabled_call()?,
            )
        }
        pub fn get_traction_control_enabled(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(
                self.get_traction_control_enabled_call()?,
            );
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Wheel {
        pub(crate) fn set_auto_friction_control_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Wheel_set_AutoFrictionControl",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_auto_friction_control_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_auto_friction_control_call(value)?,
            )
        }
        pub fn set_auto_friction_control(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_auto_friction_control_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Wheel {
        pub(crate) fn set_brakes_call(
            &self,
            value: f32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Wheel_set_Brakes",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_brakes_stream(
            &self,
            value: f32,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.set_brakes_call(value)?)
        }
        pub fn set_brakes(&self, value: f32) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_brakes_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Wheel {
        pub(crate) fn set_deployed_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Wheel_set_Deployed",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_deployed_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_deployed_call(value)?,
            )
        }
        pub fn set_deployed(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_deployed_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Wheel {
        pub(crate) fn set_drive_limiter_call(
            &self,
            value: f32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Wheel_set_DriveLimiter",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_drive_limiter_stream(
            &self,
            value: f32,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_drive_limiter_call(value)?,
            )
        }
        pub fn set_drive_limiter(&self, value: f32) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_drive_limiter_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Wheel {
        pub(crate) fn set_manual_friction_control_call(
            &self,
            value: f32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Wheel_set_ManualFrictionControl",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_manual_friction_control_stream(
            &self,
            value: f32,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_manual_friction_control_call(value)?,
            )
        }
        pub fn set_manual_friction_control(&self, value: f32) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_manual_friction_control_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Wheel {
        pub(crate) fn set_motor_enabled_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Wheel_set_MotorEnabled",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_motor_enabled_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_motor_enabled_call(value)?,
            )
        }
        pub fn set_motor_enabled(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_motor_enabled_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Wheel {
        pub(crate) fn set_motor_inverted_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Wheel_set_MotorInverted",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_motor_inverted_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_motor_inverted_call(value)?,
            )
        }
        pub fn set_motor_inverted(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_motor_inverted_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Wheel {
        pub(crate) fn set_steering_angle_limit_call(
            &self,
            value: f32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Wheel_set_SteeringAngleLimit",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_steering_angle_limit_stream(
            &self,
            value: f32,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_steering_angle_limit_call(value)?,
            )
        }
        pub fn set_steering_angle_limit(&self, value: f32) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_steering_angle_limit_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Wheel {
        pub(crate) fn set_steering_enabled_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Wheel_set_SteeringEnabled",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_steering_enabled_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_steering_enabled_call(value)?,
            )
        }
        pub fn set_steering_enabled(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_steering_enabled_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Wheel {
        pub(crate) fn set_steering_inverted_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Wheel_set_SteeringInverted",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_steering_inverted_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_steering_inverted_call(value)?,
            )
        }
        pub fn set_steering_inverted(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_steering_inverted_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Wheel {
        pub(crate) fn set_steering_response_time_call(
            &self,
            value: f32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Wheel_set_SteeringResponseTime",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_steering_response_time_stream(
            &self,
            value: f32,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_steering_response_time_call(value)?,
            )
        }
        pub fn set_steering_response_time(&self, value: f32) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_steering_response_time_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Wheel {
        pub(crate) fn set_traction_control_call(
            &self,
            value: f32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Wheel_set_TractionControl",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_traction_control_stream(
            &self,
            value: f32,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_traction_control_call(value)?,
            )
        }
        pub fn set_traction_control(&self, value: f32) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_traction_control_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Wheel {
        pub(crate) fn set_traction_control_enabled_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "Wheel_set_TractionControlEnabled",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_traction_control_enabled_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_traction_control_enabled_call(value)?,
            )
        }
        pub fn set_traction_control_enabled(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_traction_control_enabled_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl SpaceCenter {
        pub(crate) fn get_active_vessel_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "get_ActiveVessel",
                    vec![],
                ),
            )
        }
        pub fn get_active_vessel_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::Vessel>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_active_vessel_call()?,
            )
        }
        pub fn get_active_vessel(
            &self,
        ) -> Result<crate::services::space_center::Vessel, RpcError> {
            let request = crate::schema::Request::from(self.get_active_vessel_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::Vessel>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl SpaceCenter {
        pub(crate) fn get_alarm_manager_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "get_AlarmManager",
                    vec![],
                ),
            )
        }
        pub fn get_alarm_manager_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::AlarmManager>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_alarm_manager_call()?,
            )
        }
        pub fn get_alarm_manager(
            &self,
        ) -> Result<crate::services::space_center::AlarmManager, RpcError> {
            let request = crate::schema::Request::from(self.get_alarm_manager_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::AlarmManager>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl SpaceCenter {
        pub(crate) fn get_bodies_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(crate::client::Client::proc_call("SpaceCenter", "get_Bodies", vec![]))
        }
        pub fn get_bodies_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<
                std::collections::HashMap<
                    String,
                    crate::services::space_center::CelestialBody,
                >,
            >,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_bodies_call()?)
        }
        pub fn get_bodies(
            &self,
        ) -> Result<
            std::collections::HashMap<
                String,
                crate::services::space_center::CelestialBody,
            >,
            RpcError,
        > {
            let request = crate::schema::Request::from(self.get_bodies_call()?);
            let response = self.client.call(request)?;
            <std::collections::HashMap<
                String,
                crate::services::space_center::CelestialBody,
            >>::from_response(response, self.client.clone())
        }
    }
    impl SpaceCenter {
        pub(crate) fn get_camera_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(crate::client::Client::proc_call("SpaceCenter", "get_Camera", vec![]))
        }
        pub fn get_camera_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::Camera>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_camera_call()?)
        }
        pub fn get_camera(
            &self,
        ) -> Result<crate::services::space_center::Camera, RpcError> {
            let request = crate::schema::Request::from(self.get_camera_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::Camera>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl SpaceCenter {
        pub(crate) fn get_contract_manager_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "get_ContractManager",
                    vec![],
                ),
            )
        }
        pub fn get_contract_manager_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::ContractManager>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_contract_manager_call()?,
            )
        }
        pub fn get_contract_manager(
            &self,
        ) -> Result<crate::services::space_center::ContractManager, RpcError> {
            let request = crate::schema::Request::from(
                self.get_contract_manager_call()?,
            );
            let response = self.client.call(request)?;
            <crate::services::space_center::ContractManager>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl SpaceCenter {
        pub(crate) fn get_far_available_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "get_FARAvailable",
                    vec![],
                ),
            )
        }
        pub fn get_far_available_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_far_available_call()?,
            )
        }
        pub fn get_far_available(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_far_available_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl SpaceCenter {
        pub(crate) fn get_funds_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(crate::client::Client::proc_call("SpaceCenter", "get_Funds", vec![]))
        }
        pub fn get_funds_stream(&self) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_funds_call()?)
        }
        pub fn get_funds(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(self.get_funds_call()?);
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl SpaceCenter {
        pub(crate) fn get_g_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(crate::client::Client::proc_call("SpaceCenter", "get_G", vec![]))
        }
        pub fn get_g_stream(&self) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_g_call()?)
        }
        pub fn get_g(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(self.get_g_call()?);
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl SpaceCenter {
        pub(crate) fn get_game_mode_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(crate::client::Client::proc_call("SpaceCenter", "get_GameMode", vec![]))
        }
        pub fn get_game_mode_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::GameMode>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_game_mode_call()?)
        }
        pub fn get_game_mode(
            &self,
        ) -> Result<crate::services::space_center::GameMode, RpcError> {
            let request = crate::schema::Request::from(self.get_game_mode_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::GameMode>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl SpaceCenter {
        pub(crate) fn get_launch_sites_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "get_LaunchSites",
                    vec![],
                ),
            )
        }
        pub fn get_launch_sites_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Vec<crate::services::space_center::LaunchSite>>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_launch_sites_call()?,
            )
        }
        pub fn get_launch_sites(
            &self,
        ) -> Result<Vec<crate::services::space_center::LaunchSite>, RpcError> {
            let request = crate::schema::Request::from(self.get_launch_sites_call()?);
            let response = self.client.call(request)?;
            <Vec<
                crate::services::space_center::LaunchSite,
            >>::from_response(response, self.client.clone())
        }
    }
    impl SpaceCenter {
        pub(crate) fn get_map_filter_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(crate::client::Client::proc_call("SpaceCenter", "get_MapFilter", vec![]))
        }
        pub fn get_map_filter_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::MapFilterType>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_map_filter_call()?)
        }
        pub fn get_map_filter(
            &self,
        ) -> Result<crate::services::space_center::MapFilterType, RpcError> {
            let request = crate::schema::Request::from(self.get_map_filter_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::MapFilterType>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl SpaceCenter {
        pub(crate) fn get_maximum_rails_warp_factor_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "get_MaximumRailsWarpFactor",
                    vec![],
                ),
            )
        }
        pub fn get_maximum_rails_warp_factor_stream(
            &self,
        ) -> Result<crate::stream::Stream<i32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_maximum_rails_warp_factor_call()?,
            )
        }
        pub fn get_maximum_rails_warp_factor(&self) -> Result<i32, RpcError> {
            let request = crate::schema::Request::from(
                self.get_maximum_rails_warp_factor_call()?,
            );
            let response = self.client.call(request)?;
            <i32>::from_response(response, self.client.clone())
        }
    }
    impl SpaceCenter {
        pub(crate) fn get_navball_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(crate::client::Client::proc_call("SpaceCenter", "get_Navball", vec![]))
        }
        pub fn get_navball_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_navball_call()?)
        }
        pub fn get_navball(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_navball_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl SpaceCenter {
        pub(crate) fn get_physics_warp_factor_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "get_PhysicsWarpFactor",
                    vec![],
                ),
            )
        }
        pub fn get_physics_warp_factor_stream(
            &self,
        ) -> Result<crate::stream::Stream<i32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_physics_warp_factor_call()?,
            )
        }
        pub fn get_physics_warp_factor(&self) -> Result<i32, RpcError> {
            let request = crate::schema::Request::from(
                self.get_physics_warp_factor_call()?,
            );
            let response = self.client.call(request)?;
            <i32>::from_response(response, self.client.clone())
        }
    }
    impl SpaceCenter {
        pub(crate) fn get_rails_warp_factor_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "get_RailsWarpFactor",
                    vec![],
                ),
            )
        }
        pub fn get_rails_warp_factor_stream(
            &self,
        ) -> Result<crate::stream::Stream<i32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_rails_warp_factor_call()?,
            )
        }
        pub fn get_rails_warp_factor(&self) -> Result<i32, RpcError> {
            let request = crate::schema::Request::from(
                self.get_rails_warp_factor_call()?,
            );
            let response = self.client.call(request)?;
            <i32>::from_response(response, self.client.clone())
        }
    }
    impl SpaceCenter {
        pub(crate) fn get_reputation_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(crate::client::Client::proc_call("SpaceCenter", "get_Reputation", vec![]))
        }
        pub fn get_reputation_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_reputation_call()?)
        }
        pub fn get_reputation(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_reputation_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl SpaceCenter {
        pub(crate) fn get_science_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(crate::client::Client::proc_call("SpaceCenter", "get_Science", vec![]))
        }
        pub fn get_science_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_science_call()?)
        }
        pub fn get_science(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_science_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl SpaceCenter {
        pub(crate) fn get_target_body_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(crate::client::Client::proc_call("SpaceCenter", "get_TargetBody", vec![]))
        }
        pub fn get_target_body_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Option<crate::services::space_center::CelestialBody>>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_target_body_call()?)
        }
        pub fn get_target_body(
            &self,
        ) -> Result<Option<crate::services::space_center::CelestialBody>, RpcError> {
            let request = crate::schema::Request::from(self.get_target_body_call()?);
            let response = self.client.call(request)?;
            <Option<
                crate::services::space_center::CelestialBody,
            >>::from_response(response, self.client.clone())
        }
    }
    impl SpaceCenter {
        pub(crate) fn get_target_docking_port_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "get_TargetDockingPort",
                    vec![],
                ),
            )
        }
        pub fn get_target_docking_port_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Option<crate::services::space_center::DockingPort>>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_target_docking_port_call()?,
            )
        }
        pub fn get_target_docking_port(
            &self,
        ) -> Result<Option<crate::services::space_center::DockingPort>, RpcError> {
            let request = crate::schema::Request::from(
                self.get_target_docking_port_call()?,
            );
            let response = self.client.call(request)?;
            <Option<
                crate::services::space_center::DockingPort,
            >>::from_response(response, self.client.clone())
        }
    }
    impl SpaceCenter {
        pub(crate) fn get_target_vessel_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "get_TargetVessel",
                    vec![],
                ),
            )
        }
        pub fn get_target_vessel_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Option<crate::services::space_center::Vessel>>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_target_vessel_call()?,
            )
        }
        pub fn get_target_vessel(
            &self,
        ) -> Result<Option<crate::services::space_center::Vessel>, RpcError> {
            let request = crate::schema::Request::from(self.get_target_vessel_call()?);
            let response = self.client.call(request)?;
            <Option<
                crate::services::space_center::Vessel,
            >>::from_response(response, self.client.clone())
        }
    }
    impl SpaceCenter {
        pub(crate) fn get_ui_visible_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(crate::client::Client::proc_call("SpaceCenter", "get_UIVisible", vec![]))
        }
        pub fn get_ui_visible_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_ui_visible_call()?)
        }
        pub fn get_ui_visible(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_ui_visible_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl SpaceCenter {
        pub(crate) fn get_ut_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(crate::client::Client::proc_call("SpaceCenter", "get_UT", vec![]))
        }
        pub fn get_ut_stream(&self) -> Result<crate::stream::Stream<f64>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_ut_call()?)
        }
        pub fn get_ut(&self) -> Result<f64, RpcError> {
            let request = crate::schema::Request::from(self.get_ut_call()?);
            let response = self.client.call(request)?;
            <f64>::from_response(response, self.client.clone())
        }
    }
    impl SpaceCenter {
        pub(crate) fn get_vessels_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(crate::client::Client::proc_call("SpaceCenter", "get_Vessels", vec![]))
        }
        pub fn get_vessels_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<Vec<crate::services::space_center::Vessel>>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_vessels_call()?)
        }
        pub fn get_vessels(
            &self,
        ) -> Result<Vec<crate::services::space_center::Vessel>, RpcError> {
            let request = crate::schema::Request::from(self.get_vessels_call()?);
            let response = self.client.call(request)?;
            <Vec<
                crate::services::space_center::Vessel,
            >>::from_response(response, self.client.clone())
        }
    }
    impl SpaceCenter {
        pub(crate) fn get_warp_factor_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(crate::client::Client::proc_call("SpaceCenter", "get_WarpFactor", vec![]))
        }
        pub fn get_warp_factor_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_warp_factor_call()?)
        }
        pub fn get_warp_factor(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_warp_factor_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl SpaceCenter {
        pub(crate) fn get_warp_mode_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(crate::client::Client::proc_call("SpaceCenter", "get_WarpMode", vec![]))
        }
        pub fn get_warp_mode_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::WarpMode>,
            RpcError,
        > {
            crate::stream::Stream::new(self.client.clone(), self.get_warp_mode_call()?)
        }
        pub fn get_warp_mode(
            &self,
        ) -> Result<crate::services::space_center::WarpMode, RpcError> {
            let request = crate::schema::Request::from(self.get_warp_mode_call()?);
            let response = self.client.call(request)?;
            <crate::services::space_center::WarpMode>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl SpaceCenter {
        pub(crate) fn get_warp_rate_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(crate::client::Client::proc_call("SpaceCenter", "get_WarpRate", vec![]))
        }
        pub fn get_warp_rate_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_warp_rate_call()?)
        }
        pub fn get_warp_rate(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_warp_rate_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl SpaceCenter {
        pub(crate) fn get_waypoint_manager_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "get_WaypointManager",
                    vec![],
                ),
            )
        }
        pub fn get_waypoint_manager_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::space_center::WaypointManager>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_waypoint_manager_call()?,
            )
        }
        pub fn get_waypoint_manager(
            &self,
        ) -> Result<crate::services::space_center::WaypointManager, RpcError> {
            let request = crate::schema::Request::from(
                self.get_waypoint_manager_call()?,
            );
            let response = self.client.call(request)?;
            <crate::services::space_center::WaypointManager>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl SpaceCenter {
        pub(crate) fn set_active_vessel_call(
            &self,
            value: &crate::services::space_center::Vessel,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "set_ActiveVessel",
                    vec![value.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn set_active_vessel_stream(
            &self,
            value: &crate::services::space_center::Vessel,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_active_vessel_call(value)?,
            )
        }
        pub fn set_active_vessel(
            &self,
            value: &crate::services::space_center::Vessel,
        ) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_active_vessel_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl SpaceCenter {
        pub(crate) fn set_map_filter_call(
            &self,
            value: crate::services::space_center::MapFilterType,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "set_MapFilter",
                    vec![value.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn set_map_filter_stream(
            &self,
            value: crate::services::space_center::MapFilterType,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_map_filter_call(value)?,
            )
        }
        pub fn set_map_filter(
            &self,
            value: crate::services::space_center::MapFilterType,
        ) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_map_filter_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl SpaceCenter {
        pub(crate) fn set_navball_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "set_Navball",
                    vec![value.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn set_navball_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_navball_call(value)?,
            )
        }
        pub fn set_navball(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_navball_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl SpaceCenter {
        pub(crate) fn set_physics_warp_factor_call(
            &self,
            value: i32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "set_PhysicsWarpFactor",
                    vec![value.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn set_physics_warp_factor_stream(
            &self,
            value: i32,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_physics_warp_factor_call(value)?,
            )
        }
        pub fn set_physics_warp_factor(&self, value: i32) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_physics_warp_factor_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl SpaceCenter {
        pub(crate) fn set_rails_warp_factor_call(
            &self,
            value: i32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "set_RailsWarpFactor",
                    vec![value.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn set_rails_warp_factor_stream(
            &self,
            value: i32,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_rails_warp_factor_call(value)?,
            )
        }
        pub fn set_rails_warp_factor(&self, value: i32) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_rails_warp_factor_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl SpaceCenter {
        pub(crate) fn set_target_body_call(
            &self,
            value: &crate::services::space_center::CelestialBody,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "set_TargetBody",
                    vec![value.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn set_target_body_stream(
            &self,
            value: &crate::services::space_center::CelestialBody,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_target_body_call(value)?,
            )
        }
        pub fn set_target_body(
            &self,
            value: &crate::services::space_center::CelestialBody,
        ) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_target_body_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl SpaceCenter {
        pub(crate) fn set_target_docking_port_call(
            &self,
            value: &crate::services::space_center::DockingPort,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "set_TargetDockingPort",
                    vec![value.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn set_target_docking_port_stream(
            &self,
            value: &crate::services::space_center::DockingPort,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_target_docking_port_call(value)?,
            )
        }
        pub fn set_target_docking_port(
            &self,
            value: &crate::services::space_center::DockingPort,
        ) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_target_docking_port_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl SpaceCenter {
        pub(crate) fn set_target_vessel_call(
            &self,
            value: &crate::services::space_center::Vessel,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "set_TargetVessel",
                    vec![value.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn set_target_vessel_stream(
            &self,
            value: &crate::services::space_center::Vessel,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_target_vessel_call(value)?,
            )
        }
        pub fn set_target_vessel(
            &self,
            value: &crate::services::space_center::Vessel,
        ) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_target_vessel_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl SpaceCenter {
        pub(crate) fn set_ui_visible_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "SpaceCenter",
                    "set_UIVisible",
                    vec![value.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn set_ui_visible_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_ui_visible_call(value)?,
            )
        }
        pub fn set_ui_visible(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_ui_visible_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
}
#[allow(clippy::type_complexity)]
pub mod ui {
    use crate::{
        schema::{ToArgument, FromResponse},
        error::RpcError,
    };
    pub struct UI {
        pub client: ::std::sync::Arc<crate::Client>,
    }
    impl UI {
        pub fn new(client: ::std::sync::Arc<crate::Client>) -> Self {
            Self { client }
        }
    }
    crate::schema::rpc_object!(Button);
    crate::schema::rpc_object!(Canvas);
    crate::schema::rpc_object!(InputField);
    crate::schema::rpc_object!(Panel);
    crate::schema::rpc_object!(RectTransform);
    crate::schema::rpc_object!(Text);
    crate::schema::rpc_enum!(FontStyle, [Normal, Bold, Italic, BoldAndItalic,]);
    crate::schema::rpc_enum!(
        MessagePosition, [BottomCenter, TopCenter, TopLeft, TopRight,]
    );
    crate::schema::rpc_enum!(TextAlignment, [Left, Right, Center,]);
    crate::schema::rpc_enum!(
        TextAnchor, [LowerCenter, LowerLeft, LowerRight, MiddleCenter, MiddleLeft,
        MiddleRight, UpperCenter, UpperLeft, UpperRight,]
    );
    impl UI {
        pub(crate) fn add_canvas_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(crate::client::Client::proc_call("UI", "AddCanvas", vec![]))
        }
        pub fn add_canvas_stream(
            &self,
        ) -> Result<crate::stream::Stream<crate::services::ui::Canvas>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.add_canvas_call()?)
        }
        pub fn add_canvas(&self) -> Result<crate::services::ui::Canvas, RpcError> {
            let request = crate::schema::Request::from(self.add_canvas_call()?);
            let response = self.client.call(request)?;
            <crate::services::ui::Canvas>::from_response(response, self.client.clone())
        }
    }
    impl Button {
        pub(crate) fn remove_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "UI",
                    "Button_Remove",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn remove_stream(&self) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.remove_call()?)
        }
        pub fn remove(&self) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.remove_call()?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Button {
        pub(crate) fn get_clicked_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "UI",
                    "Button_get_Clicked",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_clicked_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_clicked_call()?)
        }
        pub fn get_clicked(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_clicked_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Button {
        pub(crate) fn get_rect_transform_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "UI",
                    "Button_get_RectTransform",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_rect_transform_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::ui::RectTransform>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_rect_transform_call()?,
            )
        }
        pub fn get_rect_transform(
            &self,
        ) -> Result<crate::services::ui::RectTransform, RpcError> {
            let request = crate::schema::Request::from(self.get_rect_transform_call()?);
            let response = self.client.call(request)?;
            <crate::services::ui::RectTransform>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Button {
        pub(crate) fn get_text_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "UI",
                    "Button_get_Text",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_text_stream(
            &self,
        ) -> Result<crate::stream::Stream<crate::services::ui::Text>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_text_call()?)
        }
        pub fn get_text(&self) -> Result<crate::services::ui::Text, RpcError> {
            let request = crate::schema::Request::from(self.get_text_call()?);
            let response = self.client.call(request)?;
            <crate::services::ui::Text>::from_response(response, self.client.clone())
        }
    }
    impl Button {
        pub(crate) fn get_visible_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "UI",
                    "Button_get_Visible",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_visible_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_visible_call()?)
        }
        pub fn get_visible(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_visible_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Button {
        pub(crate) fn set_clicked_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "UI",
                    "Button_set_Clicked",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_clicked_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_clicked_call(value)?,
            )
        }
        pub fn set_clicked(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_clicked_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Button {
        pub(crate) fn set_visible_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "UI",
                    "Button_set_Visible",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_visible_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_visible_call(value)?,
            )
        }
        pub fn set_visible(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_visible_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Canvas {
        pub(crate) fn add_button_call(
            &self,
            content: String,
            visible: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "UI",
                    "Canvas_AddButton",
                    vec![
                        self.to_argument(0usize as u32) ?, content.to_argument(1usize as
                        u32) ?, visible.to_argument(2usize as u32) ?
                    ],
                ),
            )
        }
        pub fn add_button_stream(
            &self,
            content: String,
            visible: bool,
        ) -> Result<crate::stream::Stream<crate::services::ui::Button>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.add_button_call(content, visible)?,
            )
        }
        pub fn add_button(
            &self,
            content: String,
            visible: bool,
        ) -> Result<crate::services::ui::Button, RpcError> {
            let request = crate::schema::Request::from(
                self.add_button_call(content, visible)?,
            );
            let response = self.client.call(request)?;
            <crate::services::ui::Button>::from_response(response, self.client.clone())
        }
    }
    impl Canvas {
        pub(crate) fn add_input_field_call(
            &self,
            visible: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "UI",
                    "Canvas_AddInputField",
                    vec![
                        self.to_argument(0usize as u32) ?, visible.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn add_input_field_stream(
            &self,
            visible: bool,
        ) -> Result<crate::stream::Stream<crate::services::ui::InputField>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.add_input_field_call(visible)?,
            )
        }
        pub fn add_input_field(
            &self,
            visible: bool,
        ) -> Result<crate::services::ui::InputField, RpcError> {
            let request = crate::schema::Request::from(
                self.add_input_field_call(visible)?,
            );
            let response = self.client.call(request)?;
            <crate::services::ui::InputField>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Canvas {
        pub(crate) fn add_panel_call(
            &self,
            visible: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "UI",
                    "Canvas_AddPanel",
                    vec![
                        self.to_argument(0usize as u32) ?, visible.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn add_panel_stream(
            &self,
            visible: bool,
        ) -> Result<crate::stream::Stream<crate::services::ui::Panel>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.add_panel_call(visible)?,
            )
        }
        pub fn add_panel(
            &self,
            visible: bool,
        ) -> Result<crate::services::ui::Panel, RpcError> {
            let request = crate::schema::Request::from(self.add_panel_call(visible)?);
            let response = self.client.call(request)?;
            <crate::services::ui::Panel>::from_response(response, self.client.clone())
        }
    }
    impl Canvas {
        pub(crate) fn add_text_call(
            &self,
            content: String,
            visible: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "UI",
                    "Canvas_AddText",
                    vec![
                        self.to_argument(0usize as u32) ?, content.to_argument(1usize as
                        u32) ?, visible.to_argument(2usize as u32) ?
                    ],
                ),
            )
        }
        pub fn add_text_stream(
            &self,
            content: String,
            visible: bool,
        ) -> Result<crate::stream::Stream<crate::services::ui::Text>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.add_text_call(content, visible)?,
            )
        }
        pub fn add_text(
            &self,
            content: String,
            visible: bool,
        ) -> Result<crate::services::ui::Text, RpcError> {
            let request = crate::schema::Request::from(
                self.add_text_call(content, visible)?,
            );
            let response = self.client.call(request)?;
            <crate::services::ui::Text>::from_response(response, self.client.clone())
        }
    }
    impl Canvas {
        pub(crate) fn remove_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "UI",
                    "Canvas_Remove",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn remove_stream(&self) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.remove_call()?)
        }
        pub fn remove(&self) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.remove_call()?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Canvas {
        pub(crate) fn get_rect_transform_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "UI",
                    "Canvas_get_RectTransform",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_rect_transform_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::ui::RectTransform>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_rect_transform_call()?,
            )
        }
        pub fn get_rect_transform(
            &self,
        ) -> Result<crate::services::ui::RectTransform, RpcError> {
            let request = crate::schema::Request::from(self.get_rect_transform_call()?);
            let response = self.client.call(request)?;
            <crate::services::ui::RectTransform>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Canvas {
        pub(crate) fn get_visible_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "UI",
                    "Canvas_get_Visible",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_visible_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_visible_call()?)
        }
        pub fn get_visible(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_visible_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Canvas {
        pub(crate) fn set_visible_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "UI",
                    "Canvas_set_Visible",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_visible_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_visible_call(value)?,
            )
        }
        pub fn set_visible(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_visible_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl UI {
        pub(crate) fn clear_call(
            &self,
            client_only: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "UI",
                    "Clear",
                    vec![client_only.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn clear_stream(
            &self,
            client_only: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.clear_call(client_only)?,
            )
        }
        pub fn clear(&self, client_only: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.clear_call(client_only)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl InputField {
        pub(crate) fn remove_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "UI",
                    "InputField_Remove",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn remove_stream(&self) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.remove_call()?)
        }
        pub fn remove(&self) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.remove_call()?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl InputField {
        pub(crate) fn get_changed_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "UI",
                    "InputField_get_Changed",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_changed_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_changed_call()?)
        }
        pub fn get_changed(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_changed_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl InputField {
        pub(crate) fn get_rect_transform_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "UI",
                    "InputField_get_RectTransform",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_rect_transform_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::ui::RectTransform>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_rect_transform_call()?,
            )
        }
        pub fn get_rect_transform(
            &self,
        ) -> Result<crate::services::ui::RectTransform, RpcError> {
            let request = crate::schema::Request::from(self.get_rect_transform_call()?);
            let response = self.client.call(request)?;
            <crate::services::ui::RectTransform>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl InputField {
        pub(crate) fn get_text_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "UI",
                    "InputField_get_Text",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_text_stream(
            &self,
        ) -> Result<crate::stream::Stream<crate::services::ui::Text>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_text_call()?)
        }
        pub fn get_text(&self) -> Result<crate::services::ui::Text, RpcError> {
            let request = crate::schema::Request::from(self.get_text_call()?);
            let response = self.client.call(request)?;
            <crate::services::ui::Text>::from_response(response, self.client.clone())
        }
    }
    impl InputField {
        pub(crate) fn get_value_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "UI",
                    "InputField_get_Value",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_value_stream(
            &self,
        ) -> Result<crate::stream::Stream<String>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_value_call()?)
        }
        pub fn get_value(&self) -> Result<String, RpcError> {
            let request = crate::schema::Request::from(self.get_value_call()?);
            let response = self.client.call(request)?;
            <String>::from_response(response, self.client.clone())
        }
    }
    impl InputField {
        pub(crate) fn get_visible_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "UI",
                    "InputField_get_Visible",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_visible_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_visible_call()?)
        }
        pub fn get_visible(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_visible_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl InputField {
        pub(crate) fn set_changed_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "UI",
                    "InputField_set_Changed",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_changed_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_changed_call(value)?,
            )
        }
        pub fn set_changed(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_changed_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl InputField {
        pub(crate) fn set_value_call(
            &self,
            value: String,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "UI",
                    "InputField_set_Value",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_value_stream(
            &self,
            value: String,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.set_value_call(value)?)
        }
        pub fn set_value(&self, value: String) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_value_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl InputField {
        pub(crate) fn set_visible_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "UI",
                    "InputField_set_Visible",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_visible_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_visible_call(value)?,
            )
        }
        pub fn set_visible(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_visible_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl UI {
        pub(crate) fn message_call(
            &self,
            content: String,
            duration: f32,
            position: crate::services::ui::MessagePosition,
            color: (f64, f64, f64),
            size: f32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "UI",
                    "Message",
                    vec![
                        content.to_argument(0usize as u32) ?, duration.to_argument(1usize
                        as u32) ?, position.to_argument(2usize as u32) ?, color
                        .to_argument(3usize as u32) ?, size.to_argument(4usize as u32) ?
                    ],
                ),
            )
        }
        pub fn message_stream(
            &self,
            content: String,
            duration: f32,
            position: crate::services::ui::MessagePosition,
            color: (f64, f64, f64),
            size: f32,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.message_call(content, duration, position, color, size)?,
            )
        }
        pub fn message(
            &self,
            content: String,
            duration: f32,
            position: crate::services::ui::MessagePosition,
            color: (f64, f64, f64),
            size: f32,
        ) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.message_call(content, duration, position, color, size)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Panel {
        pub(crate) fn add_button_call(
            &self,
            content: String,
            visible: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "UI",
                    "Panel_AddButton",
                    vec![
                        self.to_argument(0usize as u32) ?, content.to_argument(1usize as
                        u32) ?, visible.to_argument(2usize as u32) ?
                    ],
                ),
            )
        }
        pub fn add_button_stream(
            &self,
            content: String,
            visible: bool,
        ) -> Result<crate::stream::Stream<crate::services::ui::Button>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.add_button_call(content, visible)?,
            )
        }
        pub fn add_button(
            &self,
            content: String,
            visible: bool,
        ) -> Result<crate::services::ui::Button, RpcError> {
            let request = crate::schema::Request::from(
                self.add_button_call(content, visible)?,
            );
            let response = self.client.call(request)?;
            <crate::services::ui::Button>::from_response(response, self.client.clone())
        }
    }
    impl Panel {
        pub(crate) fn add_input_field_call(
            &self,
            visible: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "UI",
                    "Panel_AddInputField",
                    vec![
                        self.to_argument(0usize as u32) ?, visible.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn add_input_field_stream(
            &self,
            visible: bool,
        ) -> Result<crate::stream::Stream<crate::services::ui::InputField>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.add_input_field_call(visible)?,
            )
        }
        pub fn add_input_field(
            &self,
            visible: bool,
        ) -> Result<crate::services::ui::InputField, RpcError> {
            let request = crate::schema::Request::from(
                self.add_input_field_call(visible)?,
            );
            let response = self.client.call(request)?;
            <crate::services::ui::InputField>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Panel {
        pub(crate) fn add_panel_call(
            &self,
            visible: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "UI",
                    "Panel_AddPanel",
                    vec![
                        self.to_argument(0usize as u32) ?, visible.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn add_panel_stream(
            &self,
            visible: bool,
        ) -> Result<crate::stream::Stream<crate::services::ui::Panel>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.add_panel_call(visible)?,
            )
        }
        pub fn add_panel(
            &self,
            visible: bool,
        ) -> Result<crate::services::ui::Panel, RpcError> {
            let request = crate::schema::Request::from(self.add_panel_call(visible)?);
            let response = self.client.call(request)?;
            <crate::services::ui::Panel>::from_response(response, self.client.clone())
        }
    }
    impl Panel {
        pub(crate) fn add_text_call(
            &self,
            content: String,
            visible: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "UI",
                    "Panel_AddText",
                    vec![
                        self.to_argument(0usize as u32) ?, content.to_argument(1usize as
                        u32) ?, visible.to_argument(2usize as u32) ?
                    ],
                ),
            )
        }
        pub fn add_text_stream(
            &self,
            content: String,
            visible: bool,
        ) -> Result<crate::stream::Stream<crate::services::ui::Text>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.add_text_call(content, visible)?,
            )
        }
        pub fn add_text(
            &self,
            content: String,
            visible: bool,
        ) -> Result<crate::services::ui::Text, RpcError> {
            let request = crate::schema::Request::from(
                self.add_text_call(content, visible)?,
            );
            let response = self.client.call(request)?;
            <crate::services::ui::Text>::from_response(response, self.client.clone())
        }
    }
    impl Panel {
        pub(crate) fn remove_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "UI",
                    "Panel_Remove",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn remove_stream(&self) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.remove_call()?)
        }
        pub fn remove(&self) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.remove_call()?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Panel {
        pub(crate) fn get_rect_transform_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "UI",
                    "Panel_get_RectTransform",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_rect_transform_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::ui::RectTransform>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_rect_transform_call()?,
            )
        }
        pub fn get_rect_transform(
            &self,
        ) -> Result<crate::services::ui::RectTransform, RpcError> {
            let request = crate::schema::Request::from(self.get_rect_transform_call()?);
            let response = self.client.call(request)?;
            <crate::services::ui::RectTransform>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Panel {
        pub(crate) fn get_visible_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "UI",
                    "Panel_get_Visible",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_visible_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_visible_call()?)
        }
        pub fn get_visible(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_visible_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Panel {
        pub(crate) fn set_visible_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "UI",
                    "Panel_set_Visible",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_visible_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_visible_call(value)?,
            )
        }
        pub fn set_visible(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_visible_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl RectTransform {
        pub(crate) fn get_anchor_max_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "UI",
                    "RectTransform_get_AnchorMax",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_anchor_max_stream(
            &self,
        ) -> Result<crate::stream::Stream<(f64, f64)>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_anchor_max_call()?)
        }
        pub fn get_anchor_max(&self) -> Result<(f64, f64), RpcError> {
            let request = crate::schema::Request::from(self.get_anchor_max_call()?);
            let response = self.client.call(request)?;
            <(f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl RectTransform {
        pub(crate) fn get_anchor_min_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "UI",
                    "RectTransform_get_AnchorMin",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_anchor_min_stream(
            &self,
        ) -> Result<crate::stream::Stream<(f64, f64)>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_anchor_min_call()?)
        }
        pub fn get_anchor_min(&self) -> Result<(f64, f64), RpcError> {
            let request = crate::schema::Request::from(self.get_anchor_min_call()?);
            let response = self.client.call(request)?;
            <(f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl RectTransform {
        pub(crate) fn get_local_position_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "UI",
                    "RectTransform_get_LocalPosition",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_local_position_stream(
            &self,
        ) -> Result<crate::stream::Stream<(f64, f64, f64)>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_local_position_call()?,
            )
        }
        pub fn get_local_position(&self) -> Result<(f64, f64, f64), RpcError> {
            let request = crate::schema::Request::from(self.get_local_position_call()?);
            let response = self.client.call(request)?;
            <(f64, f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl RectTransform {
        pub(crate) fn get_lower_left_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "UI",
                    "RectTransform_get_LowerLeft",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_lower_left_stream(
            &self,
        ) -> Result<crate::stream::Stream<(f64, f64)>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_lower_left_call()?)
        }
        pub fn get_lower_left(&self) -> Result<(f64, f64), RpcError> {
            let request = crate::schema::Request::from(self.get_lower_left_call()?);
            let response = self.client.call(request)?;
            <(f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl RectTransform {
        pub(crate) fn get_pivot_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "UI",
                    "RectTransform_get_Pivot",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_pivot_stream(
            &self,
        ) -> Result<crate::stream::Stream<(f64, f64)>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_pivot_call()?)
        }
        pub fn get_pivot(&self) -> Result<(f64, f64), RpcError> {
            let request = crate::schema::Request::from(self.get_pivot_call()?);
            let response = self.client.call(request)?;
            <(f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl RectTransform {
        pub(crate) fn get_position_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "UI",
                    "RectTransform_get_Position",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_position_stream(
            &self,
        ) -> Result<crate::stream::Stream<(f64, f64)>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_position_call()?)
        }
        pub fn get_position(&self) -> Result<(f64, f64), RpcError> {
            let request = crate::schema::Request::from(self.get_position_call()?);
            let response = self.client.call(request)?;
            <(f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl RectTransform {
        pub(crate) fn get_rotation_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "UI",
                    "RectTransform_get_Rotation",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_rotation_stream(
            &self,
        ) -> Result<crate::stream::Stream<(f64, f64, f64, f64)>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_rotation_call()?)
        }
        pub fn get_rotation(&self) -> Result<(f64, f64, f64, f64), RpcError> {
            let request = crate::schema::Request::from(self.get_rotation_call()?);
            let response = self.client.call(request)?;
            <(f64, f64, f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl RectTransform {
        pub(crate) fn get_scale_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "UI",
                    "RectTransform_get_Scale",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_scale_stream(
            &self,
        ) -> Result<crate::stream::Stream<(f64, f64, f64)>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_scale_call()?)
        }
        pub fn get_scale(&self) -> Result<(f64, f64, f64), RpcError> {
            let request = crate::schema::Request::from(self.get_scale_call()?);
            let response = self.client.call(request)?;
            <(f64, f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl RectTransform {
        pub(crate) fn get_size_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "UI",
                    "RectTransform_get_Size",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_size_stream(
            &self,
        ) -> Result<crate::stream::Stream<(f64, f64)>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_size_call()?)
        }
        pub fn get_size(&self) -> Result<(f64, f64), RpcError> {
            let request = crate::schema::Request::from(self.get_size_call()?);
            let response = self.client.call(request)?;
            <(f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl RectTransform {
        pub(crate) fn get_upper_right_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "UI",
                    "RectTransform_get_UpperRight",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_upper_right_stream(
            &self,
        ) -> Result<crate::stream::Stream<(f64, f64)>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_upper_right_call()?)
        }
        pub fn get_upper_right(&self) -> Result<(f64, f64), RpcError> {
            let request = crate::schema::Request::from(self.get_upper_right_call()?);
            let response = self.client.call(request)?;
            <(f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl RectTransform {
        pub(crate) fn set_anchor_call(
            &self,
            value: (f64, f64),
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "UI",
                    "RectTransform_set_Anchor",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_anchor_stream(
            &self,
            value: (f64, f64),
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.set_anchor_call(value)?)
        }
        pub fn set_anchor(&self, value: (f64, f64)) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_anchor_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl RectTransform {
        pub(crate) fn set_anchor_max_call(
            &self,
            value: (f64, f64),
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "UI",
                    "RectTransform_set_AnchorMax",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_anchor_max_stream(
            &self,
            value: (f64, f64),
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_anchor_max_call(value)?,
            )
        }
        pub fn set_anchor_max(&self, value: (f64, f64)) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_anchor_max_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl RectTransform {
        pub(crate) fn set_anchor_min_call(
            &self,
            value: (f64, f64),
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "UI",
                    "RectTransform_set_AnchorMin",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_anchor_min_stream(
            &self,
            value: (f64, f64),
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_anchor_min_call(value)?,
            )
        }
        pub fn set_anchor_min(&self, value: (f64, f64)) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_anchor_min_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl RectTransform {
        pub(crate) fn set_local_position_call(
            &self,
            value: (f64, f64, f64),
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "UI",
                    "RectTransform_set_LocalPosition",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_local_position_stream(
            &self,
            value: (f64, f64, f64),
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_local_position_call(value)?,
            )
        }
        pub fn set_local_position(
            &self,
            value: (f64, f64, f64),
        ) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_local_position_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl RectTransform {
        pub(crate) fn set_lower_left_call(
            &self,
            value: (f64, f64),
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "UI",
                    "RectTransform_set_LowerLeft",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_lower_left_stream(
            &self,
            value: (f64, f64),
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_lower_left_call(value)?,
            )
        }
        pub fn set_lower_left(&self, value: (f64, f64)) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_lower_left_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl RectTransform {
        pub(crate) fn set_pivot_call(
            &self,
            value: (f64, f64),
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "UI",
                    "RectTransform_set_Pivot",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_pivot_stream(
            &self,
            value: (f64, f64),
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.set_pivot_call(value)?)
        }
        pub fn set_pivot(&self, value: (f64, f64)) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_pivot_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl RectTransform {
        pub(crate) fn set_position_call(
            &self,
            value: (f64, f64),
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "UI",
                    "RectTransform_set_Position",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_position_stream(
            &self,
            value: (f64, f64),
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_position_call(value)?,
            )
        }
        pub fn set_position(&self, value: (f64, f64)) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_position_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl RectTransform {
        pub(crate) fn set_rotation_call(
            &self,
            value: (f64, f64, f64, f64),
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "UI",
                    "RectTransform_set_Rotation",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_rotation_stream(
            &self,
            value: (f64, f64, f64, f64),
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_rotation_call(value)?,
            )
        }
        pub fn set_rotation(&self, value: (f64, f64, f64, f64)) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_rotation_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl RectTransform {
        pub(crate) fn set_scale_call(
            &self,
            value: (f64, f64, f64),
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "UI",
                    "RectTransform_set_Scale",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_scale_stream(
            &self,
            value: (f64, f64, f64),
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.set_scale_call(value)?)
        }
        pub fn set_scale(&self, value: (f64, f64, f64)) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_scale_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl RectTransform {
        pub(crate) fn set_size_call(
            &self,
            value: (f64, f64),
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "UI",
                    "RectTransform_set_Size",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_size_stream(
            &self,
            value: (f64, f64),
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.set_size_call(value)?)
        }
        pub fn set_size(&self, value: (f64, f64)) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_size_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl RectTransform {
        pub(crate) fn set_upper_right_call(
            &self,
            value: (f64, f64),
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "UI",
                    "RectTransform_set_UpperRight",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_upper_right_stream(
            &self,
            value: (f64, f64),
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_upper_right_call(value)?,
            )
        }
        pub fn set_upper_right(&self, value: (f64, f64)) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_upper_right_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Text {
        pub(crate) fn remove_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "UI",
                    "Text_Remove",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn remove_stream(&self) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.remove_call()?)
        }
        pub fn remove(&self) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.remove_call()?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Text {
        pub(crate) fn get_alignment_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "UI",
                    "Text_get_Alignment",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_alignment_stream(
            &self,
        ) -> Result<crate::stream::Stream<crate::services::ui::TextAnchor>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_alignment_call()?)
        }
        pub fn get_alignment(
            &self,
        ) -> Result<crate::services::ui::TextAnchor, RpcError> {
            let request = crate::schema::Request::from(self.get_alignment_call()?);
            let response = self.client.call(request)?;
            <crate::services::ui::TextAnchor>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Text {
        pub(crate) fn get_available_fonts_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "UI",
                    "Text_get_AvailableFonts",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_available_fonts_stream(
            &self,
        ) -> Result<crate::stream::Stream<Vec<String>>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_available_fonts_call()?,
            )
        }
        pub fn get_available_fonts(&self) -> Result<Vec<String>, RpcError> {
            let request = crate::schema::Request::from(self.get_available_fonts_call()?);
            let response = self.client.call(request)?;
            <Vec<String>>::from_response(response, self.client.clone())
        }
    }
    impl Text {
        pub(crate) fn get_color_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "UI",
                    "Text_get_Color",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_color_stream(
            &self,
        ) -> Result<crate::stream::Stream<(f64, f64, f64)>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_color_call()?)
        }
        pub fn get_color(&self) -> Result<(f64, f64, f64), RpcError> {
            let request = crate::schema::Request::from(self.get_color_call()?);
            let response = self.client.call(request)?;
            <(f64, f64, f64)>::from_response(response, self.client.clone())
        }
    }
    impl Text {
        pub(crate) fn get_content_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "UI",
                    "Text_get_Content",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_content_stream(
            &self,
        ) -> Result<crate::stream::Stream<String>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_content_call()?)
        }
        pub fn get_content(&self) -> Result<String, RpcError> {
            let request = crate::schema::Request::from(self.get_content_call()?);
            let response = self.client.call(request)?;
            <String>::from_response(response, self.client.clone())
        }
    }
    impl Text {
        pub(crate) fn get_font_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "UI",
                    "Text_get_Font",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_font_stream(
            &self,
        ) -> Result<crate::stream::Stream<String>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_font_call()?)
        }
        pub fn get_font(&self) -> Result<String, RpcError> {
            let request = crate::schema::Request::from(self.get_font_call()?);
            let response = self.client.call(request)?;
            <String>::from_response(response, self.client.clone())
        }
    }
    impl Text {
        pub(crate) fn get_line_spacing_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "UI",
                    "Text_get_LineSpacing",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_line_spacing_stream(
            &self,
        ) -> Result<crate::stream::Stream<f32>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_line_spacing_call()?,
            )
        }
        pub fn get_line_spacing(&self) -> Result<f32, RpcError> {
            let request = crate::schema::Request::from(self.get_line_spacing_call()?);
            let response = self.client.call(request)?;
            <f32>::from_response(response, self.client.clone())
        }
    }
    impl Text {
        pub(crate) fn get_rect_transform_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "UI",
                    "Text_get_RectTransform",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_rect_transform_stream(
            &self,
        ) -> Result<
            crate::stream::Stream<crate::services::ui::RectTransform>,
            RpcError,
        > {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_rect_transform_call()?,
            )
        }
        pub fn get_rect_transform(
            &self,
        ) -> Result<crate::services::ui::RectTransform, RpcError> {
            let request = crate::schema::Request::from(self.get_rect_transform_call()?);
            let response = self.client.call(request)?;
            <crate::services::ui::RectTransform>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Text {
        pub(crate) fn get_size_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "UI",
                    "Text_get_Size",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_size_stream(&self) -> Result<crate::stream::Stream<i32>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_size_call()?)
        }
        pub fn get_size(&self) -> Result<i32, RpcError> {
            let request = crate::schema::Request::from(self.get_size_call()?);
            let response = self.client.call(request)?;
            <i32>::from_response(response, self.client.clone())
        }
    }
    impl Text {
        pub(crate) fn get_style_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "UI",
                    "Text_get_Style",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_style_stream(
            &self,
        ) -> Result<crate::stream::Stream<crate::services::ui::FontStyle>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_style_call()?)
        }
        pub fn get_style(&self) -> Result<crate::services::ui::FontStyle, RpcError> {
            let request = crate::schema::Request::from(self.get_style_call()?);
            let response = self.client.call(request)?;
            <crate::services::ui::FontStyle>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Text {
        pub(crate) fn get_visible_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "UI",
                    "Text_get_Visible",
                    vec![self.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn get_visible_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_visible_call()?)
        }
        pub fn get_visible(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_visible_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl Text {
        pub(crate) fn set_alignment_call(
            &self,
            value: crate::services::ui::TextAnchor,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "UI",
                    "Text_set_Alignment",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_alignment_stream(
            &self,
            value: crate::services::ui::TextAnchor,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_alignment_call(value)?,
            )
        }
        pub fn set_alignment(
            &self,
            value: crate::services::ui::TextAnchor,
        ) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_alignment_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Text {
        pub(crate) fn set_color_call(
            &self,
            value: (f64, f64, f64),
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "UI",
                    "Text_set_Color",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_color_stream(
            &self,
            value: (f64, f64, f64),
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.set_color_call(value)?)
        }
        pub fn set_color(&self, value: (f64, f64, f64)) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_color_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Text {
        pub(crate) fn set_content_call(
            &self,
            value: String,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "UI",
                    "Text_set_Content",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_content_stream(
            &self,
            value: String,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_content_call(value)?,
            )
        }
        pub fn set_content(&self, value: String) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_content_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Text {
        pub(crate) fn set_font_call(
            &self,
            value: String,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "UI",
                    "Text_set_Font",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_font_stream(
            &self,
            value: String,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.set_font_call(value)?)
        }
        pub fn set_font(&self, value: String) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_font_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Text {
        pub(crate) fn set_line_spacing_call(
            &self,
            value: f32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "UI",
                    "Text_set_LineSpacing",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_line_spacing_stream(
            &self,
            value: f32,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_line_spacing_call(value)?,
            )
        }
        pub fn set_line_spacing(&self, value: f32) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_line_spacing_call(value)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Text {
        pub(crate) fn set_size_call(
            &self,
            value: i32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "UI",
                    "Text_set_Size",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_size_stream(
            &self,
            value: i32,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.set_size_call(value)?)
        }
        pub fn set_size(&self, value: i32) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_size_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Text {
        pub(crate) fn set_style_call(
            &self,
            value: crate::services::ui::FontStyle,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "UI",
                    "Text_set_Style",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_style_stream(
            &self,
            value: crate::services::ui::FontStyle,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.set_style_call(value)?)
        }
        pub fn set_style(
            &self,
            value: crate::services::ui::FontStyle,
        ) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_style_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Text {
        pub(crate) fn set_visible_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "UI",
                    "Text_set_Visible",
                    vec![
                        self.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn set_visible_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_visible_call(value)?,
            )
        }
        pub fn set_visible(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_visible_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl UI {
        pub(crate) fn get_stock_canvas_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(crate::client::Client::proc_call("UI", "get_StockCanvas", vec![]))
        }
        pub fn get_stock_canvas_stream(
            &self,
        ) -> Result<crate::stream::Stream<crate::services::ui::Canvas>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_stock_canvas_call()?,
            )
        }
        pub fn get_stock_canvas(&self) -> Result<crate::services::ui::Canvas, RpcError> {
            let request = crate::schema::Request::from(self.get_stock_canvas_call()?);
            let response = self.client.call(request)?;
            <crate::services::ui::Canvas>::from_response(response, self.client.clone())
        }
    }
}
#[allow(clippy::type_complexity)]
pub mod krpc {
    use crate::{
        schema::{ToArgument, FromResponse},
        error::RpcError,
    };
    pub struct KRPC {
        pub client: ::std::sync::Arc<crate::Client>,
    }
    impl KRPC {
        pub fn new(client: ::std::sync::Arc<crate::Client>) -> Self {
            Self { client }
        }
    }
    crate::schema::rpc_object!(Expression);
    crate::schema::rpc_object!(Type);
    crate::schema::rpc_enum!(
        GameScene, [SpaceCenter, Flight, TrackingStation, EditorVAB, EditorSPH,]
    );
    impl KRPC {
        pub(crate) fn add_event_call(
            &self,
            expression: &crate::services::krpc::Expression,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KRPC",
                    "AddEvent",
                    vec![expression.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn add_event_stream(
            &self,
            expression: &crate::services::krpc::Expression,
        ) -> Result<crate::stream::Stream<crate::schema::Event>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.add_event_call(expression)?,
            )
        }
        pub fn add_event(
            &self,
            expression: &crate::services::krpc::Expression,
        ) -> Result<crate::schema::Event, RpcError> {
            let request = crate::schema::Request::from(self.add_event_call(expression)?);
            let response = self.client.call(request)?;
            <crate::schema::Event>::from_response(response, self.client.clone())
        }
    }
    impl KRPC {
        pub(crate) fn add_stream_call(
            &self,
            call: crate::schema::ProcedureCall,
            start: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KRPC",
                    "AddStream",
                    vec![
                        call.to_argument(0usize as u32) ?, start.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn add_stream_stream(
            &self,
            call: crate::schema::ProcedureCall,
            start: bool,
        ) -> Result<crate::stream::Stream<crate::schema::Stream>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.add_stream_call(call, start)?,
            )
        }
        pub fn add_stream(
            &self,
            call: crate::schema::ProcedureCall,
            start: bool,
        ) -> Result<crate::schema::Stream, RpcError> {
            let request = crate::schema::Request::from(
                self.add_stream_call(call, start)?,
            );
            let response = self.client.call(request)?;
            <crate::schema::Stream>::from_response(response, self.client.clone())
        }
    }
    impl Expression {
        pub(crate) fn static_add_call(
            &self,
            arg_0: &crate::services::krpc::Expression,
            arg_1: &crate::services::krpc::Expression,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KRPC",
                    "Expression_static_Add",
                    vec![
                        arg_0.to_argument(0usize as u32) ?, arg_1.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn static_add_stream(
            &self,
            arg_0: &crate::services::krpc::Expression,
            arg_1: &crate::services::krpc::Expression,
        ) -> Result<crate::stream::Stream<crate::services::krpc::Expression>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.static_add_call(arg_0, arg_1)?,
            )
        }
        pub fn static_add(
            &self,
            arg_0: &crate::services::krpc::Expression,
            arg_1: &crate::services::krpc::Expression,
        ) -> Result<crate::services::krpc::Expression, RpcError> {
            let request = crate::schema::Request::from(
                self.static_add_call(arg_0, arg_1)?,
            );
            let response = self.client.call(request)?;
            <crate::services::krpc::Expression>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Expression {
        pub(crate) fn static_aggregate_call(
            &self,
            arg: &crate::services::krpc::Expression,
            func: &crate::services::krpc::Expression,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KRPC",
                    "Expression_static_Aggregate",
                    vec![
                        arg.to_argument(0usize as u32) ?, func.to_argument(1usize as u32)
                        ?
                    ],
                ),
            )
        }
        pub fn static_aggregate_stream(
            &self,
            arg: &crate::services::krpc::Expression,
            func: &crate::services::krpc::Expression,
        ) -> Result<crate::stream::Stream<crate::services::krpc::Expression>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.static_aggregate_call(arg, func)?,
            )
        }
        pub fn static_aggregate(
            &self,
            arg: &crate::services::krpc::Expression,
            func: &crate::services::krpc::Expression,
        ) -> Result<crate::services::krpc::Expression, RpcError> {
            let request = crate::schema::Request::from(
                self.static_aggregate_call(arg, func)?,
            );
            let response = self.client.call(request)?;
            <crate::services::krpc::Expression>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Expression {
        pub(crate) fn static_aggregate_with_seed_call(
            &self,
            arg: &crate::services::krpc::Expression,
            seed: &crate::services::krpc::Expression,
            func: &crate::services::krpc::Expression,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KRPC",
                    "Expression_static_AggregateWithSeed",
                    vec![
                        arg.to_argument(0usize as u32) ?, seed.to_argument(1usize as u32)
                        ?, func.to_argument(2usize as u32) ?
                    ],
                ),
            )
        }
        pub fn static_aggregate_with_seed_stream(
            &self,
            arg: &crate::services::krpc::Expression,
            seed: &crate::services::krpc::Expression,
            func: &crate::services::krpc::Expression,
        ) -> Result<crate::stream::Stream<crate::services::krpc::Expression>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.static_aggregate_with_seed_call(arg, seed, func)?,
            )
        }
        pub fn static_aggregate_with_seed(
            &self,
            arg: &crate::services::krpc::Expression,
            seed: &crate::services::krpc::Expression,
            func: &crate::services::krpc::Expression,
        ) -> Result<crate::services::krpc::Expression, RpcError> {
            let request = crate::schema::Request::from(
                self.static_aggregate_with_seed_call(arg, seed, func)?,
            );
            let response = self.client.call(request)?;
            <crate::services::krpc::Expression>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Expression {
        pub(crate) fn static_all_call(
            &self,
            arg: &crate::services::krpc::Expression,
            predicate: &crate::services::krpc::Expression,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KRPC",
                    "Expression_static_All",
                    vec![
                        arg.to_argument(0usize as u32) ?, predicate.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn static_all_stream(
            &self,
            arg: &crate::services::krpc::Expression,
            predicate: &crate::services::krpc::Expression,
        ) -> Result<crate::stream::Stream<crate::services::krpc::Expression>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.static_all_call(arg, predicate)?,
            )
        }
        pub fn static_all(
            &self,
            arg: &crate::services::krpc::Expression,
            predicate: &crate::services::krpc::Expression,
        ) -> Result<crate::services::krpc::Expression, RpcError> {
            let request = crate::schema::Request::from(
                self.static_all_call(arg, predicate)?,
            );
            let response = self.client.call(request)?;
            <crate::services::krpc::Expression>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Expression {
        pub(crate) fn static_and_call(
            &self,
            arg_0: &crate::services::krpc::Expression,
            arg_1: &crate::services::krpc::Expression,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KRPC",
                    "Expression_static_And",
                    vec![
                        arg_0.to_argument(0usize as u32) ?, arg_1.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn static_and_stream(
            &self,
            arg_0: &crate::services::krpc::Expression,
            arg_1: &crate::services::krpc::Expression,
        ) -> Result<crate::stream::Stream<crate::services::krpc::Expression>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.static_and_call(arg_0, arg_1)?,
            )
        }
        pub fn static_and(
            &self,
            arg_0: &crate::services::krpc::Expression,
            arg_1: &crate::services::krpc::Expression,
        ) -> Result<crate::services::krpc::Expression, RpcError> {
            let request = crate::schema::Request::from(
                self.static_and_call(arg_0, arg_1)?,
            );
            let response = self.client.call(request)?;
            <crate::services::krpc::Expression>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Expression {
        pub(crate) fn static_any_call(
            &self,
            arg: &crate::services::krpc::Expression,
            predicate: &crate::services::krpc::Expression,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KRPC",
                    "Expression_static_Any",
                    vec![
                        arg.to_argument(0usize as u32) ?, predicate.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn static_any_stream(
            &self,
            arg: &crate::services::krpc::Expression,
            predicate: &crate::services::krpc::Expression,
        ) -> Result<crate::stream::Stream<crate::services::krpc::Expression>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.static_any_call(arg, predicate)?,
            )
        }
        pub fn static_any(
            &self,
            arg: &crate::services::krpc::Expression,
            predicate: &crate::services::krpc::Expression,
        ) -> Result<crate::services::krpc::Expression, RpcError> {
            let request = crate::schema::Request::from(
                self.static_any_call(arg, predicate)?,
            );
            let response = self.client.call(request)?;
            <crate::services::krpc::Expression>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Expression {
        pub(crate) fn static_average_call(
            &self,
            arg: &crate::services::krpc::Expression,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KRPC",
                    "Expression_static_Average",
                    vec![arg.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn static_average_stream(
            &self,
            arg: &crate::services::krpc::Expression,
        ) -> Result<crate::stream::Stream<crate::services::krpc::Expression>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.static_average_call(arg)?,
            )
        }
        pub fn static_average(
            &self,
            arg: &crate::services::krpc::Expression,
        ) -> Result<crate::services::krpc::Expression, RpcError> {
            let request = crate::schema::Request::from(self.static_average_call(arg)?);
            let response = self.client.call(request)?;
            <crate::services::krpc::Expression>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Expression {
        pub(crate) fn static_call_call(
            &self,
            call: crate::schema::ProcedureCall,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KRPC",
                    "Expression_static_Call",
                    vec![call.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn static_call_stream(
            &self,
            call: crate::schema::ProcedureCall,
        ) -> Result<crate::stream::Stream<crate::services::krpc::Expression>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.static_call_call(call)?)
        }
        pub fn static_call(
            &self,
            call: crate::schema::ProcedureCall,
        ) -> Result<crate::services::krpc::Expression, RpcError> {
            let request = crate::schema::Request::from(self.static_call_call(call)?);
            let response = self.client.call(request)?;
            <crate::services::krpc::Expression>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Expression {
        pub(crate) fn static_cast_call(
            &self,
            arg: &crate::services::krpc::Expression,
            r#type: &crate::services::krpc::Type,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KRPC",
                    "Expression_static_Cast",
                    vec![
                        arg.to_argument(0usize as u32) ?, r#type.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn static_cast_stream(
            &self,
            arg: &crate::services::krpc::Expression,
            r#type: &crate::services::krpc::Type,
        ) -> Result<crate::stream::Stream<crate::services::krpc::Expression>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.static_cast_call(arg, r#type)?,
            )
        }
        pub fn static_cast(
            &self,
            arg: &crate::services::krpc::Expression,
            r#type: &crate::services::krpc::Type,
        ) -> Result<crate::services::krpc::Expression, RpcError> {
            let request = crate::schema::Request::from(
                self.static_cast_call(arg, r#type)?,
            );
            let response = self.client.call(request)?;
            <crate::services::krpc::Expression>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Expression {
        pub(crate) fn static_concat_call(
            &self,
            arg_1: &crate::services::krpc::Expression,
            arg_2: &crate::services::krpc::Expression,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KRPC",
                    "Expression_static_Concat",
                    vec![
                        arg_1.to_argument(0usize as u32) ?, arg_2.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn static_concat_stream(
            &self,
            arg_1: &crate::services::krpc::Expression,
            arg_2: &crate::services::krpc::Expression,
        ) -> Result<crate::stream::Stream<crate::services::krpc::Expression>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.static_concat_call(arg_1, arg_2)?,
            )
        }
        pub fn static_concat(
            &self,
            arg_1: &crate::services::krpc::Expression,
            arg_2: &crate::services::krpc::Expression,
        ) -> Result<crate::services::krpc::Expression, RpcError> {
            let request = crate::schema::Request::from(
                self.static_concat_call(arg_1, arg_2)?,
            );
            let response = self.client.call(request)?;
            <crate::services::krpc::Expression>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Expression {
        pub(crate) fn static_constant_bool_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KRPC",
                    "Expression_static_ConstantBool",
                    vec![value.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn static_constant_bool_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<crate::services::krpc::Expression>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.static_constant_bool_call(value)?,
            )
        }
        pub fn static_constant_bool(
            &self,
            value: bool,
        ) -> Result<crate::services::krpc::Expression, RpcError> {
            let request = crate::schema::Request::from(
                self.static_constant_bool_call(value)?,
            );
            let response = self.client.call(request)?;
            <crate::services::krpc::Expression>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Expression {
        pub(crate) fn static_constant_double_call(
            &self,
            value: f64,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KRPC",
                    "Expression_static_ConstantDouble",
                    vec![value.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn static_constant_double_stream(
            &self,
            value: f64,
        ) -> Result<crate::stream::Stream<crate::services::krpc::Expression>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.static_constant_double_call(value)?,
            )
        }
        pub fn static_constant_double(
            &self,
            value: f64,
        ) -> Result<crate::services::krpc::Expression, RpcError> {
            let request = crate::schema::Request::from(
                self.static_constant_double_call(value)?,
            );
            let response = self.client.call(request)?;
            <crate::services::krpc::Expression>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Expression {
        pub(crate) fn static_constant_float_call(
            &self,
            value: f32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KRPC",
                    "Expression_static_ConstantFloat",
                    vec![value.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn static_constant_float_stream(
            &self,
            value: f32,
        ) -> Result<crate::stream::Stream<crate::services::krpc::Expression>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.static_constant_float_call(value)?,
            )
        }
        pub fn static_constant_float(
            &self,
            value: f32,
        ) -> Result<crate::services::krpc::Expression, RpcError> {
            let request = crate::schema::Request::from(
                self.static_constant_float_call(value)?,
            );
            let response = self.client.call(request)?;
            <crate::services::krpc::Expression>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Expression {
        pub(crate) fn static_constant_int_call(
            &self,
            value: i32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KRPC",
                    "Expression_static_ConstantInt",
                    vec![value.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn static_constant_int_stream(
            &self,
            value: i32,
        ) -> Result<crate::stream::Stream<crate::services::krpc::Expression>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.static_constant_int_call(value)?,
            )
        }
        pub fn static_constant_int(
            &self,
            value: i32,
        ) -> Result<crate::services::krpc::Expression, RpcError> {
            let request = crate::schema::Request::from(
                self.static_constant_int_call(value)?,
            );
            let response = self.client.call(request)?;
            <crate::services::krpc::Expression>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Expression {
        pub(crate) fn static_constant_string_call(
            &self,
            value: String,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KRPC",
                    "Expression_static_ConstantString",
                    vec![value.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn static_constant_string_stream(
            &self,
            value: String,
        ) -> Result<crate::stream::Stream<crate::services::krpc::Expression>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.static_constant_string_call(value)?,
            )
        }
        pub fn static_constant_string(
            &self,
            value: String,
        ) -> Result<crate::services::krpc::Expression, RpcError> {
            let request = crate::schema::Request::from(
                self.static_constant_string_call(value)?,
            );
            let response = self.client.call(request)?;
            <crate::services::krpc::Expression>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Expression {
        pub(crate) fn static_contains_call(
            &self,
            arg: &crate::services::krpc::Expression,
            value: &crate::services::krpc::Expression,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KRPC",
                    "Expression_static_Contains",
                    vec![
                        arg.to_argument(0usize as u32) ?, value.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn static_contains_stream(
            &self,
            arg: &crate::services::krpc::Expression,
            value: &crate::services::krpc::Expression,
        ) -> Result<crate::stream::Stream<crate::services::krpc::Expression>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.static_contains_call(arg, value)?,
            )
        }
        pub fn static_contains(
            &self,
            arg: &crate::services::krpc::Expression,
            value: &crate::services::krpc::Expression,
        ) -> Result<crate::services::krpc::Expression, RpcError> {
            let request = crate::schema::Request::from(
                self.static_contains_call(arg, value)?,
            );
            let response = self.client.call(request)?;
            <crate::services::krpc::Expression>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Expression {
        pub(crate) fn static_count_call(
            &self,
            arg: &crate::services::krpc::Expression,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KRPC",
                    "Expression_static_Count",
                    vec![arg.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn static_count_stream(
            &self,
            arg: &crate::services::krpc::Expression,
        ) -> Result<crate::stream::Stream<crate::services::krpc::Expression>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.static_count_call(arg)?)
        }
        pub fn static_count(
            &self,
            arg: &crate::services::krpc::Expression,
        ) -> Result<crate::services::krpc::Expression, RpcError> {
            let request = crate::schema::Request::from(self.static_count_call(arg)?);
            let response = self.client.call(request)?;
            <crate::services::krpc::Expression>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Expression {
        pub(crate) fn static_create_dictionary_call(
            &self,
            keys: Vec<crate::services::krpc::Expression>,
            values: Vec<crate::services::krpc::Expression>,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KRPC",
                    "Expression_static_CreateDictionary",
                    vec![
                        keys.to_argument(0usize as u32) ?, values.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn static_create_dictionary_stream(
            &self,
            keys: Vec<crate::services::krpc::Expression>,
            values: Vec<crate::services::krpc::Expression>,
        ) -> Result<crate::stream::Stream<crate::services::krpc::Expression>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.static_create_dictionary_call(keys, values)?,
            )
        }
        pub fn static_create_dictionary(
            &self,
            keys: Vec<crate::services::krpc::Expression>,
            values: Vec<crate::services::krpc::Expression>,
        ) -> Result<crate::services::krpc::Expression, RpcError> {
            let request = crate::schema::Request::from(
                self.static_create_dictionary_call(keys, values)?,
            );
            let response = self.client.call(request)?;
            <crate::services::krpc::Expression>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Expression {
        pub(crate) fn static_create_list_call(
            &self,
            values: Vec<crate::services::krpc::Expression>,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KRPC",
                    "Expression_static_CreateList",
                    vec![values.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn static_create_list_stream(
            &self,
            values: Vec<crate::services::krpc::Expression>,
        ) -> Result<crate::stream::Stream<crate::services::krpc::Expression>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.static_create_list_call(values)?,
            )
        }
        pub fn static_create_list(
            &self,
            values: Vec<crate::services::krpc::Expression>,
        ) -> Result<crate::services::krpc::Expression, RpcError> {
            let request = crate::schema::Request::from(
                self.static_create_list_call(values)?,
            );
            let response = self.client.call(request)?;
            <crate::services::krpc::Expression>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Expression {
        pub(crate) fn static_create_set_call(
            &self,
            values: std::collections::HashSet<crate::services::krpc::Expression>,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KRPC",
                    "Expression_static_CreateSet",
                    vec![values.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn static_create_set_stream(
            &self,
            values: std::collections::HashSet<crate::services::krpc::Expression>,
        ) -> Result<crate::stream::Stream<crate::services::krpc::Expression>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.static_create_set_call(values)?,
            )
        }
        pub fn static_create_set(
            &self,
            values: std::collections::HashSet<crate::services::krpc::Expression>,
        ) -> Result<crate::services::krpc::Expression, RpcError> {
            let request = crate::schema::Request::from(
                self.static_create_set_call(values)?,
            );
            let response = self.client.call(request)?;
            <crate::services::krpc::Expression>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Expression {
        pub(crate) fn static_create_tuple_call(
            &self,
            elements: Vec<crate::services::krpc::Expression>,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KRPC",
                    "Expression_static_CreateTuple",
                    vec![elements.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn static_create_tuple_stream(
            &self,
            elements: Vec<crate::services::krpc::Expression>,
        ) -> Result<crate::stream::Stream<crate::services::krpc::Expression>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.static_create_tuple_call(elements)?,
            )
        }
        pub fn static_create_tuple(
            &self,
            elements: Vec<crate::services::krpc::Expression>,
        ) -> Result<crate::services::krpc::Expression, RpcError> {
            let request = crate::schema::Request::from(
                self.static_create_tuple_call(elements)?,
            );
            let response = self.client.call(request)?;
            <crate::services::krpc::Expression>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Expression {
        pub(crate) fn static_divide_call(
            &self,
            arg_0: &crate::services::krpc::Expression,
            arg_1: &crate::services::krpc::Expression,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KRPC",
                    "Expression_static_Divide",
                    vec![
                        arg_0.to_argument(0usize as u32) ?, arg_1.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn static_divide_stream(
            &self,
            arg_0: &crate::services::krpc::Expression,
            arg_1: &crate::services::krpc::Expression,
        ) -> Result<crate::stream::Stream<crate::services::krpc::Expression>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.static_divide_call(arg_0, arg_1)?,
            )
        }
        pub fn static_divide(
            &self,
            arg_0: &crate::services::krpc::Expression,
            arg_1: &crate::services::krpc::Expression,
        ) -> Result<crate::services::krpc::Expression, RpcError> {
            let request = crate::schema::Request::from(
                self.static_divide_call(arg_0, arg_1)?,
            );
            let response = self.client.call(request)?;
            <crate::services::krpc::Expression>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Expression {
        pub(crate) fn static_equal_call(
            &self,
            arg_0: &crate::services::krpc::Expression,
            arg_1: &crate::services::krpc::Expression,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KRPC",
                    "Expression_static_Equal",
                    vec![
                        arg_0.to_argument(0usize as u32) ?, arg_1.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn static_equal_stream(
            &self,
            arg_0: &crate::services::krpc::Expression,
            arg_1: &crate::services::krpc::Expression,
        ) -> Result<crate::stream::Stream<crate::services::krpc::Expression>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.static_equal_call(arg_0, arg_1)?,
            )
        }
        pub fn static_equal(
            &self,
            arg_0: &crate::services::krpc::Expression,
            arg_1: &crate::services::krpc::Expression,
        ) -> Result<crate::services::krpc::Expression, RpcError> {
            let request = crate::schema::Request::from(
                self.static_equal_call(arg_0, arg_1)?,
            );
            let response = self.client.call(request)?;
            <crate::services::krpc::Expression>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Expression {
        pub(crate) fn static_exclusive_or_call(
            &self,
            arg_0: &crate::services::krpc::Expression,
            arg_1: &crate::services::krpc::Expression,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KRPC",
                    "Expression_static_ExclusiveOr",
                    vec![
                        arg_0.to_argument(0usize as u32) ?, arg_1.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn static_exclusive_or_stream(
            &self,
            arg_0: &crate::services::krpc::Expression,
            arg_1: &crate::services::krpc::Expression,
        ) -> Result<crate::stream::Stream<crate::services::krpc::Expression>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.static_exclusive_or_call(arg_0, arg_1)?,
            )
        }
        pub fn static_exclusive_or(
            &self,
            arg_0: &crate::services::krpc::Expression,
            arg_1: &crate::services::krpc::Expression,
        ) -> Result<crate::services::krpc::Expression, RpcError> {
            let request = crate::schema::Request::from(
                self.static_exclusive_or_call(arg_0, arg_1)?,
            );
            let response = self.client.call(request)?;
            <crate::services::krpc::Expression>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Expression {
        pub(crate) fn static_function_call(
            &self,
            parameters: Vec<crate::services::krpc::Expression>,
            body: &crate::services::krpc::Expression,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KRPC",
                    "Expression_static_Function",
                    vec![
                        parameters.to_argument(0usize as u32) ?, body.to_argument(1usize
                        as u32) ?
                    ],
                ),
            )
        }
        pub fn static_function_stream(
            &self,
            parameters: Vec<crate::services::krpc::Expression>,
            body: &crate::services::krpc::Expression,
        ) -> Result<crate::stream::Stream<crate::services::krpc::Expression>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.static_function_call(parameters, body)?,
            )
        }
        pub fn static_function(
            &self,
            parameters: Vec<crate::services::krpc::Expression>,
            body: &crate::services::krpc::Expression,
        ) -> Result<crate::services::krpc::Expression, RpcError> {
            let request = crate::schema::Request::from(
                self.static_function_call(parameters, body)?,
            );
            let response = self.client.call(request)?;
            <crate::services::krpc::Expression>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Expression {
        pub(crate) fn static_get_call(
            &self,
            arg: &crate::services::krpc::Expression,
            index: &crate::services::krpc::Expression,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KRPC",
                    "Expression_static_Get",
                    vec![
                        arg.to_argument(0usize as u32) ?, index.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn static_get_stream(
            &self,
            arg: &crate::services::krpc::Expression,
            index: &crate::services::krpc::Expression,
        ) -> Result<crate::stream::Stream<crate::services::krpc::Expression>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.static_get_call(arg, index)?,
            )
        }
        pub fn static_get(
            &self,
            arg: &crate::services::krpc::Expression,
            index: &crate::services::krpc::Expression,
        ) -> Result<crate::services::krpc::Expression, RpcError> {
            let request = crate::schema::Request::from(
                self.static_get_call(arg, index)?,
            );
            let response = self.client.call(request)?;
            <crate::services::krpc::Expression>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Expression {
        pub(crate) fn static_greater_than_call(
            &self,
            arg_0: &crate::services::krpc::Expression,
            arg_1: &crate::services::krpc::Expression,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KRPC",
                    "Expression_static_GreaterThan",
                    vec![
                        arg_0.to_argument(0usize as u32) ?, arg_1.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn static_greater_than_stream(
            &self,
            arg_0: &crate::services::krpc::Expression,
            arg_1: &crate::services::krpc::Expression,
        ) -> Result<crate::stream::Stream<crate::services::krpc::Expression>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.static_greater_than_call(arg_0, arg_1)?,
            )
        }
        pub fn static_greater_than(
            &self,
            arg_0: &crate::services::krpc::Expression,
            arg_1: &crate::services::krpc::Expression,
        ) -> Result<crate::services::krpc::Expression, RpcError> {
            let request = crate::schema::Request::from(
                self.static_greater_than_call(arg_0, arg_1)?,
            );
            let response = self.client.call(request)?;
            <crate::services::krpc::Expression>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Expression {
        pub(crate) fn static_greater_than_or_equal_call(
            &self,
            arg_0: &crate::services::krpc::Expression,
            arg_1: &crate::services::krpc::Expression,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KRPC",
                    "Expression_static_GreaterThanOrEqual",
                    vec![
                        arg_0.to_argument(0usize as u32) ?, arg_1.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn static_greater_than_or_equal_stream(
            &self,
            arg_0: &crate::services::krpc::Expression,
            arg_1: &crate::services::krpc::Expression,
        ) -> Result<crate::stream::Stream<crate::services::krpc::Expression>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.static_greater_than_or_equal_call(arg_0, arg_1)?,
            )
        }
        pub fn static_greater_than_or_equal(
            &self,
            arg_0: &crate::services::krpc::Expression,
            arg_1: &crate::services::krpc::Expression,
        ) -> Result<crate::services::krpc::Expression, RpcError> {
            let request = crate::schema::Request::from(
                self.static_greater_than_or_equal_call(arg_0, arg_1)?,
            );
            let response = self.client.call(request)?;
            <crate::services::krpc::Expression>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Expression {
        pub(crate) fn static_invoke_call(
            &self,
            function: &crate::services::krpc::Expression,
            args: std::collections::HashMap<String, crate::services::krpc::Expression>,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KRPC",
                    "Expression_static_Invoke",
                    vec![
                        function.to_argument(0usize as u32) ?, args.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn static_invoke_stream(
            &self,
            function: &crate::services::krpc::Expression,
            args: std::collections::HashMap<String, crate::services::krpc::Expression>,
        ) -> Result<crate::stream::Stream<crate::services::krpc::Expression>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.static_invoke_call(function, args)?,
            )
        }
        pub fn static_invoke(
            &self,
            function: &crate::services::krpc::Expression,
            args: std::collections::HashMap<String, crate::services::krpc::Expression>,
        ) -> Result<crate::services::krpc::Expression, RpcError> {
            let request = crate::schema::Request::from(
                self.static_invoke_call(function, args)?,
            );
            let response = self.client.call(request)?;
            <crate::services::krpc::Expression>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Expression {
        pub(crate) fn static_left_shift_call(
            &self,
            arg_0: &crate::services::krpc::Expression,
            arg_1: &crate::services::krpc::Expression,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KRPC",
                    "Expression_static_LeftShift",
                    vec![
                        arg_0.to_argument(0usize as u32) ?, arg_1.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn static_left_shift_stream(
            &self,
            arg_0: &crate::services::krpc::Expression,
            arg_1: &crate::services::krpc::Expression,
        ) -> Result<crate::stream::Stream<crate::services::krpc::Expression>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.static_left_shift_call(arg_0, arg_1)?,
            )
        }
        pub fn static_left_shift(
            &self,
            arg_0: &crate::services::krpc::Expression,
            arg_1: &crate::services::krpc::Expression,
        ) -> Result<crate::services::krpc::Expression, RpcError> {
            let request = crate::schema::Request::from(
                self.static_left_shift_call(arg_0, arg_1)?,
            );
            let response = self.client.call(request)?;
            <crate::services::krpc::Expression>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Expression {
        pub(crate) fn static_less_than_call(
            &self,
            arg_0: &crate::services::krpc::Expression,
            arg_1: &crate::services::krpc::Expression,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KRPC",
                    "Expression_static_LessThan",
                    vec![
                        arg_0.to_argument(0usize as u32) ?, arg_1.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn static_less_than_stream(
            &self,
            arg_0: &crate::services::krpc::Expression,
            arg_1: &crate::services::krpc::Expression,
        ) -> Result<crate::stream::Stream<crate::services::krpc::Expression>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.static_less_than_call(arg_0, arg_1)?,
            )
        }
        pub fn static_less_than(
            &self,
            arg_0: &crate::services::krpc::Expression,
            arg_1: &crate::services::krpc::Expression,
        ) -> Result<crate::services::krpc::Expression, RpcError> {
            let request = crate::schema::Request::from(
                self.static_less_than_call(arg_0, arg_1)?,
            );
            let response = self.client.call(request)?;
            <crate::services::krpc::Expression>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Expression {
        pub(crate) fn static_less_than_or_equal_call(
            &self,
            arg_0: &crate::services::krpc::Expression,
            arg_1: &crate::services::krpc::Expression,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KRPC",
                    "Expression_static_LessThanOrEqual",
                    vec![
                        arg_0.to_argument(0usize as u32) ?, arg_1.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn static_less_than_or_equal_stream(
            &self,
            arg_0: &crate::services::krpc::Expression,
            arg_1: &crate::services::krpc::Expression,
        ) -> Result<crate::stream::Stream<crate::services::krpc::Expression>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.static_less_than_or_equal_call(arg_0, arg_1)?,
            )
        }
        pub fn static_less_than_or_equal(
            &self,
            arg_0: &crate::services::krpc::Expression,
            arg_1: &crate::services::krpc::Expression,
        ) -> Result<crate::services::krpc::Expression, RpcError> {
            let request = crate::schema::Request::from(
                self.static_less_than_or_equal_call(arg_0, arg_1)?,
            );
            let response = self.client.call(request)?;
            <crate::services::krpc::Expression>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Expression {
        pub(crate) fn static_max_call(
            &self,
            arg: &crate::services::krpc::Expression,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KRPC",
                    "Expression_static_Max",
                    vec![arg.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn static_max_stream(
            &self,
            arg: &crate::services::krpc::Expression,
        ) -> Result<crate::stream::Stream<crate::services::krpc::Expression>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.static_max_call(arg)?)
        }
        pub fn static_max(
            &self,
            arg: &crate::services::krpc::Expression,
        ) -> Result<crate::services::krpc::Expression, RpcError> {
            let request = crate::schema::Request::from(self.static_max_call(arg)?);
            let response = self.client.call(request)?;
            <crate::services::krpc::Expression>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Expression {
        pub(crate) fn static_min_call(
            &self,
            arg: &crate::services::krpc::Expression,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KRPC",
                    "Expression_static_Min",
                    vec![arg.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn static_min_stream(
            &self,
            arg: &crate::services::krpc::Expression,
        ) -> Result<crate::stream::Stream<crate::services::krpc::Expression>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.static_min_call(arg)?)
        }
        pub fn static_min(
            &self,
            arg: &crate::services::krpc::Expression,
        ) -> Result<crate::services::krpc::Expression, RpcError> {
            let request = crate::schema::Request::from(self.static_min_call(arg)?);
            let response = self.client.call(request)?;
            <crate::services::krpc::Expression>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Expression {
        pub(crate) fn static_modulo_call(
            &self,
            arg_0: &crate::services::krpc::Expression,
            arg_1: &crate::services::krpc::Expression,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KRPC",
                    "Expression_static_Modulo",
                    vec![
                        arg_0.to_argument(0usize as u32) ?, arg_1.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn static_modulo_stream(
            &self,
            arg_0: &crate::services::krpc::Expression,
            arg_1: &crate::services::krpc::Expression,
        ) -> Result<crate::stream::Stream<crate::services::krpc::Expression>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.static_modulo_call(arg_0, arg_1)?,
            )
        }
        pub fn static_modulo(
            &self,
            arg_0: &crate::services::krpc::Expression,
            arg_1: &crate::services::krpc::Expression,
        ) -> Result<crate::services::krpc::Expression, RpcError> {
            let request = crate::schema::Request::from(
                self.static_modulo_call(arg_0, arg_1)?,
            );
            let response = self.client.call(request)?;
            <crate::services::krpc::Expression>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Expression {
        pub(crate) fn static_multiply_call(
            &self,
            arg_0: &crate::services::krpc::Expression,
            arg_1: &crate::services::krpc::Expression,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KRPC",
                    "Expression_static_Multiply",
                    vec![
                        arg_0.to_argument(0usize as u32) ?, arg_1.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn static_multiply_stream(
            &self,
            arg_0: &crate::services::krpc::Expression,
            arg_1: &crate::services::krpc::Expression,
        ) -> Result<crate::stream::Stream<crate::services::krpc::Expression>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.static_multiply_call(arg_0, arg_1)?,
            )
        }
        pub fn static_multiply(
            &self,
            arg_0: &crate::services::krpc::Expression,
            arg_1: &crate::services::krpc::Expression,
        ) -> Result<crate::services::krpc::Expression, RpcError> {
            let request = crate::schema::Request::from(
                self.static_multiply_call(arg_0, arg_1)?,
            );
            let response = self.client.call(request)?;
            <crate::services::krpc::Expression>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Expression {
        pub(crate) fn static_not_call(
            &self,
            arg: &crate::services::krpc::Expression,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KRPC",
                    "Expression_static_Not",
                    vec![arg.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn static_not_stream(
            &self,
            arg: &crate::services::krpc::Expression,
        ) -> Result<crate::stream::Stream<crate::services::krpc::Expression>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.static_not_call(arg)?)
        }
        pub fn static_not(
            &self,
            arg: &crate::services::krpc::Expression,
        ) -> Result<crate::services::krpc::Expression, RpcError> {
            let request = crate::schema::Request::from(self.static_not_call(arg)?);
            let response = self.client.call(request)?;
            <crate::services::krpc::Expression>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Expression {
        pub(crate) fn static_not_equal_call(
            &self,
            arg_0: &crate::services::krpc::Expression,
            arg_1: &crate::services::krpc::Expression,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KRPC",
                    "Expression_static_NotEqual",
                    vec![
                        arg_0.to_argument(0usize as u32) ?, arg_1.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn static_not_equal_stream(
            &self,
            arg_0: &crate::services::krpc::Expression,
            arg_1: &crate::services::krpc::Expression,
        ) -> Result<crate::stream::Stream<crate::services::krpc::Expression>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.static_not_equal_call(arg_0, arg_1)?,
            )
        }
        pub fn static_not_equal(
            &self,
            arg_0: &crate::services::krpc::Expression,
            arg_1: &crate::services::krpc::Expression,
        ) -> Result<crate::services::krpc::Expression, RpcError> {
            let request = crate::schema::Request::from(
                self.static_not_equal_call(arg_0, arg_1)?,
            );
            let response = self.client.call(request)?;
            <crate::services::krpc::Expression>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Expression {
        pub(crate) fn static_or_call(
            &self,
            arg_0: &crate::services::krpc::Expression,
            arg_1: &crate::services::krpc::Expression,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KRPC",
                    "Expression_static_Or",
                    vec![
                        arg_0.to_argument(0usize as u32) ?, arg_1.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn static_or_stream(
            &self,
            arg_0: &crate::services::krpc::Expression,
            arg_1: &crate::services::krpc::Expression,
        ) -> Result<crate::stream::Stream<crate::services::krpc::Expression>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.static_or_call(arg_0, arg_1)?,
            )
        }
        pub fn static_or(
            &self,
            arg_0: &crate::services::krpc::Expression,
            arg_1: &crate::services::krpc::Expression,
        ) -> Result<crate::services::krpc::Expression, RpcError> {
            let request = crate::schema::Request::from(
                self.static_or_call(arg_0, arg_1)?,
            );
            let response = self.client.call(request)?;
            <crate::services::krpc::Expression>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Expression {
        pub(crate) fn static_order_by_call(
            &self,
            arg: &crate::services::krpc::Expression,
            key: &crate::services::krpc::Expression,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KRPC",
                    "Expression_static_OrderBy",
                    vec![
                        arg.to_argument(0usize as u32) ?, key.to_argument(1usize as u32)
                        ?
                    ],
                ),
            )
        }
        pub fn static_order_by_stream(
            &self,
            arg: &crate::services::krpc::Expression,
            key: &crate::services::krpc::Expression,
        ) -> Result<crate::stream::Stream<crate::services::krpc::Expression>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.static_order_by_call(arg, key)?,
            )
        }
        pub fn static_order_by(
            &self,
            arg: &crate::services::krpc::Expression,
            key: &crate::services::krpc::Expression,
        ) -> Result<crate::services::krpc::Expression, RpcError> {
            let request = crate::schema::Request::from(
                self.static_order_by_call(arg, key)?,
            );
            let response = self.client.call(request)?;
            <crate::services::krpc::Expression>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Expression {
        pub(crate) fn static_parameter_call(
            &self,
            name: String,
            r#type: &crate::services::krpc::Type,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KRPC",
                    "Expression_static_Parameter",
                    vec![
                        name.to_argument(0usize as u32) ?, r#type.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn static_parameter_stream(
            &self,
            name: String,
            r#type: &crate::services::krpc::Type,
        ) -> Result<crate::stream::Stream<crate::services::krpc::Expression>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.static_parameter_call(name, r#type)?,
            )
        }
        pub fn static_parameter(
            &self,
            name: String,
            r#type: &crate::services::krpc::Type,
        ) -> Result<crate::services::krpc::Expression, RpcError> {
            let request = crate::schema::Request::from(
                self.static_parameter_call(name, r#type)?,
            );
            let response = self.client.call(request)?;
            <crate::services::krpc::Expression>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Expression {
        pub(crate) fn static_power_call(
            &self,
            arg_0: &crate::services::krpc::Expression,
            arg_1: &crate::services::krpc::Expression,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KRPC",
                    "Expression_static_Power",
                    vec![
                        arg_0.to_argument(0usize as u32) ?, arg_1.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn static_power_stream(
            &self,
            arg_0: &crate::services::krpc::Expression,
            arg_1: &crate::services::krpc::Expression,
        ) -> Result<crate::stream::Stream<crate::services::krpc::Expression>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.static_power_call(arg_0, arg_1)?,
            )
        }
        pub fn static_power(
            &self,
            arg_0: &crate::services::krpc::Expression,
            arg_1: &crate::services::krpc::Expression,
        ) -> Result<crate::services::krpc::Expression, RpcError> {
            let request = crate::schema::Request::from(
                self.static_power_call(arg_0, arg_1)?,
            );
            let response = self.client.call(request)?;
            <crate::services::krpc::Expression>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Expression {
        pub(crate) fn static_right_shift_call(
            &self,
            arg_0: &crate::services::krpc::Expression,
            arg_1: &crate::services::krpc::Expression,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KRPC",
                    "Expression_static_RightShift",
                    vec![
                        arg_0.to_argument(0usize as u32) ?, arg_1.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn static_right_shift_stream(
            &self,
            arg_0: &crate::services::krpc::Expression,
            arg_1: &crate::services::krpc::Expression,
        ) -> Result<crate::stream::Stream<crate::services::krpc::Expression>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.static_right_shift_call(arg_0, arg_1)?,
            )
        }
        pub fn static_right_shift(
            &self,
            arg_0: &crate::services::krpc::Expression,
            arg_1: &crate::services::krpc::Expression,
        ) -> Result<crate::services::krpc::Expression, RpcError> {
            let request = crate::schema::Request::from(
                self.static_right_shift_call(arg_0, arg_1)?,
            );
            let response = self.client.call(request)?;
            <crate::services::krpc::Expression>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Expression {
        pub(crate) fn static_select_call(
            &self,
            arg: &crate::services::krpc::Expression,
            func: &crate::services::krpc::Expression,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KRPC",
                    "Expression_static_Select",
                    vec![
                        arg.to_argument(0usize as u32) ?, func.to_argument(1usize as u32)
                        ?
                    ],
                ),
            )
        }
        pub fn static_select_stream(
            &self,
            arg: &crate::services::krpc::Expression,
            func: &crate::services::krpc::Expression,
        ) -> Result<crate::stream::Stream<crate::services::krpc::Expression>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.static_select_call(arg, func)?,
            )
        }
        pub fn static_select(
            &self,
            arg: &crate::services::krpc::Expression,
            func: &crate::services::krpc::Expression,
        ) -> Result<crate::services::krpc::Expression, RpcError> {
            let request = crate::schema::Request::from(
                self.static_select_call(arg, func)?,
            );
            let response = self.client.call(request)?;
            <crate::services::krpc::Expression>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Expression {
        pub(crate) fn static_subtract_call(
            &self,
            arg_0: &crate::services::krpc::Expression,
            arg_1: &crate::services::krpc::Expression,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KRPC",
                    "Expression_static_Subtract",
                    vec![
                        arg_0.to_argument(0usize as u32) ?, arg_1.to_argument(1usize as
                        u32) ?
                    ],
                ),
            )
        }
        pub fn static_subtract_stream(
            &self,
            arg_0: &crate::services::krpc::Expression,
            arg_1: &crate::services::krpc::Expression,
        ) -> Result<crate::stream::Stream<crate::services::krpc::Expression>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.static_subtract_call(arg_0, arg_1)?,
            )
        }
        pub fn static_subtract(
            &self,
            arg_0: &crate::services::krpc::Expression,
            arg_1: &crate::services::krpc::Expression,
        ) -> Result<crate::services::krpc::Expression, RpcError> {
            let request = crate::schema::Request::from(
                self.static_subtract_call(arg_0, arg_1)?,
            );
            let response = self.client.call(request)?;
            <crate::services::krpc::Expression>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Expression {
        pub(crate) fn static_sum_call(
            &self,
            arg: &crate::services::krpc::Expression,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KRPC",
                    "Expression_static_Sum",
                    vec![arg.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn static_sum_stream(
            &self,
            arg: &crate::services::krpc::Expression,
        ) -> Result<crate::stream::Stream<crate::services::krpc::Expression>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.static_sum_call(arg)?)
        }
        pub fn static_sum(
            &self,
            arg: &crate::services::krpc::Expression,
        ) -> Result<crate::services::krpc::Expression, RpcError> {
            let request = crate::schema::Request::from(self.static_sum_call(arg)?);
            let response = self.client.call(request)?;
            <crate::services::krpc::Expression>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Expression {
        pub(crate) fn static_to_list_call(
            &self,
            arg: &crate::services::krpc::Expression,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KRPC",
                    "Expression_static_ToList",
                    vec![arg.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn static_to_list_stream(
            &self,
            arg: &crate::services::krpc::Expression,
        ) -> Result<crate::stream::Stream<crate::services::krpc::Expression>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.static_to_list_call(arg)?,
            )
        }
        pub fn static_to_list(
            &self,
            arg: &crate::services::krpc::Expression,
        ) -> Result<crate::services::krpc::Expression, RpcError> {
            let request = crate::schema::Request::from(self.static_to_list_call(arg)?);
            let response = self.client.call(request)?;
            <crate::services::krpc::Expression>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Expression {
        pub(crate) fn static_to_set_call(
            &self,
            arg: &crate::services::krpc::Expression,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KRPC",
                    "Expression_static_ToSet",
                    vec![arg.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn static_to_set_stream(
            &self,
            arg: &crate::services::krpc::Expression,
        ) -> Result<crate::stream::Stream<crate::services::krpc::Expression>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.static_to_set_call(arg)?,
            )
        }
        pub fn static_to_set(
            &self,
            arg: &crate::services::krpc::Expression,
        ) -> Result<crate::services::krpc::Expression, RpcError> {
            let request = crate::schema::Request::from(self.static_to_set_call(arg)?);
            let response = self.client.call(request)?;
            <crate::services::krpc::Expression>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl Expression {
        pub(crate) fn static_where_call(
            &self,
            arg: &crate::services::krpc::Expression,
            func: &crate::services::krpc::Expression,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KRPC",
                    "Expression_static_Where",
                    vec![
                        arg.to_argument(0usize as u32) ?, func.to_argument(1usize as u32)
                        ?
                    ],
                ),
            )
        }
        pub fn static_where_stream(
            &self,
            arg: &crate::services::krpc::Expression,
            func: &crate::services::krpc::Expression,
        ) -> Result<crate::stream::Stream<crate::services::krpc::Expression>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.static_where_call(arg, func)?,
            )
        }
        pub fn static_where(
            &self,
            arg: &crate::services::krpc::Expression,
            func: &crate::services::krpc::Expression,
        ) -> Result<crate::services::krpc::Expression, RpcError> {
            let request = crate::schema::Request::from(
                self.static_where_call(arg, func)?,
            );
            let response = self.client.call(request)?;
            <crate::services::krpc::Expression>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl KRPC {
        pub(crate) fn get_client_id_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(crate::client::Client::proc_call("KRPC", "GetClientID", vec![]))
        }
        pub fn get_client_id_stream(
            &self,
        ) -> Result<crate::stream::Stream<Vec<u8>>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_client_id_call()?)
        }
        pub fn get_client_id(&self) -> Result<Vec<u8>, RpcError> {
            let request = crate::schema::Request::from(self.get_client_id_call()?);
            let response = self.client.call(request)?;
            <Vec<u8>>::from_response(response, self.client.clone())
        }
    }
    impl KRPC {
        pub(crate) fn get_client_name_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(crate::client::Client::proc_call("KRPC", "GetClientName", vec![]))
        }
        pub fn get_client_name_stream(
            &self,
        ) -> Result<crate::stream::Stream<String>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_client_name_call()?)
        }
        pub fn get_client_name(&self) -> Result<String, RpcError> {
            let request = crate::schema::Request::from(self.get_client_name_call()?);
            let response = self.client.call(request)?;
            <String>::from_response(response, self.client.clone())
        }
    }
    impl KRPC {
        pub(crate) fn get_services_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(crate::client::Client::proc_call("KRPC", "GetServices", vec![]))
        }
        pub fn get_services_stream(
            &self,
        ) -> Result<crate::stream::Stream<crate::schema::Services>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_services_call()?)
        }
        pub fn get_services(&self) -> Result<crate::schema::Services, RpcError> {
            let request = crate::schema::Request::from(self.get_services_call()?);
            let response = self.client.call(request)?;
            <crate::schema::Services>::from_response(response, self.client.clone())
        }
    }
    impl KRPC {
        pub(crate) fn get_status_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(crate::client::Client::proc_call("KRPC", "GetStatus", vec![]))
        }
        pub fn get_status_stream(
            &self,
        ) -> Result<crate::stream::Stream<crate::schema::Status>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_status_call()?)
        }
        pub fn get_status(&self) -> Result<crate::schema::Status, RpcError> {
            let request = crate::schema::Request::from(self.get_status_call()?);
            let response = self.client.call(request)?;
            <crate::schema::Status>::from_response(response, self.client.clone())
        }
    }
    impl KRPC {
        pub(crate) fn remove_stream_call(
            &self,
            id: u64,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KRPC",
                    "RemoveStream",
                    vec![id.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn remove_stream_stream(
            &self,
            id: u64,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.remove_stream_call(id)?)
        }
        pub fn remove_stream(&self, id: u64) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.remove_stream_call(id)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl KRPC {
        pub(crate) fn set_stream_rate_call(
            &self,
            id: u64,
            rate: f32,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KRPC",
                    "SetStreamRate",
                    vec![
                        id.to_argument(0usize as u32) ?, rate.to_argument(1usize as u32)
                        ?
                    ],
                ),
            )
        }
        pub fn set_stream_rate_stream(
            &self,
            id: u64,
            rate: f32,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.set_stream_rate_call(id, rate)?,
            )
        }
        pub fn set_stream_rate(&self, id: u64, rate: f32) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(
                self.set_stream_rate_call(id, rate)?,
            );
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl KRPC {
        pub(crate) fn start_stream_call(
            &self,
            id: u64,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KRPC",
                    "StartStream",
                    vec![id.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn start_stream_stream(
            &self,
            id: u64,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.start_stream_call(id)?)
        }
        pub fn start_stream(&self, id: u64) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.start_stream_call(id)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
    impl Type {
        pub(crate) fn static_bool_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(crate::client::Client::proc_call("KRPC", "Type_static_Bool", vec![]))
        }
        pub fn static_bool_stream(
            &self,
        ) -> Result<crate::stream::Stream<crate::services::krpc::Type>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.static_bool_call()?)
        }
        pub fn static_bool(&self) -> Result<crate::services::krpc::Type, RpcError> {
            let request = crate::schema::Request::from(self.static_bool_call()?);
            let response = self.client.call(request)?;
            <crate::services::krpc::Type>::from_response(response, self.client.clone())
        }
    }
    impl Type {
        pub(crate) fn static_double_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(crate::client::Client::proc_call("KRPC", "Type_static_Double", vec![]))
        }
        pub fn static_double_stream(
            &self,
        ) -> Result<crate::stream::Stream<crate::services::krpc::Type>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.static_double_call()?)
        }
        pub fn static_double(&self) -> Result<crate::services::krpc::Type, RpcError> {
            let request = crate::schema::Request::from(self.static_double_call()?);
            let response = self.client.call(request)?;
            <crate::services::krpc::Type>::from_response(response, self.client.clone())
        }
    }
    impl Type {
        pub(crate) fn static_float_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(crate::client::Client::proc_call("KRPC", "Type_static_Float", vec![]))
        }
        pub fn static_float_stream(
            &self,
        ) -> Result<crate::stream::Stream<crate::services::krpc::Type>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.static_float_call()?)
        }
        pub fn static_float(&self) -> Result<crate::services::krpc::Type, RpcError> {
            let request = crate::schema::Request::from(self.static_float_call()?);
            let response = self.client.call(request)?;
            <crate::services::krpc::Type>::from_response(response, self.client.clone())
        }
    }
    impl Type {
        pub(crate) fn static_int_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(crate::client::Client::proc_call("KRPC", "Type_static_Int", vec![]))
        }
        pub fn static_int_stream(
            &self,
        ) -> Result<crate::stream::Stream<crate::services::krpc::Type>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.static_int_call()?)
        }
        pub fn static_int(&self) -> Result<crate::services::krpc::Type, RpcError> {
            let request = crate::schema::Request::from(self.static_int_call()?);
            let response = self.client.call(request)?;
            <crate::services::krpc::Type>::from_response(response, self.client.clone())
        }
    }
    impl Type {
        pub(crate) fn static_string_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(crate::client::Client::proc_call("KRPC", "Type_static_String", vec![]))
        }
        pub fn static_string_stream(
            &self,
        ) -> Result<crate::stream::Stream<crate::services::krpc::Type>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.static_string_call()?)
        }
        pub fn static_string(&self) -> Result<crate::services::krpc::Type, RpcError> {
            let request = crate::schema::Request::from(self.static_string_call()?);
            let response = self.client.call(request)?;
            <crate::services::krpc::Type>::from_response(response, self.client.clone())
        }
    }
    impl KRPC {
        pub(crate) fn get_clients_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(crate::client::Client::proc_call("KRPC", "get_Clients", vec![]))
        }
        pub fn get_clients_stream(
            &self,
        ) -> Result<crate::stream::Stream<Vec<(Vec<u8>, String, String)>>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_clients_call()?)
        }
        pub fn get_clients(&self) -> Result<Vec<(Vec<u8>, String, String)>, RpcError> {
            let request = crate::schema::Request::from(self.get_clients_call()?);
            let response = self.client.call(request)?;
            <Vec<
                (Vec<u8>, String, String),
            >>::from_response(response, self.client.clone())
        }
    }
    impl KRPC {
        pub(crate) fn get_current_game_scene_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(crate::client::Client::proc_call("KRPC", "get_CurrentGameScene", vec![]))
        }
        pub fn get_current_game_scene_stream(
            &self,
        ) -> Result<crate::stream::Stream<crate::services::krpc::GameScene>, RpcError> {
            crate::stream::Stream::new(
                self.client.clone(),
                self.get_current_game_scene_call()?,
            )
        }
        pub fn get_current_game_scene(
            &self,
        ) -> Result<crate::services::krpc::GameScene, RpcError> {
            let request = crate::schema::Request::from(
                self.get_current_game_scene_call()?,
            );
            let response = self.client.call(request)?;
            <crate::services::krpc::GameScene>::from_response(
                response,
                self.client.clone(),
            )
        }
    }
    impl KRPC {
        pub(crate) fn get_paused_call(
            &self,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(crate::client::Client::proc_call("KRPC", "get_Paused", vec![]))
        }
        pub fn get_paused_stream(
            &self,
        ) -> Result<crate::stream::Stream<bool>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.get_paused_call()?)
        }
        pub fn get_paused(&self) -> Result<bool, RpcError> {
            let request = crate::schema::Request::from(self.get_paused_call()?);
            let response = self.client.call(request)?;
            <bool>::from_response(response, self.client.clone())
        }
    }
    impl KRPC {
        pub(crate) fn set_paused_call(
            &self,
            value: bool,
        ) -> Result<crate::schema::ProcedureCall, RpcError> {
            Ok(
                crate::client::Client::proc_call(
                    "KRPC",
                    "set_Paused",
                    vec![value.to_argument(0usize as u32) ?],
                ),
            )
        }
        pub fn set_paused_stream(
            &self,
            value: bool,
        ) -> Result<crate::stream::Stream<()>, RpcError> {
            crate::stream::Stream::new(self.client.clone(), self.set_paused_call(value)?)
        }
        pub fn set_paused(&self, value: bool) -> Result<(), RpcError> {
            let request = crate::schema::Request::from(self.set_paused_call(value)?);
            let response = self.client.call(request)?;
            <()>::from_response(response, self.client.clone())
        }
    }
}
